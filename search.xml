<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/04/07/20-54-53/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>算法性能</title>
    <url>/2023/06/23/20-56-15/</url>
    <content><![CDATA[<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h4 id="什么是时间复杂度"><a href="#什么是时间复杂度" class="headerlink" title="什么是时间复杂度"></a>什么是时间复杂度</h4><p>时间复杂度是一个函数，它定性描述该算法的运行时间。</p>
<p>假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。</p>
<p><strong>大O用来表示上界</strong>，但代表的是一般情况，而不是严格的上界。就像快排的时间复杂度是O(nlogn)，但最坏情况下应该是O(n^2)。<strong>大O是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量</strong>。</p>
<p>所以我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大。</p>
<p>O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(nlogn)线性对数阶 &lt; O(n^2)平方阶 &lt; O(n^3)立方阶 &lt; O(2^n)指数阶</p>
<span id="more"></span>

<h4 id="复杂表达式的化简"><a href="#复杂表达式的化简" class="headerlink" title="复杂表达式的化简"></a>复杂表达式的化简</h4><ul>
<li>去掉加法常数项</li>
<li>去掉常数系数</li>
<li>保留最高项</li>
</ul>
<h4 id="log以什么为底"><a href="#log以什么为底" class="headerlink" title="log以什么为底"></a>log以什么为底</h4><p>说logn的时候，通常忽略了底数的描述。这是因为底可以被化简掉，无论以什么为底，套上O后效果都一样</p>
<h2 id="算法为什么会超时"><a href="#算法为什么会超时" class="headerlink" title="算法为什么会超时"></a>算法为什么会超时</h2><p>程序运行的时间超过了规定的时间，一般OJ（online judge）的超时时间就是1s。如果n的规模已经足够让$O(n)$的算法运行时间超过了1s，就应该考虑log(n)的解法了。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2023/06/23/21-00-00/</url>
    <content><![CDATA[<h2 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h2><p>数组是存放在<strong>连续内存空间</strong>上的<strong>相同类型数据</strong>的集合。正是因为数组在内存空间的地址上是连续的，所以在增删元素时，难免要移动其他元素的地址。</p>
<p><strong>数组的元素是不能删的，只能覆盖。</strong></p>
<p>关于二维数组的内存地址空间的连续性问题，不同的编程语言的内存管理不同。在C++中，二维数组是连续分布的；但在Java中二维数组的每一行头结点的地址是没有规则的。</p>
<span id="more"></span>



<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目的前提是数组为<strong>有序数组</strong>，同时题目还强调数组中<strong>无重复元素</strong>。二分法逻辑比较简单，但有两个容易搞错的点，即</p>
<ul>
<li><p><code>while(left &lt; right)</code>    or    <code>while(left &lt;= right)</code></p>
</li>
<li><p><code> right = middle</code>    or     <code>right = middle - 1</code></p>
</li>
</ul>
<p>主要原因在于<strong>对区间的定义没想清楚</strong>，在二分查找时要遵循<strong>循环不变量</strong>原则，区间的定义就是不变量。</p>
<p>区间的一般定义有两种，左闭右闭和左闭右开。因此衍生了两种主要的写法</p>
<h3 id="左闭右闭"><a href="#左闭右闭" class="headerlink" title="左闭右闭"></a>左闭右闭</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left=<span class="number">0</span>,right=nums.<span class="property">length</span>-<span class="number">1</span>,mid=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        mid=(left + right) &gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid]) left=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right=mid-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="左闭右开"><a href="#左闭右开" class="headerlink" title="左闭右开"></a>左闭右开</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left=<span class="number">0</span>,right=nums.<span class="property">length</span>,mid=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        mid=(left + right) &gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid]) left=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ul>
<li>35</li>
<li>34</li>
<li>69</li>
<li>367</li>
</ul>
<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>题目：给定一个数组nums和一个值val，<strong>原地</strong>移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
</blockquote>
<p>问题乍一看很简单，但涉及到数组的底层理论，即：数组元素不能删除，只能覆盖。</p>
<p>有一些库可以轻易实现该操作，例如vector中的erase操作，此题的本质就是实现erase函数。</p>
<h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> length=nums.<span class="property">length</span>; <span class="comment">// 记录下原数组的大小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;length;)&#123; <span class="comment">// 这里不能笼统的i+1，碰到要删除的元素时，元素整体前移，此时i不用+1</span></span><br><span class="line">        <span class="comment">// 此外，i&lt;length,而不是i&lt;nums.length,因为数组是动态变化的，length的值跟随数组变化</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i]==val)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=i;j&lt;length-<span class="number">1</span>;j++)&#123; <span class="comment">// 覆盖待删除元素 </span></span><br><span class="line">                nums[j]=nums[j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            length--; <span class="comment">// length--和for循环的位置不能变，否则for循环中条件要变</span></span><br><span class="line">        &#125;<span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>也叫快慢指针法，定义快慢指针</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">    <span class="comment">// j指针用于遍历原数组，是快指针</span></span><br><span class="line">    <span class="comment">// i指针用于构成新数组，是慢指针</span></span><br><span class="line">    <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;nums.<span class="property">length</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j]!=val)&#123; <span class="comment">// 快指针指向的元素不是待删元素时，可以插入到新数组</span></span><br><span class="line">            nums[i]=nums[j]; <span class="comment">// 插入到新数组中的i指针位置</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="相关题目-1"><a href="#相关题目-1" class="headerlink" title="相关题目"></a>相关题目</h3><ul>
<li><p>26</p>
</li>
<li><p>283</p>
</li>
</ul>
<h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>题目：给定一个 <strong>非递减</strong>的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减</strong> 排序。</p>
</blockquote>
<p>很容易想到暴力的方法，即先遍历数组，取每个元素的平方，再快排。</p>
<h3 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h3><p>观察数组，由于负数的存在，平方后数组中最大的元素在两边。因此可以在<strong>两边各放指针向中间靠拢</strong>，得到由大到小的元素，数组从后往前构造即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedSquares = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> new_num=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++) nums[i]*=nums[i]; <span class="comment">// 先遍历，得到元素的平方</span></span><br><span class="line">    <span class="keyword">var</span> index=nums.<span class="property">length</span>-<span class="number">1</span>,left=<span class="number">0</span>,right=nums.<span class="property">length</span>-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]&gt;nums[right])&#123;</span><br><span class="line">            new_num[index--]=nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            new_num[index--]=nums[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p>也可以从最小的元素向两边扩散，得到由小到大的元素，但处理上比较麻烦</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sortedSquares = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> nums_new=[]</span><br><span class="line">    <span class="keyword">let</span> min=<span class="title class_">Infinity</span></span><br><span class="line">    <span class="keyword">let</span> index</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        nums[i]*=nums[i]</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&lt;min)&#123; <span class="comment">//得到最小值的索引</span></span><br><span class="line">            index=i</span><br><span class="line">            min=nums[i]</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;=<span class="number">0</span>) <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> left=index-<span class="number">1</span>,right=index,k=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;nums.<span class="property">length</span>)&#123; <span class="comment">//从最小值向两边扩散</span></span><br><span class="line">            <span class="keyword">if</span>(nums[right]&lt;nums[left])&#123;</span><br><span class="line">                nums_new[k++]=nums[right]</span><br><span class="line">                right++</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums_new[k++]=nums[left]</span><br><span class="line">                left--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两边多出来的元素再加进新数组，下面两个while只会执行一个</span></span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums_new[k++]=nums[left]</span><br><span class="line">            left--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;nums.<span class="property">length</span>)&#123;</span><br><span class="line">            nums_new[k++]=nums[right]</span><br><span class="line">            right++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums_new</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>思考：为什么这个算法不能原地工作？</strong></p>
<p>如果原地工作，则index初始指向原数组的最后一位，当right指向的元素大于left指向的元素时，只需要把index–即可；但若反过来，则需要把left指向的元素赋到index位置，此时index指向的元素会被覆盖，数组的元素就不对了，即使把index指向的元素先取出来，等覆盖后left位置空出来再赋给left，这样会导致数组元素排列的无序性。</p>
<h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>题目：给定一个含有n个正整数的数组和一个正整数s，找出该数组中满足其和 ≥ s 的<strong>长度最小的连续</strong>子数组，并返回其长度。如果不存在符 合条件的子数组，返回 0。</p>
</blockquote>
<p>暴力方法：两个循环，一个遍历数组起始位置，一个遍历数组结束位置，组合出所有可能的数组位置从而得到长度。</p>
<p>该问题的一个很自然的思路是从小到大列举数组的长度，看最小能满足条件的长度是多少。但这样就需要列举数组长度个 结果。</p>
<p>刚刚那种思路是<strong>固定窗口大小，改变窗口位置</strong>。那能不能<strong>固定窗口位置，改变窗口大小</strong>呢？</p>
<p>由此想到，可以遍历数组，遍历窗口的<strong>起始位置</strong>，增加窗口大小直到满足条件，由此可得在该位置下最小的窗口大小，在一次完整的遍历之后即可得到全局解。<strong>本质上也是双指针</strong>的方法。</p>
<p>但是如果遍历起始位置，其方法与暴力破解没有区别。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="keyword">function</span>(<span class="params">target, nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum,result=<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 以i为头的子数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        j=i;sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(sum&lt;target&amp;&amp;j&lt;nums.<span class="property">length</span>)&#123;</span><br><span class="line">            sum+=nums[j];j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=target)&#123;</span><br><span class="line">            <span class="keyword">if</span>((j-i)&lt;result) result=j-i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result==<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>) result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>那么再换个思路，如果<strong>遍历窗口的结束位置</strong>呢? 在遍历结束位置时，只有<strong>当条件已经满足才后移起始位置</strong>以得到该结束位置下满足条件的最小解。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="keyword">function</span> (<span class="params">target, nums</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result=<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>; <span class="comment">// 全局最优解</span></span><br><span class="line">  <span class="keyword">var</span> sum=<span class="number">0</span>; <span class="comment">// 当前选中数组的和</span></span><br><span class="line">  <span class="keyword">var</span> start=<span class="number">0</span>; <span class="comment">// 初始起始位置为0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> end=<span class="number">0</span>;end&lt;nums.<span class="property">length</span>;end++)&#123;</span><br><span class="line">    sum+=nums[end]; <span class="comment">// 每次先计算数组和</span></span><br><span class="line">    <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">      sum-=nums[start++]; <span class="comment">// 找到该结束位置下满足条件的最小长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      sum += nums[--start]; <span class="comment">// 出循环时已经不满足条件，重新满足条件</span></span><br><span class="line">      result = <span class="title class_">Math</span>.<span class="title function_">min</span>(result, end - start + <span class="number">1</span>); <span class="comment">// 记录结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>) result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 以上写法还有优化的空间</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  for(var end=0;end&lt;nums.length;end++)&#123;</span></span><br><span class="line"><span class="comment">    sum+=nums[end];</span></span><br><span class="line"><span class="comment">    while(sum&gt;=target)&#123;</span></span><br><span class="line"><span class="comment">      result=Math.min(result,end-start+1);</span></span><br><span class="line"><span class="comment">      sum-=nums[start++];</span></span><br><span class="line"><span class="comment">    &#125; // 出while时不满足&gt;=target条件，直接end++，上面已经记录过结果</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  return result==Number.MAX_VALUE?0:result;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，每个元素在滑动窗后进来和出去各操作一次，复杂度为2×n</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>只要思想对，写法可以有很多种</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="keyword">function</span>(<span class="params">target, nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="title class_">Infinity</span></span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>,right=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> sum=nums[<span class="number">0</span>] <span class="comment">//sum初始为nums[0]</span></span><br><span class="line">    <span class="keyword">while</span>(right&lt;nums.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(sum&gt;=target)&#123; <span class="comment">//这里千万不能写成if</span></span><br><span class="line">            res=<span class="title class_">Math</span>.<span class="title function_">min</span>(right-left+<span class="number">1</span>,res)</span><br><span class="line">            sum-=nums[left++]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(sum&lt;target)&#123;</span><br><span class="line">            sum+=nums[++right] <span class="comment">//right初始为0，要先++</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res==<span class="title class_">Infinity</span>?<span class="number">0</span>:res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="相关题目-2"><a href="#相关题目-2" class="headerlink" title="相关题目"></a>相关题目</h3><ul>
<li>904</li>
</ul>
<h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>题目：给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
</blockquote>
<p>这道题并没有涉及到什么算法，而是一道模拟题。在循环时一定要遵循<strong>循环不变量</strong>原则，判断边界时确定好左闭右开 ，循环时就用左闭右开</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 左闭右开原则</span></span><br><span class="line"><span class="keyword">var</span> generateMatrix = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(n/<span class="number">2</span>);<span class="comment">//上取整</span></span><br><span class="line">    <span class="keyword">var</span> ans=<span class="keyword">new</span> <span class="title class_">Array</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;n;i++) ans[i]=<span class="keyword">new</span> <span class="title class_">Array</span>(n);<span class="comment">// 构造数组</span></span><br><span class="line">    <span class="keyword">var</span> index=<span class="number">1</span>; <span class="comment">// 填入数组中的数字</span></span><br><span class="line">    <span class="keyword">var</span> col=<span class="number">0</span>; <span class="comment">// 列</span></span><br><span class="line">    <span class="keyword">var</span> row=<span class="number">0</span>; <span class="comment">// 行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">1</span>;j&lt;=count;j++)&#123; </span><br><span class="line">        <span class="keyword">var</span> temp=n-(<span class="number">2</span>*j-<span class="number">1</span>); <span class="comment">// 该循环次数下，每条边要填几个数字</span></span><br><span class="line">        <span class="comment">// 四条边的循环填入数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;temp;i++) ans[row][col++]=index++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;temp;i++) ans[row++][col]=index++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;temp;i++) ans[row][col--]=index++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;temp;i++) ans[row--][col]=index++;</span><br><span class="line">        row++;col++;<span class="comment">// 回到下一次循环的正确位置</span></span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="number">0</span>) ans[--row][--col]=index; <span class="comment">// n为奇数时，最后一个数组填不上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 O(n^2)</li>
<li>空间复杂度 O(1)</li>
</ul>
<h3 id="相关题目-3"><a href="#相关题目-3" class="headerlink" title="相关题目"></a>相关题目</h3><ul>
<li>54</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>二分法</li>
<li>双指针法</li>
<li>滑动窗口法</li>
<li>模拟行为</li>
</ul>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png" alt="img"  />

<p>7.24日二刷</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2023/06/26/09-00-00/</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>不同于数组在内存中的连续分布，链表中的结点<strong>散乱分布</strong>在内存中，通过指针域的指针链接各个结点。</p>
<h3 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">	val;</span><br><span class="line">	next=<span class="literal">null</span>;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">value</span>)&#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">val</span>=value;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">next</span>=<span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表对比数组"><a href="#链表对比数组" class="headerlink" title="链表对比数组"></a>链表对比数组</h3><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195200276.png" alt="链表-链表与数据性能对比"></p>
<span id="more"></span>

<h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><blockquote>
<p>题目：删除链表中等于给定值 val 的所有结点。</p>
</blockquote>
<p>题目本身并不难，可以在链表中直接删除。但是如果头指针也要删除就需要特殊处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElements = <span class="keyword">function</span>(<span class="params">head, val</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>&amp;&amp;head.<span class="property">val</span>==val)&#123; </span><br><span class="line">        <span class="comment">//确保head不为null，否则head.val报错</span></span><br><span class="line">        <span class="comment">// 对需要删除的头结点单独处理</span></span><br><span class="line">        head=head.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span>) <span class="keyword">return</span> head; <span class="comment">// 如果本身为空或全删完了</span></span><br><span class="line">    <span class="keyword">var</span> ret=head;</span><br><span class="line">    <span class="keyword">while</span>(head.<span class="property">next</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.<span class="property">next</span>.<span class="property">val</span>==val) head.<span class="property">next</span>=head.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">else</span> head=head.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<p>有没有对所有结点一视同仁的方法呢？答案是在头结点之前添加一个<strong>虚拟头结点</strong>，这是处理链表常用的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElements = <span class="keyword">function</span>(<span class="params">head, val</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    list.<span class="property">next</span>=head; <span class="comment">// 设立虚头结点</span></span><br><span class="line">    <span class="keyword">var</span> ret=list;</span><br><span class="line">    <span class="keyword">while</span>(ret.<span class="property">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ret.<span class="property">next</span>.<span class="property">val</span>==val)&#123;</span><br><span class="line">            ret.<span class="property">next</span>=ret.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> ret=ret.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><blockquote>
<p>题目：实现链表的增删改查函数</p>
</blockquote>
<p>注意：头指针不能动</p>
<p><strong>在尾插时，不能遍历到null后直接将temp设为新结点，因为在js中变量存储的是对象的引用而不是对象本身。如果直接在 temp 为 null 时将其赋值为新节点,那么只是改变了 temp 变量的值，而没有影响到原来链表中任何一个节点的 next 引用。原链表的结构没有任何变化,新节点并没有插入到链表中。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MyLinkedList</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">index</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span> (<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="variable language_">this</span>.<span class="property">size</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> list = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">head</span>);<span class="comment">//虚头结点</span></span><br><span class="line">  <span class="keyword">while</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    list = list.<span class="property">next</span>;</span><br><span class="line">    index--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list.<span class="property">val</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addAtHead</span> = <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> list = <span class="keyword">new</span> <span class="title class_">Node</span>(val, <span class="variable language_">this</span>.<span class="property">head</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">head</span> = list;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addAtTail</span> = <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(val, <span class="literal">null</span>); <span class="comment">// 定义待插入结点</span></span><br><span class="line">  <span class="keyword">var</span> temp = <span class="variable language_">this</span>.<span class="property">head</span>; <span class="comment">// 遍历指针</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">head</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = node; <span class="variable language_">this</span>.<span class="property">size</span>++; <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (temp.<span class="property">next</span> != <span class="literal">null</span>) temp = temp.<span class="property">next</span>;</span><br><span class="line">  temp.<span class="property">next</span> = node;</span><br><span class="line">  <span class="comment">//不能像下面这样写</span></span><br><span class="line">  <span class="comment">//while (temp != null) temp = temp.next;</span></span><br><span class="line">  <span class="comment">//temp = node;</span></span><br><span class="line">  <span class="comment">//temp为null后赋值加不到原队列中去</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; index </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addAtIndex</span> = <span class="keyword">function</span> (<span class="params">index, val</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="variable language_">this</span>.<span class="property">size</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(val, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">var</span> list = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">head</span>);</span><br><span class="line">  <span class="keyword">var</span> result=list;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">head</span> == <span class="literal">null</span>) &#123; <span class="variable language_">this</span>.<span class="property">head</span> = node;<span class="variable language_">this</span>.<span class="property">size</span>++; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    index--; list = list.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">  node.<span class="property">next</span> = list.<span class="property">next</span>;</span><br><span class="line">  list.<span class="property">next</span> = node;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">head</span>=result.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">index</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">deleteAtIndex</span> = <span class="keyword">function</span> (<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="variable language_">this</span>.<span class="property">size</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">var</span> temp = index;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span>--;</span><br><span class="line">  <span class="keyword">var</span> list = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">head</span>);</span><br><span class="line">  <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    index--; list = list.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  list.<span class="property">next</span> = list.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">  <span class="keyword">if</span> (temp == <span class="number">0</span>) <span class="variable language_">this</span>.<span class="property">head</span> = list.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><blockquote>
<p>题目：反转一个单链表。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,<span class="literal">null</span>); <span class="comment">// 构造带虚头结点的链表</span></span><br><span class="line">    <span class="keyword">var</span> new_node;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123; <span class="comment">// 遍历原链表</span></span><br><span class="line">        new_node=<span class="keyword">new</span> <span class="title class_">ListNode</span>(head.<span class="property">val</span>,<span class="literal">null</span>);</span><br><span class="line">        new_node.<span class="property">next</span>=ret.<span class="property">next</span>; <span class="comment">// 头插法</span></span><br><span class="line">        ret.<span class="property">next</span>=new_node;</span><br><span class="line">        head=head.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>可以实现原地翻转</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> cur=head;</span><br><span class="line">    <span class="keyword">var</span> pre=<span class="literal">null</span>;<span class="comment">// pre始终在cur左边，即反转以后cur.next=pre</span></span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">        head=head.<span class="property">next</span>;</span><br><span class="line">        cur.<span class="property">next</span>=pre;</span><br><span class="line">        <span class="comment">// 把pre和cur都向右移动一个元素</span></span><br><span class="line">        pre=cur;</span><br><span class="line">        cur=head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre; <span class="comment">// 最终head和cur都为null，pre是反转之后的head</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h3 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverse = <span class="keyword">function</span>(<span class="params">pre,cur</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="literal">null</span>) <span class="keyword">return</span> pre;</span><br><span class="line">    <span class="keyword">var</span> temp=cur.<span class="property">next</span>;</span><br><span class="line">    cur.<span class="property">next</span>=pre;</span><br><span class="line">    pre=cur;</span><br><span class="line">    cur=temp;<span class="comment">//一次反转操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reverse</span>(pre,cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reverse</span>(<span class="literal">null</span>,head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n), 要递归处理链表的每个结点</li>
<li>空间复杂度: O(n), 递归调用了 n 层栈空间</li>
</ul>
<h2 id="交换结点"><a href="#交换结点" class="headerlink" title="交换结点"></a>交换结点</h2><blockquote>
<p>题目：给定一个链表，两两交换其中相邻的结点，并返回交换后的链表。不能只是单纯的改变结点内部的值，而是需要实际的进行结点交换。</p>
</blockquote>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> temp=head;</span><br><span class="line">    <span class="keyword">var</span> pre=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">    <span class="title function_">swap</span>(temp,pre);</span><br><span class="line">    <span class="keyword">return</span> pre.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> swap = <span class="keyword">function</span>(<span class="params">cur,pre</span>) &#123; </span><br><span class="line">    <span class="comment">// 交换cur和cur.next,pre.next=cur;</span></span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="literal">null</span>||cur.<span class="property">next</span>==<span class="literal">null</span>) <span class="keyword">return</span>; <span class="comment">// 剩余结点不足两个，无法交换</span></span><br><span class="line">    <span class="keyword">var</span> temp=cur.<span class="property">next</span>;</span><br><span class="line">    <span class="comment">// 交换开始</span></span><br><span class="line">    cur.<span class="property">next</span>=cur.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    temp.<span class="property">next</span>=cur;</span><br><span class="line">    pre.<span class="property">next</span>=temp;</span><br><span class="line">    <span class="comment">// 交换结束</span></span><br><span class="line">    <span class="comment">// 指针扫过已交换的元素，为下次交换准备</span></span><br><span class="line">    pre=cur;</span><br><span class="line">    cur=cur.<span class="property">next</span></span><br><span class="line">    <span class="title function_">swap</span>(cur,pre); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ret=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head) <span class="comment">//虚拟头结点</span></span><br><span class="line">    <span class="keyword">let</span> temp=ret</span><br><span class="line">    <span class="keyword">while</span>(temp.<span class="property">next</span>&amp;&amp;temp.<span class="property">next</span>.<span class="property">next</span>)&#123; <span class="comment">///每次交换temp后面的两个结点</span></span><br><span class="line">        <span class="keyword">let</span> cur=temp.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">        <span class="keyword">let</span> pre=temp.<span class="property">next</span></span><br><span class="line">        temp.<span class="property">next</span>=cur</span><br><span class="line">        pre.<span class="property">next</span>=cur.<span class="property">next</span></span><br><span class="line">        cur.<span class="property">next</span>=pre</span><br><span class="line">        temp=pre</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="删除倒数第N个结点"><a href="#删除倒数第N个结点" class="headerlink" title="删除倒数第N个结点"></a>删除倒数第N个结点</h2><blockquote>
<p>题目：删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 设两个指针，让他们相隔n位，同时后移</span></span><br><span class="line"><span class="comment">// 右边的指针到尾巴时，左边的指针刚好到待删元素的前一位</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span>(<span class="params">head, n</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">    <span class="keyword">var</span> pre=list;</span><br><span class="line">    <span class="keyword">var</span> behind=list;</span><br><span class="line">    <span class="keyword">if</span>(head.<span class="property">next</span>==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        pre=pre.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pre!=<span class="literal">null</span>&amp;&amp;pre.<span class="property">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">        pre=pre.<span class="property">next</span>;</span><br><span class="line">        behind=behind.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    behind.<span class="property">next</span>=behind.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">return</span> list.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><blockquote>
<p>题目：给你两个单链表的头结点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始结点。如果两个链表没有交点，返回 <code>null</code> 。</p>
</blockquote>
<p>很容易想到暴力的方法，遍历headA和headB</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">headA</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">headB</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="keyword">function</span>(<span class="params">headA, headB</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(headA==<span class="literal">null</span>||headB==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(headA!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> head=headB</span><br><span class="line">        <span class="keyword">while</span>(headB!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(headA==headB) <span class="keyword">return</span> headA;</span><br><span class="line">            headB=headB.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        headA=headA.<span class="property">next</span>;</span><br><span class="line">        headB=head; <span class="comment">// headB每次从头开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n^2)</li>
<li>空间复杂度: O(1)</li>
</ul>
<p>换一种思路，如果能让headA和headB在平行位置上一起移动，遍历一遍之后很容易得到结果。而headA和headB在长度上不一样，抓住这个<strong>长度差</strong>，让更长的率先移动直到长度相同即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">headA</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">headB</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="keyword">function</span>(<span class="params">headA, headB</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> lenA=<span class="number">0</span>,lenB=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> tempA=headA,tempB=headB;</span><br><span class="line">    <span class="keyword">while</span>(tempA!=<span class="literal">null</span>)&#123;</span><br><span class="line">        lenA++;</span><br><span class="line">        tempA=tempA.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tempB!=<span class="literal">null</span>)&#123;</span><br><span class="line">        lenB++;</span><br><span class="line">        tempB=tempB.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="comment">// 先得到headA和headB的长度</span></span><br><span class="line">    <span class="keyword">if</span>(lenA&gt;lenB)&#123;</span><br><span class="line">        <span class="keyword">var</span> len=lenA-lenB;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++) headA=headA.<span class="property">next</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lenB&gt;lenA)&#123;</span><br><span class="line">        <span class="keyword">var</span> len=lenB-lenA;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++) headB=headB.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="comment">// 消耗更长的一方的多余长度</span></span><br><span class="line">    <span class="keyword">while</span>(headA!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==headB) <span class="keyword">return</span> headA;</span><br><span class="line">        headA=headA.<span class="property">next</span>;</span><br><span class="line">        headB=headB.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//没有交点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><blockquote>
<p>题目：给定一个链表的头结点  <code>head</code> ，返回链表开始入环的第一个结点。 如果链表无环，则返回 <code>null</code>。</p>
</blockquote>
<p>这道题目其实包含了两个问题：</p>
<ul>
<li>判断有没有环<ul>
<li>环的特点就是无论后移多少次，始终在环里转圈。根据这个特点可以定义快慢指针，快指针每次前进两格，慢指针每次前进一格。若两指针能相遇，则说明有环。</li>
</ul>
</li>
<li>找到环的入口<ul>
<li>设头结点到环的入口结点距离为x，由于快指针每次比慢指针多走1格，因此他们一定在<strong>慢指针没走满一圈环的时候相遇</strong>，设入口结点到相遇结点的距离为y，环中剩下的距离为z</li>
<li><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png" alt="img"></li>
<li>则fast指针走过的结点数&#x3D;slow指针走过的结点数*2：<code>(x + y) * 2 = x + y + n (y + z)</code>（假设fast指针在环内走了n圈遇到慢指针，必定有n&gt;&#x3D;1）</li>
<li>最后是要求x，把x放一边：<code>x = (n - 1) (y + z) + z</code></li>
<li><strong>在头结点定义index1指针，相遇结点定义index2指针，让他们同时同速移动，他们第一次相遇的结点就是环的入口结点</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到相遇结点</span></span><br><span class="line">    <span class="keyword">var</span> fast=head,slow=head;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">null</span>)&#123;</span><br><span class="line">        fast=fast.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// fast为空说明没有环</span></span><br><span class="line">        fast=fast.<span class="property">next</span>; <span class="comment">// fast要连移两步,中间要判断一下是否为空，否则有可能空指针</span></span><br><span class="line">        slow=slow.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(fast==slow)&#123; <span class="comment">// 相遇结点</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fast==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 求结点入口</span></span><br><span class="line">    <span class="keyword">var</span> index1=head,index2=fast;</span><br><span class="line">    <span class="keyword">while</span>(index1!=index2)&#123; <span class="comment">// index1和index2首次相遇的地方就是结点入口</span></span><br><span class="line">        index1=index1.<span class="property">next</span>;</span><br><span class="line">        index2=index2.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)<ul>
<li>快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个index指针走的次数也小于链表长度，总体为走的次数小于 2n</li>
</ul>
</li>
<li>空间复杂度: O(1)</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很多时候对链表头结点的处理要单独考虑，为链表设立<strong>虚拟头结点</strong>可以更方便。</p>
<p>双指针法在链表的应用也很广泛，特别是涉及到距离时。</p>
<p>7.26二刷结束</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2023/06/27/12-00-00/</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p> 哈希表也叫散列表，是根据<strong>关键码</strong>的值而<strong>直接进行访问</strong>的数据结构。</p>
</blockquote>
<p>其实数组就是一张哈希表，数组的索引下标就是关键码，通过下标可以直接访问数组中的元素。</p>
<p>一般哈希表用于<strong>快速判断一个元素是否出现在集合中</strong>，是一种空间换时间的策略。</p>
<span id="more"></span>

<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>假如要查询一个名字是否在学校里，只需要初始化把这所学校里学生的名字都存在哈希表里，将学生姓名<strong>映射到哈希表</strong>上就涉及到了hash function ，也就是哈希函数。</p>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423484818.png" alt="哈希表2" style="zoom: 67%;" />



<h3 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h3><p>即不同的名字映射到了同一个索引上。</p>
<h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>发生碰撞的元素都被存储在以该索引为头结点的链表中。</p>
<p>这种方法要选择适当的哈希表的大小，既不会因为哈希表数组空而浪费内存，也不会因为链表长而在查找上浪费时间。</p>
<h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><p>首先要确保tableSize大于dataSize。这种方法就是给产生碰撞的元素再找一个空位放置，根据不同的找空位方法还可细分。</p>
<h3 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h3><ol>
<li><p>数组</p>
</li>
<li><p>set(集合)</p>
</li>
<li><p>map(映射)</p>
</li>
</ol>
<h2 id="字母异位词"><a href="#字母异位词" class="headerlink" title="字母异位词"></a>字母异位词</h2><blockquote>
<p>题目：给定两个字符串 s 和 t ，判断s 和 t 中每个字符出现的次数是否相同。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// charCodeAt()方法，返回字符串第一个字符的Unicode编码值</span></span><br><span class="line"><span class="comment">// for..in可遍历Array, Object对象，且会遍历到新添加的成员属性。(历史遗留)</span></span><br><span class="line"><span class="comment">// for..of可遍历iterable可被迭代的对象(不包括Object)。且只遍历属于对象本身的属性。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">t</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用数组的解法</span></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>!=t.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">var</span> base=<span class="string">&quot;a&quot;</span>.<span class="title function_">charCodeAt</span>();<span class="comment">//获取a的unicode编码值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> s)&#123;</span><br><span class="line">        arr[i.<span class="title function_">charCodeAt</span>()-base]++;<span class="comment">//统计s串中各字符的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> t)&#123;</span><br><span class="line">        arr[i.<span class="title function_">charCodeAt</span>()-base]--;</span><br><span class="line">        <span class="keyword">if</span>(arr[i.<span class="title function_">charCodeAt</span>()-base]&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用map的解法</span></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>!=t.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> s)&#123;</span><br><span class="line">        <span class="keyword">var</span> temp=arr.<span class="title function_">get</span>(i)||<span class="number">0</span>;</span><br><span class="line">        arr.<span class="title function_">set</span>(i,temp+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!arr.<span class="title function_">get</span>(i)) <span class="comment">// 这里包含了两种情况，一是为0，二是undefined </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        arr.<span class="title function_">set</span>(i, arr.<span class="title function_">get</span>(i)-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ul>
<li>383</li>
<li>49</li>
</ul>
<h2 id="数组交集"><a href="#数组交集" class="headerlink" title="数组交集"></a>数组交集</h2><blockquote>
<p>题目：给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回它们的交集 。输出结果中的每个元素一定是唯一的。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersection = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> num1=<span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">var</span> ret=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> nums1)&#123;</span><br><span class="line">        num1.<span class="title function_">add</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> nums2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1.<span class="title function_">has</span>(i)&amp;&amp;!ret.<span class="title function_">includes</span>(i)) ret.<span class="title function_">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="相关题目-1"><a href="#相关题目-1" class="headerlink" title="相关题目"></a>相关题目</h3><ul>
<li>350</li>
</ul>
<h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><blockquote>
<p>题目：判断一个数 <code>n</code> 是不是快乐数</p>
<p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。</p>
</blockquote>
<p>本题的重点在于无限循环，如果不是快乐数，计算出来的平方和一定会出现重复</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isHappy = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> list=<span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">let</span> num=<span class="title function_">mySum</span>(n);</span><br><span class="line">    <span class="keyword">while</span>(num!=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.<span class="title function_">has</span>(num)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        list.<span class="title function_">add</span>(num);</span><br><span class="line">        num=<span class="title function_">mySum</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 计算一个数字各数位的平方和</span></span><br><span class="line"><span class="keyword">var</span> mySum = <span class="keyword">function</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">10</span>) <span class="keyword">return</span> n*n;</span><br><span class="line">    <span class="keyword">let</span> str=n+<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">0</span>;</span><br><span class="line">    str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">i</span>=&gt;</span>&#123;res+=<span class="title class_">Number</span>(i)*<span class="title class_">Number</span>(i)&#125;)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><blockquote>
<p>题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
</blockquote>
<p>本题的思路是在遍历时寻找元素匹配的另一半是否出现过，很自然想到用哈希表。常用的哈希表中，如果用数组会造成大量空间浪费；用set会出错（3+3&#x3D;6）,所以map比较合适</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> list=<span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> minus=target-nums[i] <span class="comment">// 差值</span></span><br><span class="line">        <span class="keyword">if</span>(list.<span class="title function_">has</span>(minus))&#123;</span><br><span class="line">            <span class="keyword">return</span> [list.<span class="title function_">get</span>(minus),i]</span><br><span class="line">        &#125;</span><br><span class="line">        list.<span class="title function_">set</span>(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加"></a>四数相加</h2><blockquote>
<p>题目：给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p>
<ul>
<li>0 &lt;&#x3D; i, j, k, l &lt; n</li>
<li>nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0</li>
</ul>
</blockquote>
<p>将四个数组两两一组，分别遍历两个数组中不同元素之和的所有情况，得到一个数组和一个map。之后遍历该数组，在map查找有无与之匹配的解，map中的value存放的是出现这个和的次数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums3</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums4</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fourSumCount = <span class="keyword">function</span>(<span class="params">nums1, nums2, nums3, nums4</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> list1=<span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// nums1和nums2的遍历组合</span></span><br><span class="line">    <span class="keyword">let</span> list2=[] <span class="comment">// nums3和nums4的遍历组合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums1.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;nums2.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">let</span> temp=nums1[i]+nums2[j]</span><br><span class="line">            <span class="keyword">let</span> num=list1.<span class="title function_">get</span>(temp)</span><br><span class="line">            list1.<span class="title function_">set</span>(temp,num==<span class="literal">undefined</span>?<span class="number">1</span>:num+<span class="number">1</span>) <span class="comment">// 构造list1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums3.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;nums4.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            list2.<span class="title function_">push</span>(nums3[i]+nums4[j]); <span class="comment">// 构造list2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;list2.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> val=<span class="number">0</span>-list2[i];</span><br><span class="line">        <span class="keyword">if</span>(list1.<span class="title function_">get</span>(val)!=<span class="literal">undefined</span>) res+=list1.<span class="title function_">get</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n^2)</li>
<li>空间复杂度: O(n^2)，最坏情况下A和B的值各不相同，相加产生的数字个数为 n^2</li>
</ul>
<h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><blockquote>
<p>题目：给定一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。返回所有和为 0 且不重复的三元组。</p>
<p><strong>答案中不可以包含重复的三元组</strong></p>
</blockquote>
<p>注意题目条件：<strong>答案中不可以包含重复的三元组</strong>，即使有两组三元组均满足条件，但若内部元素值一样，则违反了这个条件</p>
<p>这道题用哈希法来做会遇到一个很棘手的问题，就是题目里说的不能包含重复的三元组。对重复的三元组去重很麻烦，也很费时。所以<strong>哈希法并不合适</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> list = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Set</span>() <span class="comment">// 用于去除重复数组，但set不能去除重复数组</span></span><br><span class="line">  <span class="keyword">let</span> ans=[]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> num = list.<span class="title function_">get</span>(nums[i])</span><br><span class="line">    list.<span class="title function_">set</span>(nums[i], num == <span class="literal">undefined</span> ? <span class="number">1</span> : num + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> num = list.<span class="title function_">get</span>(nums[i])</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="literal">undefined</span>) <span class="keyword">continue</span></span><br><span class="line">    list.<span class="title function_">set</span>(nums[i], num - <span class="number">1</span> == <span class="number">0</span> ? <span class="literal">undefined</span> : num - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> numm = list.<span class="title function_">get</span>(nums[j])</span><br><span class="line">      <span class="keyword">if</span>(numm==<span class="literal">undefined</span>) <span class="keyword">continue</span></span><br><span class="line">      list.<span class="title function_">set</span>(nums[j], numm - <span class="number">1</span> == <span class="number">0</span> ? <span class="literal">undefined</span> : numm - <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">let</span> tar = <span class="number">0</span> - nums[i] - nums[j];</span><br><span class="line">      <span class="keyword">if</span> (list.<span class="title function_">get</span>(tar) != <span class="literal">undefined</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp=<span class="keyword">new</span> <span class="title class_">Array</span>()</span><br><span class="line">        res.<span class="title function_">add</span>([nums[i], nums[j], tar].<span class="title function_">sort</span>())</span><br><span class="line">        list.<span class="title function_">set</span>(tar, list.<span class="title function_">get</span>(tar) - <span class="number">1</span> == <span class="number">0</span> ? <span class="literal">undefined</span> : list.<span class="title function_">get</span>(tar) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">//list.set(nums[j], list.get(nums[j]) == undefined ? 1 : list.get(nums[j]) + 1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//list.set(nums[i], list.get(nums[i]) == undefined ? 1 : list.get(nums[i]) + 1)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> res) ans.<span class="title function_">push</span>(i)</span><br><span class="line">  <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>本题使用双指针法的重要前置操作是<strong>数组排序</strong>。整体思路比较简单，但<strong>如何去重是关键</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans=[]</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b) <span class="comment">//从小到大排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="comment">// 对i指针去重</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; </span><br><span class="line">        <span class="keyword">let</span> left=i+<span class="number">1</span>,right=nums.<span class="property">length</span>-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]&gt;<span class="number">0</span>) right--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]&lt;<span class="number">0</span>) left++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans.<span class="title function_">push</span>([nums[i],nums[left],nums[right]])</span><br><span class="line">                <span class="comment">// 对right去重</span></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right-<span class="number">1</span>]) right--;</span><br><span class="line">                <span class="comment">// 对left去重</span></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                left++;right--</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><blockquote>
<p>题目：给定一个整数数组 nums ，返回所有和为 0 且不重复的四元组。</p>
</blockquote>
<p>四数之和与三数之和本质上都是一个做法，套两个循环，<code>nums[i]</code>和<code>nums[j]</code>为定值，设头尾指针移动。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fourSum = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">4</span>) <span class="keyword">return</span> [];</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 去重i</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 去重j</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] === nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">let</span> l = j + <span class="number">1</span>, r = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">const</span> sum = nums[i] + nums[j] + nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; target) &#123; l++; <span class="keyword">continue</span>&#125;</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; target) &#123; r--; <span class="keyword">continue</span>&#125;</span><br><span class="line">                res.<span class="title function_">push</span>([nums[i], nums[j], nums[l], nums[r]]);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 对nums[left]和nums[right]去重</span></span><br><span class="line">                <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] === nums[++l]);</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] === nums[--r]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="数组的缺陷"><a href="#数组的缺陷" class="headerlink" title="数组的缺陷"></a>数组的缺陷</h3><ul>
<li>数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。</li>
<li>如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</li>
</ul>
<h3 id="set的缺陷"><a href="#set的缺陷" class="headerlink" title="set的缺陷"></a>set的缺陷</h3><ul>
<li>set是一个集合，里面放的元素只能是一个key</li>
</ul>
<h3 id="map的缺陷"><a href="#map的缺陷" class="headerlink" title="map的缺陷"></a>map的缺陷</h3><ul>
<li>map可以算是万能的哈希表，但<strong>map要维护红黑树或者符号表，而且还要做哈希函数的运算</strong>，效率不高</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>js基础</title>
    <url>/2023/06/27/20-56-15/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JS &#x3D; ECMAScript(语法) + DOM(页面文档对象模型) + BOM(浏览器对象模型)  </p>
<ul>
<li>DOM和BOM都是Web API</li>
</ul>
<p>文档：</p>
<p><code>https://developer.mozilla.org/zh-CN</code></p>
<p><code>https://developer.mozilla.org/zh-CN/docs/web/javascript</code></p>
<span id="more"></span>

<h3 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h3><p>JavaScript 程序不能独立运行，它需要被嵌入 HTML 中，然后浏览器才能执行 JavaScript 代码。通过 <code>script</code> 标签将 JavaScript 代码引入到 HTML 中，有两种方式：</p>
<h4 id="内部方式"><a href="#内部方式" class="headerlink" title="内部方式"></a>内部方式</h4><p>通过 <code>script</code> 标签包裹 JavaScript 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JavaScript 基础 - 引入方式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--通常写到文件底部，因为浏览器是按照代码顺序加载的，如果先加载的js涉及到修改其下方的html，可能会失败--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&#x27;嗨，欢迎来传智播学习前端技术！&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// js一句代码结束后可以不写;</span></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="外部形式"><a href="#外部形式" class="headerlink" title="外部形式"></a>外部形式</h4><p>一般将 JavaScript 代码写在独立的以 .js 结尾的文件中，然后通过 <code>script</code> 标签的 <code>src</code> 属性引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo.js</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JavaScript 基础 - 引入方式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;demo.js&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  	<span class="comment">// 这里的代码会被忽略</span></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="输入输出语句"><a href="#输入输出语句" class="headerlink" title="输入输出语句"></a>输入输出语句</h3><table>
<thead>
<tr>
<th>方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>alert(msg)</td>
<td align="left">浏览器弹出警示框</td>
</tr>
<tr>
<td>console.log(msg)</td>
<td align="left">浏览器控制台打印输出信息</td>
</tr>
<tr>
<td>prompt(info)</td>
<td align="left">浏览器弹出输入框，用户可以输入</td>
</tr>
<tr>
<td>document.write()</td>
<td align="left">向html文档中输出内容，可以识别标签</td>
</tr>
</tbody></table>
<p>注：<code>alert</code>和<code>prompt</code>会跳过页面渲染先被执行。</p>
<h3 id="let和var"><a href="#let和var" class="headerlink" title="let和var"></a>let和var</h3><p>JavaScript 使用专门的关键字 <code>let</code> 和 <code>var</code> 来声明（定义）变量，在使用时需要注意一些细节：</p>
<p>以下是使用 <code>let</code> 时的注意事项：</p>
<ol>
<li>允许声明时赋值</li>
<li><strong>不允许重复声明</strong></li>
<li>允许同时声明多个变量并赋值</li>
<li>JavaScript 中内置的一些关键字不能被当做变量名</li>
</ol>
<p><code>var</code>和<code>let</code>的区别在于</p>
<ul>
<li><strong>var允许重复声明</strong>。</li>
<li>可以先使用再声明</li>
<li>变量提升，是全局变量，没有块级作用域</li>
</ul>
<p>因此 <code>let</code> 相较 <code>var</code> 更严谨，推荐使用 <code>let</code>。</p>
<h3 id="变量名命名规则"><a href="#变量名命名规则" class="headerlink" title="变量名命名规则"></a>变量名命名规则</h3><p>关于变量的名称（标识符）有一系列的规则需要遵守：</p>
<ol>
<li>只能是字母、数字、下划线、$，且不能能数字开头</li>
<li>字母区分大小写，如 Age 和 age 是不同的变量</li>
<li>JavaScript 内部已占用于单词（关键字或保留字）不允许使用</li>
<li>尽量保证变量具有一定的语义，见字知义</li>
</ol>
<p>注：所谓关键字是指 JavaScript 内部使用的词语，如 <code>let</code> 和<code>var</code>，保留字是指 JavaScript 内部目前没有使用的词语，但是将来可能会使用词语。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>概念：使用 <code>const</code> 声明的变量称为“常量”。</p>
<p>使用场景：当某个变量永远不会改变的时候，就可以使用<code>const</code>来声明，而不是let。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意： 常量不允许重新赋值,声明的时候必须赋值（初始化）</p>
</blockquote>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li><code>==</code> 左右两边值是否相等</li>
<li><code>===</code> 左右两边是否类型和值都相等</li>
<li><code>!=</code> 两边操作数不相等时返回true</li>
<li><code>!==</code> 操作数或类型不等时返回true</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>js中有两大数据类型，分别是<strong>值类型(基本类型)<strong>和</strong>引用类型(对象类型)</strong></p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>基本类型在存储时<strong>变量中存储的是值本身</strong>，存储在栈区</p>
<p>js是<strong>弱数据类型</strong>的语言，主要有五大基本数据类型，可以通过 <code>typeof</code> 关键字检测数据类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typeof有两种使用方法</span></span><br><span class="line"><span class="comment">// 作为运算符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 函数形式</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(<span class="literal">null</span>))</span><br></pre></td></tr></table></figure>

<h4 id="number类型"><a href="#number类型" class="headerlink" title="number类型"></a>number类型</h4><p>包括整数、小数、正数、负数。在number中有一个特殊的值，叫做<code>NaN</code>，代表计算错误，任何对NaN的操作都会返回NaN。</p>
<h4 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h4><p>通过单引号 、双引号或反引号包裹的数据都叫字符串，单引号和双引号没有本质上的区别，推荐使用单引号。</p>
<p>字符串可以拼接，但比较麻烦。</p>
<p>注意事项：</p>
<ol>
<li>无论单引号或是双引号必须成对使用</li>
<li>单引号&#x2F;双引号<strong>可以互相嵌套</strong>，但是不能自已嵌套自已</li>
<li>必要时可以使用转义符 <code>\</code>，输出单引号或双引号</li>
</ol>
<h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age=<span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我&#x27;</span>+age+<span class="string">&#x27;岁&#x27;</span>) <span class="comment">// 字符串拼接</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我<span class="subst">$&#123;age&#125;</span>岁了`</span>) <span class="comment">// 模板字符串，必须用反引号</span></span><br></pre></td></tr></table></figure>



<h4 id="boolean类型"><a href="#boolean类型" class="headerlink" title="boolean类型"></a>boolean类型</h4><h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><p>未定义是比较特殊的类型，只有一个值 undefined。变量未初始化时，其默认值为 undefined。因为js是弱数据类型的语言，未经初始化，解释器也不知道变量是何类型</p>
<p>一般很少【直接】为某个变量赋值为 undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只声明了变量，并末赋值</span></span><br><span class="line"><span class="keyword">let</span> tmp;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="keyword">typeof</span> tmp) <span class="comment">// 结果为 undefined</span></span><br></pre></td></tr></table></figure>

<p>通常用于检查一个数据是否被传递过来</p>
<h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>null表示赋值了，但是内容为空。可以把null作为<strong>尚未创建的对象</strong></p>
<p>如果一个变量里确定存放的是对象，但该对象还没准备好，就可以先放个null</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data=<span class="literal">null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> data); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>+<span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span>+<span class="number">1</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>复杂数据类型，在存储变量时**存储的是地址(引用)**，在栈区存地址，实际存储在堆区</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h5><ul>
<li>push  尾部追加</li>
<li>unshift  头部增加</li>
</ul>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><ul>
<li>pop  删除最后一个</li>
<li>shift   删除第一个</li>
<li>splice(删除的下标，删除的个数)</li>
</ul>
<h5 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr)&#123; <span class="comment">// 通常不同for in遍历数组</span></span><br><span class="line">    <span class="comment">// i是数组的索引号，但是是字符串</span></span><br><span class="line">    arr[i] <span class="comment">// 这样也可以拿到元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> arr) i <span class="comment">// i就是元素</span></span><br></pre></td></tr></table></figure>



<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="命名函数"><a href="#命名函数" class="headerlink" title="命名函数"></a>命名函数</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//函数体代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getSum</span>();</span><br></pre></td></tr></table></figure>



<h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><h6 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;函数表达式&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure>



<h6 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h6><p>避免全局变量之间的污染</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; xxx  &#125;)();</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;xxxx&#125;());</span><br><span class="line"><span class="comment">//多个立即执行函数要用;隔开</span></span><br></pre></td></tr></table></figure>

<h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><p>采取就近原则的方式来查找变量最终的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">&#x27;22&#x27;</span>;</span><br><span class="line">    <span class="title function_">fn2</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">        <span class="title function_">fn3</span>();</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">fn3</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//a的值 4</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">//b的值 22</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>();</span><br></pre></td></tr></table></figure>

<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><h5 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h5><p>对象(object)是一种数据类型，可以理解为一种无序的数据集合。它由<strong>属性和方法</strong>两部分构成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person=&#123; <span class="comment">// 定义对象</span></span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;fj&#x27;</span>,</span><br><span class="line">	<span class="attr">sing</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="property">age</span>=<span class="number">20</span> <span class="comment">// 动态追加属性</span></span><br><span class="line">person[<span class="string">&#x27;age&#x27;</span>]=<span class="number">20</span> <span class="comment">// 这样也能得到属性</span></span><br><span class="line">person.<span class="property">move</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 动态追加方法</span></span><br><span class="line"><span class="comment">//也可以删除属性  delete person.name ，在严格模式下不允许，仅了解</span></span><br></pre></td></tr></table></figure>

<h5 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 得到属性名</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[i]) <span class="comment">// 得到属性值</span></span><br><span class="line">    <span class="comment">// console.log(obj.i) //这个写法是错误的，i是个字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常使用**<code>for in</code>遍历对象，其遍历的是键名，遍历的结果是个字符串**；<code>for of</code>遍历带有iterator接口的，例如set、map、array</p>
<h5 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h5><p>如<code>Math</code>、<code>Date</code>、<code>Number</code>等</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>某些运算符被执行时，<strong>系统内部自动将数据类型进行转换</strong>，这种转换称为隐式转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">13</span> <span class="comment">// 数值</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="string">&#x27;2&#x27;</span> <span class="comment">// 字符串</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num + num2) <span class="comment">//字符串拼接 132</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num - num2) <span class="comment">//数字加减 11</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num * num2) <span class="comment">// 26</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="string">&#x27;12&#x27;</span>) <span class="comment">// 转为数字型</span></span><br></pre></td></tr></table></figure>

<p>转换类型不明显</p>
<h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><p>编写程序时过度依靠系统内部的隐式转换是不严禁的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显式将字符串 12 转换成数值 12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&#x27;12&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;12.2pp&#x27;</span>)) <span class="comment">//12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;a12a&#x27;</span>)) <span class="comment">//NaN 只能取开头的数字</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;12.2pp&#x27;</span>)) <span class="comment">//12.2</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2023/06/29/11-00-00/</url>
    <content><![CDATA[<h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><span id="more"></span>

<blockquote>
<p>题目：给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
</blockquote>
<p>一些同学可能为了处理逻辑：每隔2k个字符的前k的字符，写了一堆逻辑代码或者再搞一个计数器，来统计2k，再统计前k个字符。</p>
<p>其实在遍历字符串的过程中，只要让 i +&#x3D; (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。</p>
<p><strong>所以当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseStr = <span class="keyword">function</span>(<span class="params">s, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> len=s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> res=s.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// 字符串无法更改，先变成数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i+=<span class="number">2</span>*k)&#123; <span class="comment">//每次移动2k</span></span><br><span class="line">        k=i+k&gt;len?len-<span class="attr">i</span>:k <span class="comment">// 剩余字符&lt;k,则全部反转;&gt;k则反转前k个</span></span><br><span class="line">        <span class="keyword">let</span> left=i  <span class="comment">// 待反转字符的头指针</span></span><br><span class="line">        <span class="keyword">let</span> right=i+k-<span class="number">1</span> <span class="comment">// 待反转字符的尾指针</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">let</span> temp=res[left]</span><br><span class="line">            res[left++]=res[right]</span><br><span class="line">            res[right--]=temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// 变成字符串返回</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><blockquote>
<p>题目：实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
</blockquote>
<p>这道题如果用split库函数非常简单，但也失去了意义。</p>
<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> replaceSpace = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(s); <span class="comment">// 转化为数组</span></span><br><span class="line">    <span class="keyword">let</span> count=<span class="number">0</span>; <span class="comment">// 空格的数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==<span class="string">&#x27; &#x27;</span>) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left = arr.<span class="property">length</span>-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> right = arr.<span class="property">length</span>+count*<span class="number">2</span>-<span class="number">1</span>; <span class="comment">//将所有空格替换之后的长度</span></span><br><span class="line">    <span class="keyword">while</span>(left&gt;=<span class="number">0</span>)&#123; <span class="comment">// 从后向前依次遍历，若从前向后需要重新分配空间</span></span><br><span class="line">        <span class="keyword">if</span>(arr[left]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            arr[right--]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            arr[right--]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            arr[right--]=<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            arr[right--]=arr[left]</span><br><span class="line">        &#125;</span><br><span class="line">        left--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="翻转字符串中的单词"><a href="#翻转字符串中的单词" class="headerlink" title="翻转字符串中的单词"></a>翻转字符串中的单词</h2><blockquote>
<p>题目：给你一个字符串 s ，请你反转字符串中 单词 的顺序。</p>
<p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p>
<p>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p>
<p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
</blockquote>
<p>在不申请额外空间的前提下，这类问题的基本范式是<strong>局部反转+整体反转</strong></p>
<ol>
<li>移除多余空格</li>
<li>将整个字符串反转</li>
<li>将每个单词反转</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseWords = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(s)</span><br><span class="line">    <span class="title function_">removeMoreSpace</span>(arr) <span class="comment">// js参数传递时，基本类型是值传递，引用类型是引用传递</span></span><br><span class="line">    <span class="comment">// 翻转</span></span><br><span class="line">    <span class="title function_">reverse</span>(arr, <span class="number">0</span>, arr.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] === <span class="string">&#x27; &#x27;</span> || i === arr.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="comment">// 翻转单词</span></span><br><span class="line">            <span class="title function_">reverse</span>(arr, start, i - <span class="number">1</span>);</span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除多余空格</span></span><br><span class="line"><span class="keyword">var</span> removeMoreSpace=<span class="keyword">function</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> fast=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> slow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast&lt;arr.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[fast]==<span class="string">&#x27; &#x27;</span>&amp;&amp;(fast==<span class="number">0</span>||arr[fast-<span class="number">1</span>]==<span class="string">&#x27; &#x27;</span>)) fast++</span><br><span class="line">        <span class="keyword">else</span> arr[slow++]=arr[fast++]</span><br><span class="line">    &#125;</span><br><span class="line">    arr.<span class="property">length</span>=arr[slow-<span class="number">1</span>]==<span class="string">&#x27; &#x27;</span>?slow-<span class="number">1</span>:slow</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 翻转从start到end的字符</span></span><br><span class="line"><span class="keyword">var</span> reverse=<span class="keyword">function</span>(<span class="params">arr,start,end</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> left = start;</span><br><span class="line">    <span class="keyword">let</span> right = end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        [arr[left], arr[right]] = [arr[right], arr[left]];</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串匹配-KMP"><a href="#字符串匹配-KMP" class="headerlink" title="字符串匹配-KMP"></a>字符串匹配-KMP</h2><blockquote>
<p>题目：给定两个字符串 haystack 和 needle，在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标(下标从 0 开始)，否则返回 -1 。 </p>
</blockquote>
<p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再做匹配了</strong></p>
<h3 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h3><p>包含首字母，不包含尾字母的所有子串</p>
<h3 id="前缀表"><a href="#前缀表" class="headerlink" title="前缀表"></a>前缀表</h3><p>前缀表中存储的是前缀和该字符串本身的<strong>最长相等前后缀</strong></p>
<h3 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h3><p>在文本串和模式串分别设指针开始匹配，当匹配不上的时候，查询前一个字符的前缀表。不必从头开始匹配，而是从前一个字符的最长相等前后缀的后一位开始。原理是不匹配的那一位的前面所有字符都是匹配的，此时找到最长相等前后缀，既然该子串的前缀和后缀相等，那么前缀也是匹配的，所以<strong>跳过必然匹配的前缀，从前缀后面开始匹配即可</strong>。</p>
<p>而这个前缀表的数字正好代表了下次匹配时需要跳过的前缀长度，比如查询到对应的前缀表数字是2，那么下一次匹配时就跳过模式串前两个字符，从索引为2的位置开始。所以<strong>前缀表上最长相等前后缀刚好代表了下一次需要跳转到的位置</strong>，因此<strong>可以直接把前缀表当成next数组</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">haystack</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">needle</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 得到next数组</span></span><br><span class="line"><span class="keyword">var</span> getNext = <span class="keyword">function</span>(<span class="params">needle</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> next = [];</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>; <span class="comment">// 前缀末尾,同时也是最长相等前后缀的长度</span></span><br><span class="line">    next.<span class="title function_">push</span>(j); <span class="comment">// 初始化,next[0] = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; needle.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// i指向后缀末尾</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] !== needle[j])</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (needle[i] === needle[j])</span><br><span class="line">            j++;</span><br><span class="line">        next.<span class="title function_">push</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strStr = <span class="keyword">function</span>(<span class="params">haystack, needle</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.<span class="property">length</span> === <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> next = <span class="title function_">getNext</span>(needle);</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>; <span class="comment">// 指向模式串，与next数组一一对应</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; haystack.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// i指向文本串</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] !== needle[j])</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] === needle[j])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (j === needle.<span class="property">length</span>) <span class="comment">//j要指向最后才满足整个模式串都匹配上</span></span><br><span class="line">            <span class="keyword">return</span> (i - needle.<span class="property">length</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="重复子串"><a href="#重复子串" class="headerlink" title="重复子串"></a>重复子串</h2><blockquote>
<p>题目：给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</p>
</blockquote>
<h3 id="移动匹配"><a href="#移动匹配" class="headerlink" title="移动匹配"></a>移动匹配</h3><p>任何一个<strong>重复子串的前半部分和后半部分都能找到一个相等的区间</strong>，给字符串s拼接一个相同的s得到ss，那么ss<strong>中间部分</strong>就一定能<strong>找到一个s</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> repeatedSubstringPattern = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> newS = s+s</span><br><span class="line">    newS = newS.<span class="title function_">substr</span>(<span class="number">1</span>,newS.<span class="property">length</span>-<span class="number">2</span>)<span class="comment">// 移除首尾字母，避免在首部和尾部找到s</span></span><br><span class="line">    <span class="keyword">if</span>(newS.<span class="title function_">includes</span>(s)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>js tips</title>
    <url>/2023/07/01/10-30-15/</url>
    <content><![CDATA[<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=<span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">2</span>); <span class="comment">// 这一句要加;</span></span><br><span class="line">[arr[<span class="number">1</span>], arr[<span class="number">0</span>]] = [arr[<span class="number">0</span>], arr[<span class="number">1</span>]]; <span class="comment">// 前面的语句要加分号</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>js在参数传递时，对于基本数据类型是值传递方式；对于引用数据类型是引用传递</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num</span>)&#123; <span class="comment">// 值传递</span></span><br><span class="line">  num+=<span class="number">10</span></span><br><span class="line">  <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(a)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)			<span class="comment">//10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(a))		<span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">modifyArray</span>(<span class="params">arr</span>) &#123; <span class="comment">// 引用传递</span></span><br><span class="line">  arr.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="title function_">modifyArray</span>(nums);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nums); <span class="comment">// 输出 [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>虽然传递对象时是通过引用传递，但是<strong>如果在函数内部将参数重新赋值为一个新的对象，这个赋值操作对原始对象并没有影响</strong>。这是因为在函数内部，参数变量被重新赋值，指向了一个新的对象，而不是修改原始对象的引用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">replaceObj</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  obj = &#123;<span class="attr">a</span>: <span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="title function_">replaceObj</span>(person);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// 输出 &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列</title>
    <url>/2023/07/08/11-00-00/</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>栈其实就是递归的一种实现结构</strong></p>
<span id="more"></span>

<h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><blockquote>
<p>题目：请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>
<p>实现 MyQueue 类：</p>
<ul>
<li>void push(int x) 将元素 x 推到队列的末尾</li>
<li>int pop() 从队列的开头移除并返回元素</li>
<li>int peek() 返回队列开头的元素</li>
<li>boolean empty() 如果队列为空，返回 true ；否则，返回 false</li>
</ul>
</blockquote>
<p>使用两个栈实现队列，在实现pop时先将一个栈中的元素全部移到另一个栈中，取其栈顶即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyQueue</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 使用数组push、pop模拟栈</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inStack</span>=[]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">outStack</span>=[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inStack</span>.<span class="title function_">push</span>(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">outStack</span>.<span class="property">length</span>&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">outStack</span>.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">inStack</span>.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = <span class="variable language_">this</span>.<span class="property">inStack</span>.<span class="title function_">pop</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">outStack</span>.<span class="title function_">push</span>(temp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">outStack</span>.<span class="title function_">pop</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">peek</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="variable language_">this</span>.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">outStack</span>.<span class="title function_">push</span>(temp)</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">inStack</span>.<span class="property">length</span>&lt;=<span class="number">0</span>&amp;&amp;<span class="variable language_">this</span>.<span class="property">outStack</span>.<span class="property">length</span>&lt;=<span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><blockquote>
<p>题目：请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p>
<p>实现 MyStack 类：</p>
<ul>
<li>void push(int x) 将元素 x 压入栈顶。</li>
<li>int pop() 移除并返回栈顶元素。</li>
<li>int top() 返回栈顶元素。</li>
<li>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</li>
</ul>
</blockquote>
<p>使用两个队列实现栈，在实现pop时先将一个队列中的元素移到另一个队列中，直到只剩一个为止，取剩的那一个元素即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MyStack</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 使用数组push、shift模拟队列</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue1</span>=[]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue2</span>=[]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue1</span>.<span class="title function_">push</span>(x)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pop</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">queue1</span>.<span class="property">length</span>&lt;=<span class="number">0</span>) [<span class="variable language_">this</span>.<span class="property">queue1</span>,<span class="variable language_">this</span>.<span class="property">queue2</span>]=[<span class="variable language_">this</span>.<span class="property">queue2</span>,<span class="variable language_">this</span>.<span class="property">queue1</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">queue1</span>.<span class="property">length</span>&gt;<span class="number">1</span>) <span class="variable language_">this</span>.<span class="property">queue2</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">queue1</span>.<span class="title function_">shift</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue1</span>.<span class="title function_">shift</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">top</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp=<span class="variable language_">this</span>.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue1</span>.<span class="title function_">push</span>(temp)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyStack</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">empty</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue1</span>.<span class="property">length</span>==<span class="number">0</span>&amp;&amp;<span class="variable language_">this</span>.<span class="property">queue2</span>.<span class="property">length</span>==<span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h2><blockquote>
<p>题目：给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ul>
</blockquote>
<p><strong>括号匹配是使用栈解决的经典问题。</strong>由于栈结构的特殊性，非常适合做对称匹配类的题目。</p>
<p>不匹配的情况有三种，左括号多余、右括号多余和左右括号不匹配</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">let</span> map = &#123; <span class="string">&quot;(&quot;</span>:<span class="string">&quot;)&quot;</span>, <span class="string">&quot;&#123;&quot;</span>:<span class="string">&quot;&#125;&quot;</span>, <span class="string">&quot;[&quot;</span>:<span class="string">&quot;]&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>||s[i]==<span class="string">&#x27;[&#x27;</span>||s[i]==<span class="string">&#x27;&#123;&#x27;</span>) stack.<span class="title function_">push</span>(s[i]);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> temp = stack.<span class="title function_">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(temp===<span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 排除右括号多余的情况</span></span><br><span class="line">            <span class="keyword">if</span>(map[temp]!=s[i]) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 排除不匹配的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !stack.<span class="property">length</span> <span class="comment">//排除左括号多余的情况</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h2><blockquote>
<p>题目：给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上<strong>反复执行</strong>重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
</blockquote>
<h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>会超时！设置双指针，fast检测，slow指向待填入位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>; <span class="comment">//代表这一次循环有没有删除，如果没有则结束</span></span><br><span class="line">  <span class="keyword">let</span> arr = s.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>) <span class="comment">//便于修改</span></span><br><span class="line">  <span class="keyword">let</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> count=<span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">    flag = <span class="literal">false</span>,count=<span class="number">0</span>,fast=<span class="number">0</span>,slow=<span class="number">0</span> <span class="comment">// 初始化状态</span></span><br><span class="line">    <span class="keyword">while</span> (fast &lt; arr.<span class="property">length</span>) &#123; <span class="comment">// 一次循环</span></span><br><span class="line">      <span class="keyword">if</span> (arr[fast] == arr[fast + <span class="number">1</span>]) &#123; <span class="comment">// 需要消除</span></span><br><span class="line">        fast += <span class="number">2</span>;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        count++ <span class="comment">// 记录下消除次数，通过改变length删除元素</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr[slow++] = arr[fast++]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.<span class="property">length</span>=arr.<span class="property">length</span>-count*<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// 变回字符串</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="用栈解决"><a href="#用栈解决" class="headerlink" title="用栈解决"></a>用栈解决</h3><p>将字符串元素依次入栈，入栈前与前一个元素若相同，则不入栈且将前一个元素出栈</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr=s.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> stack=[]</span><br><span class="line">    stack.<span class="title function_">push</span>(arr[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==stack[stack.<span class="property">length</span>-<span class="number">1</span>]) stack.<span class="title function_">pop</span>()</span><br><span class="line">        <span class="comment">// 注意这里不能写arr[i]==arr[i-1]</span></span><br><span class="line">        <span class="keyword">else</span> stack.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="后缀表达式求值"><a href="#后缀表达式求值" class="headerlink" title="后缀表达式求值"></a>后缀表达式求值</h2><blockquote>
<p>题目：给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p>
<p>请你计算该表达式。返回一个表示表达式值的整数。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string[]</span>&#125; <span class="variable">tokens</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> evalRPN = <span class="keyword">function</span>(<span class="params">tokens</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack=[]</span><br><span class="line">    <span class="keyword">let</span> num1=<span class="number">0</span>,num2=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;tokens.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tokens[i]==<span class="string">&#x27;+&#x27;</span>||tokens[i]==<span class="string">&#x27;-&#x27;</span>||tokens[i]==<span class="string">&#x27;*&#x27;</span>||tokens[i]==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            num1=<span class="built_in">parseInt</span>(stack.<span class="title function_">pop</span>())</span><br><span class="line">            num2=<span class="built_in">parseInt</span>(stack.<span class="title function_">pop</span>())</span><br><span class="line">            <span class="keyword">if</span>(tokens[i]==<span class="string">&#x27;+&#x27;</span>) stack.<span class="title function_">push</span>(num1+num2)</span><br><span class="line">            <span class="keyword">if</span>(tokens[i]==<span class="string">&#x27;-&#x27;</span>) stack.<span class="title function_">push</span>(num2-num1)</span><br><span class="line">            <span class="keyword">if</span>(tokens[i]==<span class="string">&#x27;*&#x27;</span>) stack.<span class="title function_">push</span>(num2*num1)</span><br><span class="line">            <span class="keyword">if</span>(tokens[i]==<span class="string">&#x27;/&#x27;</span>) stack.<span class="title function_">push</span>(<span class="built_in">parseInt</span>(num2/num1))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(tokens[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.<span class="title function_">pop</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h2><blockquote>
<p>题目：给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 滑动窗口中的最大值 。</p>
</blockquote>
<p>暴力会超时</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">let</span> max</span><br><span class="line">    <span class="keyword">let</span> ans=[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=nums.<span class="property">length</span>-k;i++)&#123;</span><br><span class="line">        max=-<span class="title class_">Infinity</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&lt;k+i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&gt;max) max=nums[j]</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="title function_">push</span>(max)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 O(n*k)</li>
</ul>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>可以维护一个队列，队列中的元素就是滑动窗口的元素，每次移动滑动窗口则需要对队列做三个操作：</p>
<ul>
<li>push一个元素进队尾</li>
<li>从队头pop一个元素</li>
<li>获取队列中的 最大值</li>
</ul>
<p>但是获取最大值的操作不能遍历实现，否则时间复杂度和暴力解法没有区别。因此需要实现一种特殊的<strong>单调队列</strong>，它应该能以O(1)时间来获取队列中最大值。</p>
<p>在单调队列中，并<strong>不需要维护滑动窗口中的所有元素</strong>，只需要维护有可能成为最大值的元素即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="keyword">function</span> (<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MonoQueue</span> &#123; <span class="comment">// 单调队列</span></span><br><span class="line">        queue;</span><br><span class="line">        <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">enqueue</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="comment">//入队操作，入队时弹出所有小于value的元素</span></span><br><span class="line">            <span class="keyword">let</span> back = <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (back !== <span class="literal">undefined</span> &amp;&amp; back &lt; value) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">pop</span>();</span><br><span class="line">                back = <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">dequeue</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="comment">//出队操作</span></span><br><span class="line">            <span class="keyword">let</span> front = <span class="variable language_">this</span>.<span class="title function_">front</span>();</span><br><span class="line">            <span class="keyword">if</span> (front === value) &#123;</span><br><span class="line">            <span class="comment">//当它是最大值时才会留在队列中，否则早就被弹出了</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">front</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 获取队列中的最大值，最大值一直维护在队头</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> helperQueue = <span class="keyword">new</span> <span class="title class_">MonoQueue</span>();</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="comment">//j指向滑动窗口右边；i指向滑动窗口左边</span></span><br><span class="line">    <span class="keyword">let</span> resArr = [];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; k) &#123; <span class="comment">// 先入队k个元素</span></span><br><span class="line">        helperQueue.<span class="title function_">enqueue</span>(nums[j++]);</span><br><span class="line">    &#125;</span><br><span class="line">    resArr.<span class="title function_">push</span>(helperQueue.<span class="title function_">front</span>());</span><br><span class="line">    <span class="keyword">while</span> (j &lt; nums.<span class="property">length</span>) &#123;</span><br><span class="line">        helperQueue.<span class="title function_">enqueue</span>(nums[j]);</span><br><span class="line">        helperQueue.<span class="title function_">dequeue</span>(nums[i]);</span><br><span class="line">        resArr.<span class="title function_">push</span>(helperQueue.<span class="title function_">front</span>());</span><br><span class="line">        i++, j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resArr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="前k个高频元素"><a href="#前k个高频元素" class="headerlink" title="前k个高频元素"></a>前k个高频元素</h2><blockquote>
<p>题目：给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
</blockquote>
<p>首先统计元素出现的频率，这一类的问题可以使用map来进行统计。</p>
<p>然后是对频率进行排序，这里我们可以使用一种 容器适配器就是<strong>优先级队列</strong>。其实就是**一个披着队列外衣的堆(大根堆和小根堆)**，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。</p>
<p>而且优先级队列内部元素是自动依照元素的权值排列。</p>
<p>但在js中没有堆的库函数，可以用<code>Array.from</code>转化为二维数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> topKFrequent = <span class="keyword">function</span>(<span class="params">nums, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    <span class="keyword">let</span> res=[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(nums[i])) map.<span class="title function_">set</span>(nums[i], map.<span class="title function_">get</span>(nums[i])+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> map.<span class="title function_">set</span>(nums[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回一个按出现次数降序的二维数组</span></span><br><span class="line">    <span class="keyword">let</span> sortArray = <span class="title class_">Array</span>.<span class="title function_">from</span>(map).<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b[<span class="number">1</span>] - a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(sortArray[i][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2023/07/10/15-00-00/</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200920221638903.png" alt="img"></p>
<span id="more"></span>

<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树是有数值的，<strong>二叉搜索树是一个有序树</strong>。</p>
<ul>
<li>若它的左子树不空，则<strong>左子树上所有结点的值均小于它的根结点的值</strong>；</li>
<li>若它的右子树不空，则<strong>右子树上所有结点的值均大于它的根结点的值</strong>；</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190304693.png" alt="img"></p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul>
<li>深度优先遍历(可以借助栈使用非递归方式实现)<ul>
<li>前序遍历（递归法，迭代法）</li>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递归法，迭代法）</li>
</ul>
</li>
<li>广度优先遍历(通常使用队列实现)<ul>
<li>层次遍历（迭代法）</li>
</ul>
</li>
</ul>
<h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TreeNode</span>(<span class="params">val, left, right</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = (val===<span class="literal">undefined</span> ? <span class="number">0</span> : val)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = (left===<span class="literal">undefined</span> ? <span class="literal">null</span> : left)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = (right===<span class="literal">undefined</span> ? <span class="literal">null</span> : right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><h3 id="如何写递归程序"><a href="#如何写递归程序" class="headerlink" title="如何写递归程序"></a>如何写递归程序</h3><ol>
<li><strong>确定递归函数的参数和返回值</strong>： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件</strong>：写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑</strong>：确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans=[]</span><br><span class="line">    <span class="keyword">const</span> df = <span class="keyword">function</span>(<span class="params">root</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        ans.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line">        <span class="title function_">df</span>(root.<span class="property">left</span>)</span><br><span class="line">        <span class="title function_">df</span>(root.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">df</span>(root)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans=[]</span><br><span class="line">    <span class="keyword">const</span> df = <span class="keyword">function</span>(<span class="params">root</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="title function_">df</span>(root.<span class="property">left</span>)</span><br><span class="line">        <span class="title function_">df</span>(root.<span class="property">right</span>)</span><br><span class="line">        ans.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">df</span>(root)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans=[]</span><br><span class="line">    <span class="keyword">const</span> df = <span class="keyword">function</span>(<span class="params">root</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="title function_">df</span>(root.<span class="property">left</span>)</span><br><span class="line">        ans.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line">        <span class="title function_">df</span>(root.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">df</span>(root)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h2><h3 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans=[]</span><br><span class="line">    <span class="keyword">let</span> stack=[]</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">null</span>) stack.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">while</span>(stack.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp=stack.<span class="title function_">pop</span>()</span><br><span class="line">        ans.<span class="title function_">push</span>(temp.<span class="property">val</span>)</span><br><span class="line">        <span class="comment">// 这里注意，前序遍历的顺序是根-&gt;左孩子-&gt;右孩子</span></span><br><span class="line">        <span class="comment">// 但栈是先入后出的数据结构，因此要先入栈右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="property">right</span>!=<span class="literal">null</span>) stack.<span class="title function_">push</span>(temp.<span class="property">right</span>)</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="property">left</span>!=<span class="literal">null</span>) stack.<span class="title function_">push</span>(temp.<span class="property">left</span>)  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans=[]</span><br><span class="line">    <span class="keyword">let</span> stack=[]</span><br><span class="line">    <span class="keyword">let</span> cur=root <span class="comment">// 处理以cur为根的子树</span></span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">null</span>||stack.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(cur)</span><br><span class="line">            cur=cur.<span class="property">left</span> <span class="comment">//处理cur的左子树</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur=stack.<span class="title function_">pop</span>()</span><br><span class="line">            ans.<span class="title function_">push</span>(cur.<span class="property">val</span>)</span><br><span class="line">            cur=cur.<span class="property">right</span> <span class="comment">//处理cur的右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans=[]</span><br><span class="line">    <span class="keyword">let</span> stack=[]</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">null</span>) stack.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">while</span>(stack.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp=stack.<span class="title function_">pop</span>()</span><br><span class="line">        ans.<span class="title function_">push</span>(temp.<span class="property">val</span>)</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="property">left</span>!=<span class="literal">null</span>) stack.<span class="title function_">push</span>(temp.<span class="property">left</span>)</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="property">right</span>!=<span class="literal">null</span>) stack.<span class="title function_">push</span>(temp.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.<span class="title function_">reverse</span>() <span class="comment">//最后把数组反转</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>该题与普通的层序遍历的区别的在于：需要把一层的元素单独放在一个数组中，最后返回一个二维数组。</p>
<p>因此要记录下每一层元素的数量，<strong>当一层的元素全部出队时，队列的长度就是下一层元素的数量</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> queue=[]</span><br><span class="line">    <span class="keyword">let</span> ans=[]</span><br><span class="line">    <span class="keyword">let</span> count=<span class="number">1</span> <span class="comment">//记录每一层元素的个数</span></span><br><span class="line">    <span class="keyword">let</span> ans_temp=[] <span class="comment">//存储每层元素</span></span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">null</span>) queue.<span class="title function_">push</span>(root)</span><br><span class="line">    <span class="keyword">while</span>(queue.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp=queue.<span class="title function_">shift</span>()</span><br><span class="line">        count-- <span class="comment">//每弹出一个元素，该层数量-1</span></span><br><span class="line">        ans_temp.<span class="title function_">push</span>(temp.<span class="property">val</span>)</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="property">left</span>!=<span class="literal">null</span>) queue.<span class="title function_">push</span>(temp.<span class="property">left</span>)</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="property">right</span>!=<span class="literal">null</span>) queue.<span class="title function_">push</span>(temp.<span class="property">right</span>)</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123; <span class="comment">//该层元素全部弹出</span></span><br><span class="line">            ans.<span class="title function_">push</span>(ans_temp)</span><br><span class="line">            ans_temp=[]</span><br><span class="line">            count=queue.<span class="property">length</span> <span class="comment">//此时下一层结点已全部入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相关题目：102、107、199、637、429、515、116、117</p>
<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><blockquote>
<p>题目：给一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
</blockquote>
<p>这道题思想上并不复杂，就是遍历二叉树，在遍历的时候两两交换其子结点。重点在于用什么遍历方式。是选递归还是非递归，递归中又有前中后序。不能稀里糊涂accpet就算了事</p>
<p>其实前序和后序都很合适，但如果用中序遍历则会比较绕，因为中序的顺序是左中右，先处理左子树，再把左右子树翻转，然后去处理右子树，此时右子树就是已经被处理过的原本的左子树。也就是说有的结点被翻转两次，有的结点没被翻转。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> invertTree = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="title function_">invert</span>(root)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> invert = <span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="comment">// 翻转以node为根的子树</span></span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    [node.<span class="property">left</span>,node.<span class="property">right</span>]=[node.<span class="property">right</span>,node.<span class="property">left</span>]</span><br><span class="line">    <span class="title function_">invert</span>(node.<span class="property">left</span>)</span><br><span class="line">    <span class="comment">// 如果是中序，交换就要写在这里</span></span><br><span class="line">    <span class="title function_">invert</span>(node.<span class="property">right</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><blockquote>
<p>题目：检查一个二叉树是否轴对称</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> t1=<span class="title function_">postorder1</span>(root.<span class="property">left</span>)</span><br><span class="line">    <span class="keyword">let</span> t2=<span class="title function_">postorder2</span>(root.<span class="property">right</span>)</span><br><span class="line">    <span class="keyword">return</span> t1.<span class="title function_">join</span>()==t2.<span class="title function_">join</span>() <span class="comment">// 数组不能直接比较，可先转成字符串</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> postorder1 = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans=[]</span><br><span class="line">    <span class="keyword">const</span> df = <span class="keyword">function</span>(<span class="params">root</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123; <span class="comment">//这里不能直接return，否则当只有一个孩子的时候，左孩子和右孩子的遍历结果是一样的</span></span><br><span class="line">            ans.<span class="title function_">push</span>(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">df</span>(root.<span class="property">left</span>) <span class="comment">//先左再右</span></span><br><span class="line">        <span class="title function_">df</span>(root.<span class="property">right</span>)</span><br><span class="line">        ans.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">df</span>(root)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> postorder2 = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans=[]</span><br><span class="line">    <span class="keyword">const</span> df = <span class="keyword">function</span>(<span class="params">root</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            ans.<span class="title function_">push</span>(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">df</span>(root.<span class="property">right</span>) <span class="comment">//先右再左</span></span><br><span class="line">        <span class="title function_">df</span>(root.<span class="property">left</span>)</span><br><span class="line">        ans.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">df</span>(root)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h2><blockquote>
<p>题目：给定一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p>
</blockquote>
<h3 id="普通二叉树"><a href="#普通二叉树" class="headerlink" title="普通二叉树"></a>普通二叉树</h3><p>遍历结点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countNodes = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> df=<span class="keyword">function</span>(<span class="params">root</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> leftNum=<span class="title function_">df</span>(root.<span class="property">left</span>)</span><br><span class="line">        <span class="keyword">let</span> rightNum=<span class="title function_">df</span>(root.<span class="property">right</span>)</span><br><span class="line">        <span class="keyword">return</span> leftNum+rightNum+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">df</span>(root)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="完全二叉树-1"><a href="#完全二叉树-1" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>完全二叉树有两种情况，一是满二叉树；二是最后一层叶子结点没满。对于满二叉树而言，得到深度之后可以用公式快速计算，那么可以考虑<strong>把一个完全二叉树分为若干满二叉树分别计算</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countNodes = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left=root.<span class="property">left</span></span><br><span class="line">    <span class="keyword">let</span> right=root.<span class="property">right</span></span><br><span class="line">    <span class="keyword">let</span> leftDepth=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> rightDepth=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(left)&#123;</span><br><span class="line">        leftDepth++</span><br><span class="line">        left=left.<span class="property">left</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(right)&#123;</span><br><span class="line">        rightDepth++</span><br><span class="line">        right=right.<span class="property">right</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(leftDepth===rightDepth) <span class="keyword">return</span> <span class="number">2</span>**leftDepth-<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">countNodes</span>(root.<span class="property">left</span>)+<span class="title function_">countNodes</span>(root.<span class="property">right</span>)+<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><blockquote>
<p>题目：给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
</blockquote>
<p>本题要求二叉树的<strong>高度</strong>，与之前求的二叉树的<strong>深度</strong>要区分开。对于一个高为h 的二叉树，其根节点的高度就是h，而深度则为1</p>
<p>求高度用后序遍历，求深度用前序遍历。因此后序遍历的顺序是左右中，先处理孩子，再处理根，这样就可以把孩子的高度返回给根，根在孩子的基础上+1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isBalanced = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getHeight</span>(root) == -<span class="number">1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getHeight=<span class="keyword">function</span>(<span class="params">node</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> left=<span class="title function_">getHeight</span>(node.<span class="property">left</span>)</span><br><span class="line">    <span class="keyword">if</span>(left==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> right=<span class="title function_">getHeight</span>(node.<span class="property">right</span>)</span><br><span class="line">    <span class="keyword">if</span>(right==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(left-right)&gt;<span class="number">1</span>?-<span class="number">1</span>:<span class="number">1</span>+<span class="title class_">Math</span>.<span class="title function_">max</span>(left,right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心</title>
    <url>/2023/07/14/10-00-00/</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。贪心法没有固定的策略或套路。</p>
<p><strong>刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心</strong>。</p>
<span id="more"></span>

<h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><blockquote>
<p>题目：每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
</blockquote>
<p>题目要求满足越多数量的孩子，就要充分利用饼干，用大饼干喂大胃口，小饼干喂小胃口。那么<strong>局部最优解就是把饼干喂给范围内胃口最大的小孩</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findContentChildren = <span class="keyword">function</span>(<span class="params">g, s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans=<span class="number">0</span></span><br><span class="line">    s.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> a-b&#125;) <span class="comment">// 从小到大排序</span></span><br><span class="line">    g.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> a-b&#125;)</span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span> <span class="comment">//孩子</span></span><br><span class="line">    <span class="keyword">let</span> j=<span class="number">0</span> <span class="comment">//饼干</span></span><br><span class="line">    <span class="comment">// 双指针法</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;g.<span class="property">length</span>&amp;&amp;j&lt;s.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(g[i]&lt;=s[j])&#123;</span><br><span class="line">            ans++</span><br><span class="line">            i++</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><blockquote>
<p>题目：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<p>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p>
</blockquote>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124174327597.png" alt="376.摆动序列"></p>
<p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</strong>。</p>
<p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong>。</p>
<p>可以分为几种情况来看</p>
<ul>
<li>上下坡有平坡</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230106170449.png" alt="img"></p>
<ul>
<li>单调有平坡</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230108171505.png" alt="img"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wiggleMaxLength = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> preDiff = <span class="number">0</span> <span class="comment">//</span></span><br><span class="line">    <span class="keyword">let</span> curDiff = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        curDiff = nums[i + <span class="number">1</span>] - nums[i]</span><br><span class="line">        <span class="keyword">if</span>((curDiff&gt;<span class="number">0</span> &amp;&amp; preDiff&lt;=<span class="number">0</span>) || (curDiff&lt;<span class="number">0</span> &amp;&amp; preDiff&gt;=<span class="number">0</span>))&#123;</span><br><span class="line">            result++</span><br><span class="line">            preDiff = curDiff <span class="comment">//只有遇到摆动了preDiff才改变，实现逻辑删除</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><blockquote>
<p>题目：给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
</blockquote>
<p>本题如果使用暴力法来做，就是两层for循环遍历出所有的子数组，选取最大和的数组。</p>
<p>但在遍历的过程中不难想到，<strong>当和为正数时，对后面的数有增大作用；当和为负数，对后面的数只会有减小作用</strong>。</p>
<p><strong>当连续和为负数时，再去加后面的数，只会让后面的数变小</strong>。此时不如抛弃之前的和，从下一个数开始重新求和</p>
<p>需要注意的是，本题的策略是<strong>遇到连续和为负数时抛弃，而不是遇到负数时抛弃</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSubArray = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans=-<span class="title class_">Infinity</span></span><br><span class="line">    <span class="keyword">let</span> sum=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        sum+=nums[i]</span><br><span class="line">        ans=<span class="title class_">Math</span>.<span class="title function_">max</span>(ans,sum) <span class="comment">// 记录下当前的最大连续和</span></span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123; <span class="comment">//如果连续和为负数，则抛弃，重新开始计</span></span><br><span class="line">            sum=<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>本题的贪心思路并不好想，虽然贪心的理论很直白，但是题目不简单</p>
<h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><blockquote>
<p>题目：给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p>
<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p>
<p>返回 你能获得的 最大 利润 。</p>
</blockquote>
<p>画出股票价格走势图，就是在极小值点买，在极大值点卖出。</p>
<p>同时如果股票连涨三天，<strong>在第一天买第三天卖的利润 与 每天都买且卖所得的利润是一样的</strong>，反应到图上就是每一段递增曲线的高度差之和</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;prices.<span class="property">length</span>-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i]&lt;prices[i+<span class="number">1</span>]) <span class="comment">//股票涨价</span></span><br><span class="line">            ans+=(prices[i+<span class="number">1</span>]-prices[i]) <span class="comment">//当天利润</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><blockquote>
<p>题目：给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。</p>
</blockquote>
<p>如果用数组中的元素代表其覆盖范围，这道题其实在问能不能从第一个元素覆盖到最后一个元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canJump = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cover=<span class="number">0</span> <span class="comment">//从第一个元素开始能覆盖到的范围</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=cover;i++)&#123; <span class="comment">//注意这里是i&lt;=cover，遍历到能覆盖到的区域</span></span><br><span class="line">        cover=<span class="title class_">Math</span>.<span class="title function_">max</span>(cover,i+nums[i]) <span class="comment">//更新覆盖区域</span></span><br><span class="line">        <span class="keyword">if</span>(cover&gt;=nums.<span class="property">length</span>-<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>题目：现假定可以到达<code>nums[n-1]</code>，返回到达的最小跳跃次数</p>
</blockquote>
<p>本题的贪心思路是<strong>用尽量少的步数去增加覆盖范围</strong>，每次遍历覆盖范围内的元素，记录下一次跳跃的最大覆盖范围</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jump = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> curIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> nextIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> steps = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        nextIndex = <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[i] + i, nextIndex)</span><br><span class="line">        <span class="keyword">if</span>(i === curIndex) &#123;</span><br><span class="line">            curIndex = nextIndex</span><br><span class="line">            steps++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> steps</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><blockquote>
<p>题目：在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p>
</blockquote>
<p>到达每个加油站后的剩余油量为 <code>gas[i] - cost[i]</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">gas</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">cost</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> canCompleteCircuit = <span class="keyword">function</span>(<span class="params">gas, cost</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> curSum = <span class="number">0</span> <span class="comment">//当前油量和消耗的差值</span></span><br><span class="line">    <span class="keyword">let</span> totalSum = <span class="number">0</span> <span class="comment">//记录总油量和总消耗的差值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; gas.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        curSum += gas[i] - cost[i]</span><br><span class="line">        totalSum += gas[i] - cost[i]</span><br><span class="line">        <span class="keyword">if</span>(curSum &lt; <span class="number">0</span>) &#123; <span class="comment">//入不敷出，尝试把下一个结点作为开始结点</span></span><br><span class="line">            curSum = <span class="number">0</span></span><br><span class="line">            start = i + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> start</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><blockquote>
<p>题目：n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<ul>
<li><p>每个孩子至少分配到 1 个糖果。</p>
</li>
<li><p>相邻两个孩子评分更高的孩子会获得更多的糖果。</p>
</li>
</ul>
<p>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p>
</blockquote>
<p>对于每个孩子来说，既要和左边比较又要和右边比较，但如果在一次循环中作两次比较会顾此失彼。</p>
<p>先处理右边孩子得分高的情况，在循环中，如果右边分高则该孩子的糖果应是其左边孩子糖果数量+1，否则糖果为1</p>
<p>再处理左边孩子得分高的情况，从后向前遍历，如果左边孩子分高则该孩子的糖果应是右边孩子糖果数量+1，否则为1</p>
<p>这样得到两组糖果数量，取较大值最为最终值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">ratings</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> candy = <span class="keyword">function</span>(<span class="params">ratings</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="keyword">new</span> <span class="title class_">Array</span>(ratings.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;ratings.<span class="property">length</span>;i++)&#123; <span class="comment">//左边孩子大</span></span><br><span class="line">        <span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>]) res[i]=res[i-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=ratings.<span class="property">length</span>-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123; <span class="comment">//右边孩子大</span></span><br><span class="line">        <span class="keyword">if</span>(ratings[i]&gt;ratings[i+<span class="number">1</span>])</span><br><span class="line">            res[i]=<span class="title class_">Math</span>.<span class="title function_">max</span>(res[i+<span class="number">1</span>]+<span class="number">1</span>,res[i]) <span class="comment">//得到每个孩子最终的糖果数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ans=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> res) ans+=i</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h2><blockquote>
<p>题目：在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p>
<p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p>
<p>注意，一开始你手头没有任何零钱。</p>
<p>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p>
</blockquote>
<p>顾客付10美元后，要找回5美元；顾客付20美元后，可以找回三张5美元，也可以找回一张10美元和一张5美元。因此5美元比10美元用处多，在找钱时优先把10美元用出去。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">bills</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lemonadeChange = <span class="keyword">function</span>(<span class="params">bills</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> pocket=<span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    pocket.<span class="title function_">set</span>(<span class="number">5</span>,<span class="number">0</span>)</span><br><span class="line">    pocket.<span class="title function_">set</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="comment">//没必要记录20美元的数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> bills)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i===<span class="number">5</span>) pocket.<span class="title function_">set</span>(<span class="number">5</span>,pocket.<span class="title function_">get</span>(<span class="number">5</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(i===<span class="number">10</span>)&#123;</span><br><span class="line">            pocket.<span class="title function_">set</span>(<span class="number">10</span>,pocket.<span class="title function_">get</span>(<span class="number">10</span>)+<span class="number">1</span>);</span><br><span class="line">            pocket.<span class="title function_">set</span>(<span class="number">5</span>,pocket.<span class="title function_">get</span>(<span class="number">5</span>)-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span>(pocket.<span class="title function_">get</span>(<span class="number">5</span>)&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i===<span class="number">20</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pocket.<span class="title function_">get</span>(<span class="number">10</span>)&gt;<span class="number">0</span>)&#123; <span class="comment">//有10美元先用10美元</span></span><br><span class="line">                pocket.<span class="title function_">set</span>(<span class="number">10</span>,pocket.<span class="title function_">get</span>(<span class="number">10</span>)-<span class="number">1</span>)</span><br><span class="line">                pocket.<span class="title function_">set</span>(<span class="number">5</span>,pocket.<span class="title function_">get</span>(<span class="number">5</span>)-<span class="number">1</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span> pocket.<span class="title function_">set</span>(<span class="number">5</span>,pocket.<span class="title function_">get</span>(<span class="number">5</span>)-<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">if</span>(pocket.<span class="title function_">get</span>(<span class="number">5</span>)&lt;<span class="number">0</span>||pocket.<span class="title function_">get</span>(<span class="number">10</span>)&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h2><blockquote>
<p>题目：假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p>
<p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p>
</blockquote>
<p>本题有两个维度，h和k。遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。<strong>如果两个维度一起考虑一定会顾此失彼</strong>。</p>
<p>那么是先确定k还是先确定h呢，如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。</p>
<p>那么按照身高h从高到低排序，身高一样时按k从小到大排序。身高最高者，其k值必定为0，之后以k为索引将元素加入到数组中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">people</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reconstructQueue = <span class="keyword">function</span>(<span class="params">people</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res=[]</span><br><span class="line">    people.<span class="title function_">sort</span>(</span><br><span class="line">        <span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>]!==b[<span class="number">0</span>]) <span class="keyword">return</span> b[<span class="number">0</span>]-a[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a[<span class="number">1</span>]-b[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ) <span class="comment">//按身高从高到低排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;people.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="comment">// people[i][1]为k值</span></span><br><span class="line">        res.<span class="title function_">splice</span>(people[i][<span class="number">1</span>],<span class="number">0</span>,people[i])</span><br><span class="line">        <span class="comment">//原本的顺序不会因为插入新元素而乱，因为后来的people都比较矮，对高的人的k值无法造成影响</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h2><blockquote>
<p>题目：有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。</p>
<p>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</p>
</blockquote>
<p>本题的直观想法就是扫描过去，射重叠部分多的。</p>
<p><strong>为了让气球尽可能的重叠，需要对数组进行排序</strong>。按起始位置或终止位置排序都可以，以起始位置为例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">points</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMinArrowShots = <span class="keyword">function</span>(<span class="params">points</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(points.<span class="property">length</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    points.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> a[<span class="number">0</span>]-b[<span class="number">0</span>]&#125;) <span class="comment">//按数组起始位置从小到大排序</span></span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">1</span> <span class="comment">//至少需要一支箭</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;points.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(points[i][<span class="number">0</span>]&gt;points[i-<span class="number">1</span>][<span class="number">1</span>])&#123; <span class="comment">//没有重叠边界</span></span><br><span class="line">            res++</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            points[i][<span class="number">1</span>]=<span class="title class_">Math</span>.<span class="title function_">min</span>(points[i][<span class="number">1</span>],points[i-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">            <span class="comment">//重叠之后把范围改成交集范围，看之后的气球能否与交集范围重叠</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h2><blockquote>
<p>题目：给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p>
</blockquote>
<p>本题思路与上题类似，先把区间按起始位置从小到大排序，依次扫描时若有重叠部分，则删除结束位置更靠后的区间(结束位置更靠后就更有可能和别的区间重叠)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">intervals</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> eraseOverlapIntervals = <span class="keyword">function</span>(<span class="params">intervals</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">0</span></span><br><span class="line">    intervals.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> a[<span class="number">0</span>]-b[<span class="number">0</span>]&#125;)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;intervals.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i-<span class="number">1</span>][<span class="number">1</span>]&gt;intervals[i][<span class="number">0</span>])&#123; <span class="comment">//有重叠部分</span></span><br><span class="line">            intervals[i][<span class="number">1</span>]=<span class="title class_">Math</span>.<span class="title function_">min</span>(intervals[i][<span class="number">1</span>],intervals[i-<span class="number">1</span>][<span class="number">1</span>]) <span class="comment">//逻辑删除</span></span><br><span class="line">            res++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h2><blockquote>
<p>题目：给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p>
<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。</p>
<p>返回一个表示每个字符串片段的长度的列表。</p>
</blockquote>
<h3 id="方法一、遍历"><a href="#方法一、遍历" class="headerlink" title="方法一、遍历"></a>方法一、遍历</h3><p>先遍历字符串，计算每个字母出现的次数。维护一个集合，存储当前片段的字母种类。在遍历时</p>
<ul>
<li>什么时候分段：集合为空，说明当前分段的字母都已经遍历到了</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> partitionLabels = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> status=<span class="keyword">new</span> <span class="title class_">Set</span>() <span class="comment">//存储当前段中字母的种类</span></span><br><span class="line">    <span class="keyword">let</span> count=<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> res=[]<span class="comment">//存储分段后的字符长度</span></span><br><span class="line">    <span class="keyword">let</span> temp=<span class="string">&quot;&quot;</span> <span class="comment">//存储该段字符</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        count[s[i].<span class="title function_">charCodeAt</span>()-<span class="number">97</span>]++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(status.<span class="property">size</span>==<span class="number">0</span>&amp;&amp;temp.<span class="property">length</span>&gt;<span class="number">0</span>)&#123; <span class="comment">//满足分段条件</span></span><br><span class="line">            res.<span class="title function_">push</span>(temp.<span class="property">length</span>)</span><br><span class="line">            temp=<span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!status.<span class="title function_">has</span>(s[i])) status.<span class="title function_">add</span>(s[i])</span><br><span class="line">        <span class="keyword">if</span>(--count[s[i].<span class="title function_">charCodeAt</span>()-<span class="number">97</span>]==<span class="number">0</span>)<span class="comment">//每次都要把当前字符的数量减掉，减到0时在集合中删除</span></span><br><span class="line">            status.<span class="title function_">delete</span>(s[i])</span><br><span class="line">        temp+=s[i]</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">push</span>(temp.<span class="property">length</span>)<span class="comment">//加入最后一个片段</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二、贪心"><a href="#方法二、贪心" class="headerlink" title="方法二、贪心"></a>方法二、贪心</h3><p>首先要明白是什么限制了片段的数量，<strong>当一个片段包含一种字符时，它就要包含字符串中所有的该字符</strong>，在延伸的时候又不得不包含进别的字符……</p>
<p>先统计每个字符<strong>最后出现的位置</strong>，在遍历时找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201222191924417.png" alt="763.划分字母区间"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> partitionLabels = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> hash=<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>) <span class="comment">//最后出现的位置</span></span><br><span class="line">    <span class="keyword">let</span> res=[]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        hash[s[i].<span class="title function_">charCodeAt</span>()-<span class="number">97</span>]=i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        right=<span class="title class_">Math</span>.<span class="title function_">max</span>(right,hash[s[i].<span class="title function_">charCodeAt</span>()-<span class="number">97</span>])</span><br><span class="line">        <span class="keyword">if</span>(right===i)&#123;</span><br><span class="line">            res.<span class="title function_">push</span>(right-left+<span class="number">1</span>)</span><br><span class="line">            left=right+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><blockquote>
<p>题目：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">intervals</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">intervals</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = intervals.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span> ( n &lt; <span class="number">2</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">    intervals.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">0</span>]- b[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> res = [],</span><br><span class="line">        left = intervals[<span class="number">0</span>][<span class="number">0</span>],</span><br><span class="line">        right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt; right) &#123; </span><br><span class="line">            <span class="comment">//i与前面的区间不重叠，改左右区间的范围</span></span><br><span class="line">            res.<span class="title function_">push</span>([left, right]);</span><br><span class="line">            left = intervals[i][<span class="number">0</span>];</span><br><span class="line">            right = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//重叠时只改右区间范围</span></span><br><span class="line">            right = <span class="title class_">Math</span>.<span class="title function_">max</span>(intervals[i][<span class="number">1</span>], right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">push</span>([left, right]); <span class="comment">//加入最后一个区间</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h2><blockquote>
<p>题目：当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。</p>
<p>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。</p>
</blockquote>
<p>思路不难想，从后向前遍历数字，不是单调递增则把该位数字变为9，前一位数字-1。但是还需要一些特殊处理，不然碰到6878、1000这样的数字会错误。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> monotoneIncreasingDigits = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> num=<span class="title class_">Array</span>.<span class="title function_">from</span>(n.<span class="title function_">toString</span>())</span><br><span class="line">    <span class="keyword">let</span> flag=num.<span class="property">length</span> <span class="comment">//记录从哪一位开始后面全变成9</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=num.<span class="property">length</span>-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123; <span class="comment">//从后往前遍历</span></span><br><span class="line">        <span class="keyword">if</span>(num[i]&lt;num[i-<span class="number">1</span>])&#123;</span><br><span class="line">            num[i-<span class="number">1</span>]--</span><br><span class="line">            flag=i <span class="comment">//不是直接变成9，而是记录下该变成9的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=flag;i&lt;num.<span class="property">length</span>;i++) num[i]=<span class="string">&#x27;9&#x27;</span></span><br><span class="line">    <span class="comment">//从flag开始往后全都变成9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(num.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><blockquote>
<p>题目：给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong>计算监控树的所有节点所需的最小摄像头数量。</p>
</blockquote>
<p>这道题要充分利用摄像头的覆盖面积，</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础</title>
    <url>/2023/10/09/19-00-37/</url>
    <content><![CDATA[<h2 id="Java的背景知识"><a href="#Java的背景知识" class="headerlink" title="Java的背景知识"></a>Java的背景知识</h2><h3 id="技术体系"><a href="#技术体系" class="headerlink" title="技术体系"></a>技术体系</h3><p>所谓技术体系，就是Java为了满足不同的应用场景提供了不同的技术版本，主要有三个版本。</p>
<ul>
<li><p>Java SE（Java Standard Edition）：叫做标准版，它是后面两个版本的基础，</p>
</li>
<li><p>Java EE（Java Enterprise Edition）: 叫做企业版，它是为企业级应用开发提供的一套解决方案。</p>
</li>
<li><p>Java ME（Java Micro Edition）：叫做小型版，它为开发移动设备的应用提供了一套解决方案。<strong>目前已经不被市场认可（淘汰），取而代之的是基于Android系统的应用开发</strong>。</p>
</li>
</ul>
<span id="more"></span>

<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>文件名和类名不一致</p>
<h3 id="JDK的组成"><a href="#JDK的组成" class="headerlink" title="JDK的组成"></a>JDK的组成</h3><p>JDK由JVM、核心类库、开发工具组成。其中JVM和核心类库组成了JRE（Java Runtime Enviroment），即Java的运行环境</p>
<ul>
<li><p>JDK最核心的组成部分是JVM（Java Virtual Machine），它是Java虚拟机，真正运行Java程序的地方。</p>
</li>
<li><p>核心类库是Java本身写好的一些程序，给程序员调用的。 Java程序员并不是凭空开始写代码，是要基于核心类库提供的一些基础代码，进行编程。</p>
</li>
<li><p>源代码需要编译成字节码(.class)，<strong>编译工具</strong>叫做javac.exe，编写好源代码之后，想要把class文件加载到内存中运行，这里需要用到<strong>运行工具</strong>java.exe。 除了编译工具和运行工具，还有一些其他的反编译工具、文档工具等</p>
</li>
</ul>
<h3 id="跨平台原理"><a href="#跨平台原理" class="headerlink" title="跨平台原理"></a>跨平台原理</h3><p>如果没有跨平台性，同一个应用程序，想要在多种操作系统上运行，需要针对各个操作系统单独开发应用。比如微信有Windows版本、MacOS版本、Android版本、IOS版本</p>
<p>跨平台性的原理是因为在<strong>不同版本的操作系统</strong>中安装有<strong>不同版本的Java虚拟机</strong>，Java程序的运行只依赖于Java虚拟机，和操作系统并没有直接关系。<strong>从而做到一处编译，处处运行</strong>。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>首先，左边<code>int[] ages</code> 表示定义了一个数组类型的变量，变量名叫ages</p>
<p>其次，右边<code>&#123;12,24,36&#125;</code>表示创建一个数组对象，你完全可以把它理解成一个能装数据的东西。这个对象在内存中会有一个地址值<code>[I@4c873330</code>，每次创建一个数组对象都会有不用的地址值。</p>
<p>然后，把右边的地址值<code>[I@4c873330</code>赋值给左边的ages变量</p>
<p>所以，ages变量就可以通过地址值，找到数组这个东西。</p>
<p>Java为了便于虚拟机执行Java程序，将虚拟机的内存划分为 方法区、栈、堆、本地方法栈、寄存器 这5块区域。同学们需要重点关注的是  <strong>方法区、栈、堆</strong>。</p>
<p>下面把每一个块内存区域作用介绍一下，我们大致只需要知道每一部分存储什么内容就行。</p>
<ul>
<li><strong>方法区</strong>：字节码文件先加载到这里</li>
<li><strong>栈</strong>：方法运行时所进入的内存区域，由于变量在方法中，所以变量也在这一块区域中</li>
<li><strong>堆</strong>：存储new出来的东西，并分配地址。由于数组是new 出来的，所以数组也在这块区域。</li>
</ul>
<p><strong>总结一下<code>int a = 10</code>与 <code>int[] arr = new int[]&#123;11,22,33&#125;的区别</code></strong></p>
<ul>
<li><strong>a</strong>是一个变量，在栈内存中，<strong>a</strong>变量中存储的数据就是<strong>10</strong>这个值。</li>
<li><strong>arr</strong>也是一个变量，在栈中，存储的是数组对象在堆内存中的地址值</li>
</ul>
<h3 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h3><p>静态初始化指的是：在定义数组时直接给数组中的数据赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义数组，用来存储多个年龄</span></span><br><span class="line"><span class="type">int</span>[] ages = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">12</span>, <span class="number">24</span>, <span class="number">36</span>&#125;</span><br><span class="line"><span class="comment">//简化写法</span></span><br><span class="line"><span class="type">int</span>[] ages = &#123;<span class="number">12</span>, <span class="number">24</span>, <span class="number">36</span>&#125;</span><br><span class="line"><span class="comment">//等价写法</span></span><br><span class="line"><span class="type">int</span> ages[] = &#123;<span class="number">12</span>, <span class="number">24</span>, <span class="number">36</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据类型[]  数组名 = new 数据类型[长度];</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包类似于文件夹，一个包中可以放多个类文件。</p>
<ul>
<li><p>如果当前程序中，要调用自己所在包下的其他程序，可以直接调用。（同一个包下的类，互相可以直接调用）</p>
</li>
<li><p>如果当前程序中，要调用其他包下的程序，则必须在当前程序中导包, 才可以访问！</p>
<p>导包格式：<code> import 包名.类名</code></p>
</li>
<li><p>如果当前程序中，要调用Java.lang包下的程序，不需要我们导包的，可以直接使用。</p>
</li>
<li><p>如果当前程序中，要调用多个不同包下的程序，而这些程序名正好一样，此时默认只能导入一个程序，另一个程序必须带包名访问。</p>
</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h2 id="final和常量"><a href="#final和常量" class="headerlink" title="final和常量"></a>final和常量</h2><ol>
<li><p>final修饰类：该类称为最终类，特点是不能被继承。</p>
<p>比如一些工具类可以用final修饰。</p>
</li>
<li><p>final修饰方法：该方法称之为最终方法，特点是不能被重写。</p>
</li>
<li><p>final修饰变量：该变量只能被赋值一次。</p>
<p>被 <strong>static final</strong> 修饰的成员变量称为常量，通常用于记录系统的配置信息。常量命名规范：建议都采用大写字母命名，多个单词之前有_隔开。比如<code>public static final String SCHOOL_NAME = &quot;南理工&quot;;</code></p>
<p>在程序编译后，常量会“宏替换”，出现常量的地方，全都会被替换为其记住的字面量。把代码反编译后，其实代码是下面的样子</p>
<p><strong>注意</strong></p>
<ul>
<li>修饰基本类型变量时，变量存储的<strong>数据</strong>不能改变</li>
<li>修饰引用类型变量时，变量存储的<strong>地址</strong>不能改变，但地址指向的对象内容可以改变。</li>
</ul>
</li>
</ol>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>枚举是一种特殊的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> 枚举类名&#123;</span><br><span class="line">    对象名称<span class="number">1</span>,对象名称<span class="number">2</span>;</span><br><span class="line">    其他成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>枚举类的第一行只能罗列一些名称，这些名称都是<strong>常量</strong>，并且<strong>每个常量记住的都是枚举类的一个对象</strong>。</li>
<li>枚举类的<strong>构造器都是私有</strong>的（写不写都只能是私有的），因此，枚举类对外不能创建对象。</li>
<li>枚举都是最终类，<strong>不可以被继承</strong>。</li>
<li>枚举类中，从第二行开始，可以定义类的其他各种成员。</li>
<li>编译器为枚举类新增了几个方法，并且枚举类都是继承自<code>java.lang.Enum</code>类的，从enum类也会继承到一些方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    X,Y,Z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//获取枚举A类的，枚举项</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> A.X;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> A.Y;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a3</span> <span class="operator">=</span> A.Z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用枚举可以实现单例设计模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>枚举一般表示一组固定的值，然后作为参数进行传输。</strong></p>
<p>比如用户性别，可以用常量做，也可以用枚举做。</p>
<ul>
<li>常量的参数值不受约束</li>
<li>枚举代码可读性好，参数值有约束。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Constant</span>&#123;</span><br><span class="line">    BOY,GRIL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//调用方法，传递男生</span></span><br><span class="line">        provideInfo(Constant.BOY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">provideInfo</span><span class="params">(Constant c)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> BOY:</span><br><span class="line">                System.out.println(<span class="string">&quot;展示一些信息给男生看&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GRIL:</span><br><span class="line">                System.out.println(<span class="string">&quot;展示一些信息给女生看&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>所谓泛型指的是，在定义类、接口、方法时，同时声明了一个或者多个类型变量（如：<E>），称为泛型类、泛型接口、泛型方法、它们统称为泛型。</p>
<p>比如<code>ArrayList</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里的&lt;T,W&gt;其实指的就是类型变量，可以是一个，也可以是多个。</span></span><br><span class="line"><span class="keyword">public</span> class 类名&lt;T,W&gt;&#123; &#125;</span><br><span class="line"><span class="comment">//泛型类可以限制类型</span></span><br><span class="line"><span class="keyword">public</span> class 类名&lt;E <span class="keyword">extends</span> <span class="title class_">People</span>&gt;&#123; &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型类，用来表示一个容器</span></span><br><span class="line"><span class="comment">//容器中存储的数据，它的类型用&lt;E&gt;先代替用着，等调用者来确认&lt;E&gt;的具体类型。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArrayList</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//定一个索引，方便对数组进行操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        array[index]=e;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取元素</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E)array[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Data</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;T&gt; <span class="title function_">getByName</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此时确定Data&lt;E&gt;中的E为Teacher类型，</span></span><br><span class="line"><span class="comment">//接口中add和getByName方法上的T也都会变成Teacher类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherData</span> <span class="keyword">implements</span> <span class="title class_">Data</span>&lt;Teacher&gt;&#123;</span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Teacher t)</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Teacher&gt; <span class="title function_">getByName</span><span class="params">(String name)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要先声明泛型变量</span></span><br><span class="line"><span class="keyword">public</span> &lt;泛型变量,泛型变量&gt; 返回值类型 方法名(形参列表)&#123;&#125;</span><br><span class="line"><span class="comment">//&lt;T&gt;为声明泛型变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getData</span><span class="params">(T t)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型限定"><a href="#泛型限定" class="headerlink" title="泛型限定"></a>泛型限定</h3><p>泛型限定的意思是对泛型的数据类型进行范围的限制。</p>
<ul>
<li><?> 表示任意类型</li>
<li><? extends 数据类型> 表示指定类型或者指定类型的子类，也叫**泛型上限**</li>
<li><? super 数据类型> 表示指定类型或者指定类型的父类，也叫**泛型下限**</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BENZ</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BWN</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//1.集合中的元素不管是什么类型，test1方法都能接收</span></span><br><span class="line">        ArrayList&lt;BWM&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Benz&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        test1(list1);</span><br><span class="line">        test1(list2);</span><br><span class="line">        test1(list3);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.集合中的元素只能是Car或者Car的子类类型，才能被test2方法接收</span></span><br><span class="line">        ArrayList&lt;Car&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;BWM&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        test2(list4);</span><br><span class="line">        test2(list5);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.集合中的元素只能是Car或者Car的父类类型，才能被test3方法接收</span></span><br><span class="line">        ArrayList&lt;Car&gt; list6 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Object&gt; list7 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        test3(list6);</span><br><span class="line">        test3(list7);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(ArrayList&lt;?&gt; list)</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">(ArrayList&lt;? extends Car&gt; list)</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">(ArrayList&lt;? <span class="built_in">super</span> Car&gt; list)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型擦除和注意事项"><a href="#泛型擦除和注意事项" class="headerlink" title="泛型擦除和注意事项"></a>泛型擦除和注意事项</h3><p>泛型只在编译阶段有效，一旦编译成字节码，<strong>字节码中是不包含泛型的</strong>，而是具体的类型，这就是泛型擦除。</p>
<p>泛型只支持引用数据类型，即对象类型，<strong>不支持基本数据类型</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ArrayList&lt;int&gt; list1 = new ArrayList&lt;&gt;(); //不允许，int是基本数据类型</span></span><br><span class="line">ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//可以用int的对象类型</span></span><br></pre></td></tr></table></figure>

<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><strong>正则表达式其实是由一些特殊的符号组成的，它代表的是某种规则。</strong></p>
<p>主要有两个作用</p>
<ul>
<li>校验数据格式是否合法</li>
<li>在一段文本中查找满足要求的内容</li>
</ul>
<h3 id="书写规则"><a href="#书写规则" class="headerlink" title="书写规则"></a>书写规则</h3><h3 id="校验数据"><a href="#校验数据" class="headerlink" title="校验数据"></a>校验数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标：校验用户输入的电话、邮箱、时间是否合法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        checkPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkPhone</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入您的电话号码(手机|座机): &quot;</span>);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            <span class="comment">// 18676769999  010-3424242424 0104644535</span></span><br><span class="line">            <span class="keyword">if</span>(phone.matches(<span class="string">&quot;(1[3-9]\\d&#123;9&#125;)|(0\\d&#123;2,7&#125;-?[1-9]\\d&#123;4,19&#125;)&quot;</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您输入的号码格式正确~~~&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您输入的号码格式不正确~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找内容"><a href="#查找内容" class="headerlink" title="查找内容"></a>查找内容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需求1：从以下内容中爬取出，手机，邮箱，座机、400电话等信息。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot; 来黑马程序员学习Java，\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;        电话：1866668888，18699997777\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;        或者联系邮箱：boniu@itcast.cn，\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;        座机电话：01036517895，010-98951256\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;        邮箱：bozai@itcast.cn，\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;        邮箱：dlei0009@163.com，\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;        热线电话：400-618-9090 ，400-618-4000，4006184000，4006189090&quot;</span>;</span><br><span class="line">    <span class="comment">// 1、定义爬取规则</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(1[3-9]\\d&#123;9&#125;)|(0\\d&#123;2,7&#125;-?[1-9]\\d&#123;4,19&#125;)|(\\w&#123;2,&#125;@\\w&#123;2,20&#125;(\\.\\w&#123;2,10&#125;)&#123;1,2&#125;)&quot;</span></span><br><span class="line">    + <span class="string">&quot;|(400-?\\d&#123;3,7&#125;-?\\d&#123;3,7&#125;)&quot;</span>;</span><br><span class="line">    <span class="comment">// 2、把正则表达式封装成一个Pattern对象</span></span><br><span class="line">    <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">    <span class="comment">// 3、通过pattern对象去获取查找内容的匹配器对象。</span></span><br><span class="line">    <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(data);</span><br><span class="line">    <span class="comment">// 4、定义一个循环开始爬取信息</span></span><br><span class="line">    <span class="keyword">while</span> (matcher.find())&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> matcher.group(); <span class="comment">// 获取到了找到的内容了。</span></span><br><span class="line">        System.out.println(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜索替换"><a href="#搜索替换" class="headerlink" title="搜索替换"></a>搜索替换</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexTest5</span> &#123;    </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">            <span class="comment">// 1、public String replaceAll(String regex , String newStr)：按照正则表达式匹配的内容进行替换        </span></span><br><span class="line">        <span class="comment">// 需求1：请把下面字符串中的不是汉字的部分替换为 “-”        </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;古力娜扎ai8888迪丽热巴999aa5566马尔扎哈fbbfsfs42425卡尔扎巴&quot;</span>;        </span><br><span class="line">        System.out.println(s1.replaceAll(regex:<span class="string">&quot;\\w+&quot;</span>, replacement:<span class="string">&quot;-&quot;</span>));                </span><br><span class="line">        <span class="comment">// 需求2(拓展)：某语音系统，收到一个口吃的人说的“我我我喜欢编编编编编编编编编编编编程程程！”，需要优化成“我喜欢编程！”。        </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;我我我喜欢编编编编编编编编编编编编程程程&quot;</span>;        </span><br><span class="line">        System.out.println(s2.replaceAll(<span class="string">&quot;(.)\\1+&quot;</span>, <span class="string">&quot;$1&quot;</span>));</span><br><span class="line">        <span class="comment">// 2、public String[] split(String regex)：按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组。        </span></span><br><span class="line">        <span class="comment">// 需求1：请把下面字符串中的人名取出来，使用切割来做        </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;古力娜扎ai8888迪丽热巴999aa5566马尔扎哈fbbfsfs42425卡尔扎巴&quot;</span>;        </span><br><span class="line">        String[] names = s3.split(<span class="string">&quot;\\w+&quot;</span>);        </span><br><span class="line">        System.out.println(Arrays.toString(names));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>java会把异常封装为对象抛出去。</p>
<p>java中所有的异常和错误对象都继承自<code>Java.lang.Throwable</code>，它有两个子类，分别是</p>
<ul>
<li><code>Error</code>。代表系统级别错误，是java内部的错误，不用管</li>
<li><code>Exception</code>。代表程序中可能出现的问题，它有两个分支<ul>
<li><code>RuntimeException</code>。编译时正常，运行时出错，比如数组越界</li>
<li>其他异常，属于编译时异常。</li>
</ul>
</li>
</ul>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>java中提供的异常类不总满足需求。比如年龄非法。</p>
<p>可以<strong>自定义运行时异常或编译时异常。</strong>由于编译时异常在写代码时就会报错，需要在调用异常的方法体上加上<code>throws</code>把异常抛给它的调用者，这时调用者可以用try catch捕获</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、编译时异常类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeIllegalException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、运行时异常类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgeIllegalRuntimeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeIllegalRuntimeException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 捕获底层可能产生的异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            saveAge(<span class="number">225</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;saveAge底层执行是成功的！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AgeIllegalException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;saveAge底层执行是出现bug的！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveAge</span><span class="params">(<span class="type">int</span> age)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">if</span>(age &gt; <span class="number">0</span> &amp;&amp; age &lt; <span class="number">150</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄被成功保存： &quot;</span> + age);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用一个异常对象封装这个问题</span></span><br><span class="line">            <span class="comment">// throw 抛出去这个异常对象,给上层，由上层捕获</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeIllegalException</span>(<span class="string">&quot;/age is illegal, your age is &quot;</span> + age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 捕获底层可能产生的异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            saveAge2(<span class="number">225</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;saveAge2底层执行是成功的！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AgeIllegalException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;saveAge2底层执行是出现bug的！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(age &gt; <span class="number">0</span> &amp;&amp; age &lt; <span class="number">150</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄被成功保存： &quot;</span> + age);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用一个异常对象封装这个问题</span></span><br><span class="line">            <span class="comment">// throw 抛出去这个异常对象,给上层，由上层捕获</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeIllegalRuntimeException</span>(<span class="string">&quot;/age is illegal, your age is &quot;</span> + age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>比如有如下的场景：A调用用B，B调用C；C中有异常产生抛给B，B中有异常产生又抛给A；异常到了A这里就不建议再抛出了，因为最终抛出被JVM处理程序就会异常终止，并且给用户看异常信息，用户也看不懂，体验很不好。</p>
<p>此时比较好的做法就是：</p>
<ol>
<li>将异常捕获，将比较友好的信息显示给用户看</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您要找的文件不存在！！&quot;</span>);</span><br><span class="line">            e.printStackTrace(); <span class="comment">// 打印出这个异常对象的信息。记录下来。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您要解析的时间有问题了！&quot;</span>);</span><br><span class="line">            e.printStackTrace(); <span class="comment">// 打印出这个异常对象的信息。记录下来。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2028-11-11 10:24:11&quot;</span>);</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 读取文件的。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/meinv.png&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>尝试修复</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest4</span> &#123;</span><br><span class="line">    <span class="comment">// 需求：调用一个方法，让用户输入一个合适的价格返回为止。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试修复</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(getMoney());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请您输入合法的数字！！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请您输入合适的价格：&quot;</span>);</span><br><span class="line">            <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> sc.nextDouble(); </span><br><span class="line">            <span class="comment">//接收到非double类型会自动抛出异常</span></span><br><span class="line">            <span class="comment">//运行时异常，自动抛给上层</span></span><br><span class="line">            <span class="keyword">if</span>(money &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> money;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;您输入的价格是不合适的！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p>java提供了File类来对文件或文件夹进行操作，File对象只能对文件进行操作，<strong>不能操作文件中的内容</strong>。</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个File对象，指代某个具体的文件。</span></span><br><span class="line">        <span class="comment">// 路径分隔符</span></span><br><span class="line">        <span class="comment">// File f1 = new File(&quot;D:/resource/ab.txt&quot;);</span></span><br><span class="line">        <span class="comment">// File f1 = new File(&quot;D:\\resource\\ab.txt&quot;);</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:&quot;</span> + File.separator +<span class="string">&quot;resource&quot;</span> + File.separator + <span class="string">&quot;ab.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1.length()); <span class="comment">// 文件大小</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">//可以指向文件夹</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource&quot;</span>);</span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：File对象可以指代一个不存在的文件路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/aaaa.txt&quot;</span>);</span><br><span class="line">        System.out.println(f3.length());</span><br><span class="line">        System.out.println(f3.exists()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相对路径（重点）：不带盘符，默认是直接去工程下寻找文件的。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;file-io-app\\src\\itheima.txt&quot;</span>);</span><br><span class="line">        System.out.println(f4.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断当前文件对象，对应的文件路径是否存在，存在返回true.</span></span><br><span class="line">System.out.println(f4.exists());</span><br><span class="line"><span class="comment">// 判断当前文件对象指代的是否是文件，是文件返回true，反之。</span></span><br><span class="line">System.out.println(f4.isFile());</span><br><span class="line"><span class="comment">// 判断当前文件对象指代的是否是文件夹，是文件夹返回true，反之。</span></span><br><span class="line">System.out.println(f4.isDirectory());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件的名称（包含后缀）</span></span><br><span class="line">System.out.println(f1.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件的大小，返回字节个数</span></span><br><span class="line">System.out.println(f1.length());</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件的最后修改时间。</span></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> f1.lastModified();</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(sdf.format(time));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取创建文件对象时，使用的路径</span></span><br><span class="line">System.out.println(f3.getPath());</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取绝对路径</span></span><br><span class="line">System.out.println(f2.getAbsolutePath());</span><br></pre></td></tr></table></figure>

<h3 id="创建和删除文件"><a href="#创建和删除文件" class="headerlink" title="创建和删除文件"></a>创建和删除文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建新文件</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/itheima2.txt&quot;</span>);</span><br><span class="line">System.out.println(f1.createNewFile());</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建文件夹</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/resource/aaa&quot;</span>);</span><br><span class="line">System.out.println(f2.mkdir());</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.mkdir(): 只能创建单级文件夹</span></span><br><span class="line"><span class="comment">//2.mkdirs(): 能创建多级文件夹</span></span><br><span class="line"><span class="comment">//3.delete(): 文件可以直接删除，但是文件夹只能删除空的文件夹。</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历文件夹"><a href="#遍历文件夹" class="headerlink" title="遍历文件夹"></a>遍历文件夹</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、获取当前目录下所有的&quot;一级文件名称&quot;到一个字符串数组中去返回。</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\course\\待研发内容&quot;</span>);</span><br><span class="line">String[] names = f1.list();</span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">	System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//（重点）获取当前目录下所有的&quot;一级文件对象&quot;到一个文件对象数组中去返回（重点）</span></span><br><span class="line">File[] files = f1.listFiles();</span><br><span class="line"><span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">    System.out.println(file.getAbsolutePath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">          searchFile(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/&quot;</span>) , <span class="string">&quot;QQ.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去目录下搜索某个文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir  目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 要搜索的文件名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">searchFile</span><span class="params">(File dir, String fileName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、把非法的情况都拦截住</span></span><br><span class="line">        <span class="keyword">if</span>(dir == <span class="literal">null</span> || !dir.exists() || dir.isFile())&#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 代表无法搜索</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、dir不是null,存在，一定是目录对象。</span></span><br><span class="line">        <span class="comment">// 获取当前目录下的全部一级文件对象。</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、判断当前目录下是否存在一级文件对象，以及是否可以拿到一级文件对象。</span></span><br><span class="line">        <span class="keyword">if</span>(files != <span class="literal">null</span> &amp;&amp; files.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 4、遍历全部一级文件对象。</span></span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                <span class="comment">// 5、判断文件是否是文件,还是文件夹</span></span><br><span class="line">                <span class="keyword">if</span>(f.isFile())&#123;</span><br><span class="line">                    <span class="comment">// 是文件，判断这个文件名是否是我们要找的</span></span><br><span class="line">                    <span class="keyword">if</span>(f.getName().contains(fileName))&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;找到了：&quot;</span> + f.getAbsolutePath());</span><br><span class="line">                        <span class="comment">//启动程序</span></span><br><span class="line">                        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">                        runtime.exec(f.getAbsolutePath());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 是文件夹，继续重复这个过程（递归）</span></span><br><span class="line">                    searchFile(f, fileName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><h3 id="标准ASCII字符集"><a href="#标准ASCII字符集" class="headerlink" title="标准ASCII字符集"></a>标准ASCII字符集</h3><p>包含英文字母、标点符号、数字以及一些特殊字符，一共不到128个，7位编码就够了。所以用<strong>1个字节</strong>来存储每个字符，<strong>最高位补0</strong>。</p>
<h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p>汉字编码字符集，包含了2万多个汉字等字符，一个中文字符编码成<strong>两个字节</strong>。</p>
<p>汉字的第一个字节的第一位必须是1。</p>
<p>兼容ASCII。</p>
<ul>
<li>如果读取到第1位是0，就认为是一个字母，此时往后读1个字节。</li>
<li>如果读取到第1位是1，就认为是一个汉字，此时往后读2个字节。</li>
</ul>
<h3 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h3><p>国际组织制定的，可以容纳世界上所有文字和符号的字符集。</p>
<p>有三种</p>
<ul>
<li>UTF-32<ul>
<li>4个字节表示一个字符，占用空间大，浪费严重</li>
</ul>
</li>
<li>UTF-16</li>
<li><strong>UTF-8</strong><ul>
<li>可变长编码方案。共四种长度：1、2、3、4字节</li>
<li>规定1字节的以0开头；2字节的第一字节以110开头，第二字节以10开头；3字节的第一字节以1110开头，其余字节以10开头；4字节的第一字节以11110开头，其余字节以10开头。</li>
<li>英文字母、数字占1个字节。兼容ASCII编码</li>
<li>汉字字符占3个字节</li>
<li>极少数字符占4个字节</li>
</ul>
</li>
</ul>
<h3 id="编解码"><a href="#编解码" class="headerlink" title="编解码"></a>编解码</h3><ul>
<li>编码：把<strong>字符转换为字节</strong></li>
<li>解码：把<strong>字节转换为字符</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;a我b&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = data.getBytes(); <span class="comment">// 默认是按照平台字符集（UTF-8）进行编码的。</span></span><br><span class="line">        System.out.println(Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照指定字符集进行编码。</span></span><br><span class="line">        <span class="type">byte</span>[] bytes1 = data.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bytes1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、解码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes); <span class="comment">// 按照平台默认编码（UTF-8）解码</span></span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes1, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>按流的方向分</p>
<ul>
<li>输入流</li>
<li>输出流</li>
</ul>
<p>按流中数据的最小单位分：</p>
<ul>
<li>字节流，可以操作所有类型的文件</li>
<li>字符流，只适合操作文本文件。</li>
</ul>
<p>两两结合后共有四大流。 </p>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><ul>
<li>创建FileInputStream文件字节输入流管道，与源文件接通。</li>
<li>调用read()方法开始读取文件的字节数据。</li>
<li>调用close()方法释放资源</li>
</ul>
<p>字节流中的字节输入流，用InputStream来表示。但是InputStream是抽象类，我们用的是它的子类，叫FileInputStream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每次读取一个字节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建文件字节输入流管道，与源文件接通。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>((<span class="string">&quot;file-io-app\\src\\itheima01.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始读取文件的字节数据。</span></span><br><span class="line">        <span class="comment">// public int read():每次读取一个字节返回，如果没有数据了，返回-1.</span></span><br><span class="line">        <span class="type">int</span> b; <span class="comment">// 用于记住读取的字节。</span></span><br><span class="line">        <span class="keyword">while</span> ((b = is.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、流使用完毕之后，必须关闭！释放系统资源！</span></span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性读取完文件的全部字节到一个字节数组中去。</span></span><br><span class="line"><span class="comment">// 创建一个字节输入流管道与源文件接通</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file-io-app\\src\\itheima03.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、调用方法读取所有字节，返回一个存储所有字节的字节数组。</span></span><br><span class="line"><span class="type">byte</span>[] buffer = is.readAllBytes();</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、关闭流</span></span><br><span class="line">is.close(); </span><br></pre></td></tr></table></figure>

<h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><ul>
<li>创建FileOutputStream文件字节输出流管道，与目标文件接通。</li>
<li>调用wirte()方法往文件中写数据</li>
<li>调用close()方法释放资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个字节输出流管道与目标文件接通。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file-io-app/src/itheima04out.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始写字节数据出去了</span></span><br><span class="line">        os.write(<span class="number">97</span>); <span class="comment">// 97就是一个字节，代表a</span></span><br><span class="line">        os.write(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// &#x27;b&#x27;也是一个字节</span></span><br><span class="line">        <span class="comment">// os.write(&#x27;磊&#x27;); // [ooo] 默认只能写出去一个字节</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="string">&quot;我爱你中国abc&quot;</span>.getBytes();</span><br><span class="line">        os.write(bytes);</span><br><span class="line"></span><br><span class="line">        os.write(bytes, <span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">        <span class="comment">// 换行符</span></span><br><span class="line">        os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        os.close(); <span class="comment">// 关闭流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面释放资源的方法存在问题，当程序存在异常退出时，无法正常释放资源。</p>
<p>JDK7后提供了一种简化的释放资源的操作，它会自动释放资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(资源对象<span class="number">1</span>; 资源对象<span class="number">2</span>;)&#123;</span><br><span class="line">    <span class="comment">//使用资源的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类 e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    	<span class="keyword">try</span> (</span><br><span class="line">          <span class="comment">// 1、创建一个字节输入流管道与源文件接通</span></span><br><span class="line">          <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:/resource/meinv.png&quot;</span>);</span><br><span class="line">          <span class="comment">// 2、创建一个字节输出流管道与目标文件接通。</span></span><br><span class="line">          <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:/data/meinv.png&quot;</span>);</span><br><span class="line">        ) <span class="comment">//声明资源对象</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 3、创建一个字节数组，负责转移字节数据。</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">// 1KB.</span></span><br><span class="line">            <span class="comment">// 4、从字节输入流中读取字节数据，写出去到字节输出流中。读多少写出去多少。</span></span><br><span class="line">            <span class="type">int</span> len; <span class="comment">// 记住每次读取了多少个字节。</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;复制完成！！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>使用字节流可以读取文件中的字节数据。但是如果文件中有中文，使用字节流来读取，就有可能读到半个汉字的情况，这样会导致乱码。虽然使用读取全部字节的方法不会出现乱码，但是如果文件过大又不太合适。</p>
<p>所以Java专门为我们提供了另外一种流，叫字符流，可以字符流是专门为读取文本数据而生的。</p>
<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><h3 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h3><h3 id="IO框架"><a href="#IO框架" class="headerlink" title="IO框架"></a>IO框架</h3><p><strong>由apache开源基金组织提供了一组有关IO流小框架，可以提高IO流的开发效率。</strong></p>
<p>这个框架的名字叫<code>commons-io</code>：其本质是别人写好的一些字节码文件（class文件），打包成了一个jar包。只需要把jar包引入到项目中，就可以直接用了。 </p>
<h2 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h2><h3 id="properties文件"><a href="#properties文件" class="headerlink" title="properties文件"></a>properties文件</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>属性文件，每一行都是一个键值对，键和值中间用&#x3D;隔开。比如: <code>admin=123456</code> </p>
<p>每一行末尾不要加分号以及空格等字符；不然会把分号，空格会当做值的一部分。</p>
<p>键不能重复，值可以重复</p>
<h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个Properties的对象出来（键值对集合，空容器）</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        System.out.println(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、开始加载属性文件中的键值对数据到properties对象中去</span></span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;properties-xml-log-app\\src\\users.properties&quot;</span>));</span><br><span class="line">        System.out.println(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、根据键取值</span></span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;赵敏&quot;</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;张无忌&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、遍历全部的键和值。</span></span><br><span class="line">        <span class="comment">//获取键的集合</span></span><br><span class="line">        Set&lt;String&gt; keys = properties.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            <span class="comment">//再根据键获取值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;----&gt;&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        properties.forEach((k, v) -&gt; &#123;</span><br><span class="line">            System.out.println(k + <span class="string">&quot;----&gt;&quot;</span> + v);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建Properties对象出来，先用它存储一些键值对数据</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;minmin&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;殷素素&quot;</span>, <span class="string">&quot;cuishan&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;susu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、把properties对象中的键值对数据存入到属性文件中去</span></span><br><span class="line">        properties.store(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;properties-xml-log-app/src/users2.properties&quot;</span>)</span><br><span class="line">                         , <span class="string">&quot;i saved many users!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="XML文件"><a href="#XML文件" class="headerlink" title="XML文件"></a>XML文件</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>可扩展的标记语言，由一些标签组成，标签名可以自己定义（可扩展），但是必须要正确的嵌套</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注释：以上抬头声明必须放在第一行，必须有 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  根标签只能有一个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">users</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">desc</span>=<span class="string">&quot;第一个用户&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张无忌<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">地址</span>&gt;</span>光明顶<span class="tag">&lt;/<span class="name">地址</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>minmin<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">people</span>&gt;</span>很多人<span class="tag">&lt;/<span class="name">people</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>敏敏<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>女<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">地址</span>&gt;</span>光明顶<span class="tag">&lt;/<span class="name">地址</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>wuji<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">users</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>有很多开源、好用的XML解析框架，最知名的是DOM4J。其解析XML文件的思想是：文档对象模型（把整个XML文档、每一个标签、每一个属性都等都当做对象来看待）。Dowument对象表示XML文档、Element对象表示标签（元素）、Attribute对象表示属性、标签中的内容就是文本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dom4JTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建一个Dom4J框架提供的解析器对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用saxReader对象把需要解析的XML文件读成一个Document对象。</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span></span><br><span class="line">                saxReader.read(<span class="string">&quot;properties-xml-log-app\\src\\helloworld.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、从文档对象中解析XML文件的全部数据了</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        System.out.println(root.getName());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4、获取根元素下的全部一级子元素。</span></span><br><span class="line">        <span class="comment">// List&lt;Element&gt; elements = root.elements();</span></span><br><span class="line">        List&lt;Element&gt; elements = root.elements(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">            System.out.println(element.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、获取当前元素下的某个子元素。</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">people</span> <span class="operator">=</span> root.element(<span class="string">&quot;people&quot;</span>);</span><br><span class="line">        System.out.println(people.getText());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果下面有很多子元素user，默认获取第一个。</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">user</span> <span class="operator">=</span> root.element(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user.elementText(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、获取元素的属性信息呢？</span></span><br><span class="line">        System.out.println(user.attributeValue(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        <span class="type">Attribute</span> <span class="variable">id</span> <span class="operator">=</span> user.attribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        System.out.println(id.getName());</span><br><span class="line">        System.out.println(id.getValue());</span><br><span class="line"></span><br><span class="line">        List&lt;Attribute&gt; attributes = user.attributes();</span><br><span class="line">        <span class="keyword">for</span> (Attribute attribute : attributes) &#123;</span><br><span class="line">            System.out.println(attribute.getName() + <span class="string">&quot;=&quot;</span> + attribute.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7、如何获取全部的文本内容:获取当前元素下的子元素文本值</span></span><br><span class="line">        System.out.println(user.elementText(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        System.out.println(user.elementTextTrim(<span class="string">&quot;地址&quot;</span>)); <span class="comment">// 取出文本去除前后空格</span></span><br><span class="line">        System.out.println(user.elementText(<span class="string">&quot;password&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Element</span> <span class="variable">data</span> <span class="operator">=</span> user.element(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        System.out.println(data.getText());</span><br><span class="line">        System.out.println(data.getTextTrim()); <span class="comment">// 取出文本去除前后空格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Logback第三方日志框架"><a href="#Logback第三方日志框架" class="headerlink" title="Logback第三方日志框架"></a>Logback第三方日志框架</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>官网<code>https://logback.qos.ch/index.html</code>。分为三个模块，logback-core、logback-classic和logback-access。其中core是其他两个模块的基础，classic是log4j的改进，access与Servlet容器集成，提供http访问。</p>
<p>想使用Logback日志框架，至少要再项目中整合三个模块：</p>
<ul>
<li>slf4j-api：日志接口</li>
<li>logback-core</li>
<li>logback-classic</li>
</ul>
<h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><p>将Jar包引入到项目中，具体步骤如下</p>
<ol>
<li><p>在资料中找到<code>slftj-api.jar、logback-core.jar、logback-classes.jar</code> 这三个jar包，复制一下</p>
</li>
<li><p>在当前模块下面新建一个lib文件夹，把刚刚复制的三个jar包都粘贴到此处</p>
</li>
<li><p>从资料中找到<code>logback.xml</code>配置文件，将此文件复制粘贴到src目录下（必须是src目录）</p>
</li>
</ol>
<h3 id="日志对象"><a href="#日志对象" class="headerlink" title="日志对象"></a>日志对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogBackTest</span> &#123;</span><br><span class="line">    <span class="comment">//public static final Logger LOGGER = LoggerFactory.getLogger(&quot;当前类名&quot;);</span></span><br><span class="line">    <span class="comment">// 创建一个Logger日志对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;LogBackTest&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//while (true) &#123;</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;chu法方法开始执行~~~&quot;</span>);</span><br><span class="line">                chu(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">                LOGGER.info(<span class="string">&quot;chu法方法执行成功~~~&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;chu法方法执行失败了，出现了bug~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">chu</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;参数a:&quot;</span> + a);</span><br><span class="line">        LOGGER.debug(<span class="string">&quot;参数b:&quot;</span> + b);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a / b;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;结果是：&quot;</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台和文件都会记录日志信息。</p>
<h3 id="日志配置文件"><a href="#日志配置文件" class="headerlink" title="日志配置文件"></a>日志配置文件</h3><p>Logback提供了一个核心配置文件logback.xml，日志框架在记录日志时会读取配置文件中的配置信息，从而记录日志的形式。</p>
<ul>
<li>配置日志输出的位置是文件、还是控制台</li>
</ul>
<ol start="2">
<li>配置日志输出的格式</li>
<li>配置日志关闭和开启、以及哪些日志输出哪些日志不输出。</li>
</ol>
<h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p>Logback只输出大于或者等于核心配置文件配置的日志级别信息。小于配置级别的日志信息，不被记录。</p>
<table>
<thead>
<tr>
<th>日志级别</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>trace</td>
<td>程序运行轨迹</td>
</tr>
<tr>
<td>debug</td>
<td>实际应用中一般将其作为最低级，trace很少用</td>
</tr>
<tr>
<td>info</td>
<td>运行信息，包括网络连接、IO操作等</td>
</tr>
<tr>
<td>warn</td>
<td>可能会发生的问题</td>
</tr>
<tr>
<td>error</td>
<td>错误信息</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java面向对象</title>
    <url>/2023/10/10/15-00-37/</url>
    <content><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="类与对象的执行原理"><a href="#类与对象的执行原理" class="headerlink" title="类与对象的执行原理"></a>类与对象的执行原理</h3><p><code>Student s1 = new Student();</code>这句话中的原理如下</p>
<ul>
<li><code>Student s1</code>表示的是在<strong>栈</strong>内存中，创建了一个Student类型的变量，变量名为s1</li>
<li>而<code>new Student()</code>会在<strong>堆</strong>内存中创建一个对象，而对象中包含学生的属性名和属性值，同时系统会为这个Student对象分配一个地址值0x4f3f5b24</li>
<li>类的代码存放在<strong>方法区</strong>。</li>
</ul>
<span id="more"></span>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>一个代码文件中，可以写多个class类，但是只能有一个是public修饰，且public修饰的类必须和文件名相同。</p>
<h2 id="实体类JavaBean"><a href="#实体类JavaBean" class="headerlink" title="实体类JavaBean"></a>实体类JavaBean</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>实体类就是一种特殊的类，它需要满足下面的要求：</p>
<ul>
<li>类中的成员变量都要<strong>私有</strong>，且对外提供相应的<strong>get</strong>和<strong>set</strong>方法。</li>
<li>类中必须有一个<strong>无参构造器</strong></li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>实体类仅仅只用来<strong>封装数据</strong>，而对数据的处理交给其他类来完成，以实现<strong>数据和数据业务处理相分离</strong>。</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h3 id="修饰成员变量"><a href="#修饰成员变量" class="headerlink" title="修饰成员变量"></a>修饰成员变量</h3><p>Java中的成员变量按照有无static修饰分为两种：<strong>类变量、实例变量</strong>。</p>
<p>静态变量是属于类的，只需要通过类名就可以调用：**<code>类名.静态变量</code>**</p>
<p>实例变量是属于对象的，需要通过对象才能调用：**<code>对象.实例变量</code>**</p>
<p>如果某个数据只需要一份，且希望能够被共享（访问、修改），则该数据可以定义成类变量来记住。</p>
<ul>
<li>比如用户类可以记住自己创建了多少个用户对象。</li>
</ul>
<h3 id="修饰成员方法"><a href="#修饰成员方法" class="headerlink" title="修饰成员方法"></a>修饰成员方法</h3><p>成员方法根据有无static也分为两类：<strong>类方法、实例方法</strong></p>
<p>有static修饰的方法，是属于类的，称为<strong>类方法</strong>；调用时直接用类名调用即可。</p>
<p>无static修饰的方法，是属于对象的，称为实例方法；调用时，需要使用对象调用</p>
<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><p>如果一个类中的方法全都是静态的，那么这样的类就叫做工具类。</p>
<p>比如一个生成验证码的类就可以写成工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUtils</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createCode</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//1.定义一个字符串，用来记录产生的验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.验证码是由所有的大写字母、小写字母或者数字字符组成</span></span><br><span class="line">        <span class="comment">//这里先把所有的字符写成一个字符串，一会从字符串中随机找字符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.循环n次，产生n个索引,再通过索引获取字符</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> r.nextInt(data.length());</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> data.charAt(index);</span><br><span class="line">            <span class="comment">//4.把获取到的字符，拼接到code验证码字符串上。</span></span><br><span class="line">            code+=ch;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后返回code,code的值就是验证码</span></span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块根据有无static修饰分为两种：静态代码块、实例代码块</p>
<h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p>类加载时自动执行，只执行一次，在构造器之前执行。</p>
<p>可以用于完成类的初始化等，例如对类变量的初始化赋值。</p>
<h4 id="实例代码块"><a href="#实例代码块" class="headerlink" title="实例代码块"></a>实例代码块</h4><p>在创建对象之前执行，<strong>每次创建对象之前都会执行一次</strong></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>Java中提供了一个关键字extends，用这个关键字，可以让一个类和另一个类建立起父子关系。</p>
<p>子类能继承父类的<strong>非私有</strong>成员。</p>
<p>带继承关系的类，java会用类和其父类，这<strong>多张设计图</strong>来一起创建类的对象。</p>
<h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>用来限制类中的成员（成员变量、成员方法、构造器、代码块…）能够被访问的范围。</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>本类里</th>
<th>同一个包中的类</th>
<th>子孙类</th>
<th>任意类</th>
</tr>
</thead>
<tbody><tr>
<td><strong>private</strong></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>缺省</strong></td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>protected</strong></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td><strong>public</strong></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>Java是单继承的，即一个类只能继承一个父类，但是支持<strong>多层继承</strong>。</p>
<p>Object类是java中所有类的祖先类，我们写的任何一个类，只要没有继承别的类，都会默认继承Object。</p>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>当子类觉得父类中的某个方法不好用，或者无法满足自己的需求时，子类可以重写一个方法名称、参数列表一样的方法，去覆盖父类的这个方法，这就是方法重写。</p>
<ul>
<li>使用Override注解，他可以指定java编译器，检查我们方法重写的格式是否正确，代码可读性也会更好。</li>
<li>子类重写父类方法时，访问权限必须大于或者等于父类该方法的权限（ public &gt; protected &gt; 缺省 ）。</li>
<li>重写的方法返回值类型，必须与被重写方法的返回值类型一样，或者范围更小。</li>
<li>私有方法、静态方法不能被重写，如果重写会报错的。</li>
<li>一般而言，方法重写遵循返回值类型和权限都不变，只改变方法的原则</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>最常见的应用是子类重写Object类的<code>toString()</code>方法，以便返回对象的内容。</p>
<p>java支持直接打印类，系统会调用Object类中的<code>toString</code>方法进行输出。</p>
<p>Object类默认的toString方法返回的是地址，一般不用。此外，由于特别常用，因此不用自己写，像setter和getter一样可以生成。</p>
<h3 id="子类访问成员的特点"><a href="#子类访问成员的特点" class="headerlink" title="子类访问成员的特点"></a>子类访问成员的特点</h3><p>继承至少涉及到两个类，而每一个类中都可能有各自的成员（成员变量、成员方法），就有可能出现子类和父类有相同成员的情况。</p>
<p><strong>在子类中访问其他成员（成员变量、成员方法），是依据就近原则的</strong></p>
<ul>
<li>先子类局部范围找</li>
<li>再子类成员范围找</li>
<li>最后父类成员范围找，找不到就报错</li>
</ul>
<p>如果子类和父类出现同名变量或者方法，优先使用子类的；此时如果一定要在子类中使用父类的成员，可以加<strong>this</strong>或者<strong>super</strong>进行区分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;父类名字&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==父类的print1方法执行==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Z</span> <span class="keyword">extends</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;子类名称&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;局部名称&quot;</span>;</span><br><span class="line">        System.out.println(name); <span class="comment">// 局部名称</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name); <span class="comment">// 子类成员变量</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.name); <span class="comment">// 父类的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==子类的print1方法执行了=&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        print1(); <span class="comment">// 子类的</span></span><br><span class="line">        <span class="built_in">super</span>.print1(); <span class="comment">// 父类的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子类构造器的特点"><a href="#子类构造器的特点" class="headerlink" title="子类构造器的特点"></a>子类构造器的特点</h3><h4 id="super"><a href="#super" class="headerlink" title="super()"></a><code>super()</code></h4><p>子类的构造器会<strong>先调用父类构造器</strong>，再执行自己。</p>
<p>因为子类构造器中会默认带一行<code>super()</code>代码，作用就是调用父类的构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Z</span> <span class="keyword">extends</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Z</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// super(); //默认存在的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类z的无参构造器执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Z</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="comment">// super(); //默认存在的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类z的有参构造器执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="super-String"><a href="#super-String" class="headerlink" title="super(String)"></a><code>super(String)</code></h4><p>如果父类没有构造器，会默认带一个无参构造器；但如果父类只有一个有参构造器，系统就不会生成默认的无参构造器，此时由于子类中默认存在的<code>super()</code>还回去找父类的无参构造器，就会报错。</p>
<p>如果不想使用默认的<code>super()</code>方式调用父类构造器，还可以手动使用<code>super(参数)</code>调用父类有参数构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Z</span> <span class="keyword">extends</span> <span class="title class_">F</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Z</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">//调用父类的带String参数的构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类z的有参构造器执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String skill;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name,<span class="type">int</span> age,String skill)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name,age); <span class="comment">//调用父类的有参构造器来完成初始化</span></span><br><span class="line">        <span class="built_in">this</span>.skill = skill;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="this"><a href="#this" class="headerlink" title="this()"></a><code>this()</code></h4><p>通过使用<code>this()</code>可以调用本类中的无参构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="comment">//需求：当学生没有填写年龄，默认18岁</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">       	<span class="comment">//this.name=name;</span></span><br><span class="line">        <span class="comment">//this.age=18; </span></span><br><span class="line">        <span class="comment">//这样写也能实现，但代码和下面的有参构造器的相似度太高</span></span><br><span class="line">        <span class="built_in">this</span>(name,<span class="number">18</span>); <span class="comment">//可以直接调用下面的有参构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：在一个构造器中，this和super不能同时使用。</strong>有this时，super不会默认存在</p>
<ul>
<li>this和super都要写在构造器的第一行</li>
<li>this在调用其他构造器时，必定会调用super，不需要再有一个super</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>多态是在继承&#x2F;实现情况下的一种现象，表现为：<strong>对象多态</strong>、<strong>行为多态</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">People</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">People</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line"><span class="comment">//p1和p2都是people类型，但是指向的对象不一样，这种现象称之为对象多态</span></span><br><span class="line">p1.run();<span class="comment">//编译看左边，运行看右边，即编译器找的是people类中的run，运行时找student类中的run</span></span><br><span class="line">p2.run();</span><br><span class="line"><span class="comment">//都可以调用run方法，但两个方法表现的行为不一样，这种现象称之为行为多态</span></span><br></pre></td></tr></table></figure>

<p>多态前提</p>
<ul>
<li>有继承&#x2F;实现关系</li>
<li>存在父类引用子类对象</li>
<li>存在方法重写</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>在多态形式下，右边的代码是<strong>解耦合</strong>的，更便于扩展和维护。</li>
</ol>
<p>耦合是指两个或两个以上的体系或两种运动形式间通过相互作用而彼此影响以至联合起来的现象。让数据模型，业务逻辑和视图显示三层之间彼此降低耦合，把关联依赖降到最低，而不至于牵一发而动全身。原则就是A功能的代码不要写在B的功能代码中，如果两者之间需要交互，可以通过接口，通过消息，甚至可以引入框架，但总之就是不要直接交叉写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">People</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="comment">//多态如何解耦合。</span></span><br><span class="line"><span class="comment">//假设Student类需要换成别的类，使用多态可以直接替换，下面的代码不需要修改</span></span><br><span class="line"><span class="comment">//People p1 = new Teacher();</span></span><br><span class="line">p1.run();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义方法时，<strong>使用父类类型作为形参，可以接收一切子类对象</strong>，扩展行更强，更便利。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握使用多态的好处</span></span><br><span class="line">		<span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">		go(t);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        go(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数People p既可以接收Student对象，也能接收Teacher对象。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(People p)</span>&#123;</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>在使用多态时，由于编译器在找方法时以左边的类型为准，因此子类的独有方法无法编译通过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">People</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">p1.study(); <span class="comment">//由于People类中没有study方法，因此编译不通过</span></span><br></pre></td></tr></table></figure>

<p>要解决上述缺点，就需要多态下的类型转换。</p>
<ul>
<li><p>自动类型转换：<code>People p = new Student();</code></p>
</li>
<li><p>强制类型转换：<code>Student t = (Student)p;</code></p>
</li>
<li><p>错误转换：<code>Teacher t = (Teacher)p;</code></p>
</li>
</ul>
<p>因为p<strong>原本就是student，才能转成student</strong>。</p>
<p>如果类型转换错了，编译阶段能通过，但是在运行时会出现类型转换异常ClassCastException，比如把Teacher类型转换成了Student类型。原因是编译和运行的认知不同，编译器认为p是people类型，且teacher继承了people，故允许这种转换。</p>
<p><strong>原本是什么类型，才能强转成什么类型。</strong></p>
<p>Java建议在强转前使用<code>instanceof</code>判断当前对象的真实类型，再强转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">t</span> <span class="operator">=</span> (Student) p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个用在行为多态更合适，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">		go(t);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        go(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数People p既可以接收Student对象，也能接收Teacher对象。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(People p)</span>&#123;</span><br><span class="line">        p.run();</span><br><span class="line">        <span class="keyword">if</span>(p <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) p;</span><br><span class="line">            s.study();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p <span class="keyword">instanceof</span> Teacher)&#123;</span><br><span class="line">            <span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> (Teacher) p;</span><br><span class="line">            p.teach();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p><code>abstract</code>关键字可以修饰类和方法，变成抽象类和抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//abstract修饰类，这个类就是抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//abstract修饰方法，这个方法就是抽象方法</span></span><br><span class="line">    <span class="comment">//抽象方法不能有方法体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抽象类中不一定有抽象方法，<strong>有抽象方法的类一定是抽象类</strong>。</li>
<li>类该有的成员（成员变量、方法、构造器）抽象类都可以有。</li>
<li>抽象类最主要的特点：<strong>抽象类不能创建对象</strong>，仅作为一种特殊的父类，让子类继承并实现。</li>
<li>一个类继承抽象类，必须重写完抽象类的全部抽象方法，否则这个类也必须定义成抽象类。</li>
</ul>
<h2 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>父类知道每个子类都要做的行为，但每个子类的情况不同，父类就定义成抽象方法，强制子类去重载。</li>
<li>不知道系统未来具体的业务实现时，我们可以先定义抽象类，将来让子类去实现，以方便系统的扩展。</li>
<li>总之，<strong>抽象类是为了更好地支持多态</strong>。</li>
</ol>
<p>例如，有猫类和狗类，都有叫的方法，但他们叫的行为不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动物叫的行为：不具体，是抽象的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;汪汪汪的叫~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;喵喵喵的叫~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：掌握抽象类的使用场景和好处.</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        a.cry();	<span class="comment">//这时执行的是Dog类的cry方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>Java提供了一个关键字interface，用这个关键字来定义接口这种特殊结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;</span><br><span class="line">    <span class="comment">//成员变量（常量）</span></span><br><span class="line">    <span class="comment">//成员方法（抽象方法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//这里public static final默认存在，可以不加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;黑马程序员&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里的public abstract默认存在，可以不加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//打印A接口中的常量</span></span><br><span class="line">        System.out.println(A.SCHOOL_NAME);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//接口是不能创建对象的</span></span><br><span class="line">        <span class="comment">//A a = new A();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>接口是用来被类实现的，我们称之为实现类。</strong></li>
<li><strong>一个类是可以实现多个接口的（接口可以理解成干爹），类实现接口必须重写所有接口的全部抽象方法，否则这个类也必须是抽象类</strong></li>
</ul>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>弥补了单继承的不足，一个类同时可以实现多个接口。</li>
<li>让程序可以<strong>面向接口编程</strong>，这样程序员可以灵活方便的切换各种业务实现。</li>
</ul>
<p>比如一个学生，但他也可以是歌手，也可以是司机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Driver</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Singer</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A类是Student的子类，同时也实现了Dirver接口和Singer接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Driver</span>, Singer&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//想唱歌的时候，A类对象就表现为Singer类型</span></span><br><span class="line">        <span class="type">Singer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="comment">//面向接口编程，后面的对象可以灵活地替换</span></span><br><span class="line">        s.sing();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//想开车的时候，A类对象就表现为Driver类型</span></span><br><span class="line">        <span class="type">Driver</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        d.drive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>设计一个班级学生的信息管理模块：学生的数据有：姓名、性别、成绩</p>
<p>功能1：要求打印出全班学生的信息； 功能2：要求打印出全班学生的平均成绩。</p>
<p>注意！以上功能的业务实现是有多套方案的，比如：</p>
<p>第1套方案：能打印出班级全部学生的信息；能打印班级全部学生的平均分。</p>
<p>第2套方案：能打印出班级全部学生的信息（包含男女人数）；能打印班级全部学生的平均分（要求是去掉最高分、最低分）。</p>
<p><strong>要求：系统可以支持灵活的切换这些实现方案。</strong></p>
<ol>
<li>先写一个学生类，用来描述学生的相关信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">char</span> sex, <span class="type">double</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">char</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">double</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>写一个StudentOperator接口，表示学生信息管理系统的两个功能。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentOperator</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printAllInfo</span><span class="params">(ArrayList&lt;Student&gt; students)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printAverageScore</span><span class="params">(ArrayList&lt;Student&gt; students)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>写一个StudentOperator接口的实现类StudentOperatorImpl1，采用第1套方案对业务进行实现。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentOperatorImpl1</span> <span class="keyword">implements</span> <span class="title class_">StudentOperator</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAllInfo</span><span class="params">(ArrayList&lt;Student&gt; students)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------全班全部学生信息如下--------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAverageScore</span><span class="params">(ArrayList&lt;Student&gt; students)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">allScore</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>写一个StudentOperator接口的实现类StudentOperatorImpl2，采用第2套方案对业务进行实现。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentOperatorImpl2</span> <span class="keyword">implements</span> <span class="title class_">StudentOperator</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAllInfo</span><span class="params">(ArrayList&lt;Student&gt; students)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------全班全部学生信息如下--------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printAverageScore</span><span class="params">(ArrayList&lt;Student&gt; students)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">allScore</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>写一个班级管理类ClassManager，在班级管理类中使用StudentOperator的实现类StudentOperatorImpl1对学生进行操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StudentOperator</span> <span class="variable">studentOperator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentOperatorImpl1</span>();</span><br><span class="line">    <span class="comment">//需要更换方案时，只需要把对象名换一下。</span></span><br><span class="line">    <span class="comment">//private StudentOperator studentOperator = new StudentOperatorImpl2();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassManager</span><span class="params">()</span>&#123;</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">99</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;古力娜扎&quot;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印全班全部学生的信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        studentOperator.printAllInfo(students);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印全班全部学生的平均分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScore</span><span class="params">()</span>&#123;</span><br><span class="line">        studentOperator.printAverageScore(students);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK8新特性"><a href="#JDK8新特性" class="headerlink" title="JDK8新特性"></a>JDK8新特性</h3><p>从jdk8开始，接口新增了三种方法形式。</p>
<ul>
<li>默认方法：是个实例方法，需要使用实现类的对象访问</li>
<li>私有方法：是个实例方法，只能在内部访问(同接口的默认方法或其他私有方法中访问)</li>
<li>静态方法：用static修饰，用接口名访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、默认方法：必须使用default修饰，默认会被public修饰</span></span><br><span class="line"><span class="comment">     * 实例方法：对象的方法，必须使用实现类的对象来访问。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===默认方法==&quot;</span>);</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、私有方法：必须使用private修饰。(JDK 9开始才支持的)</span></span><br><span class="line"><span class="comment">     *   实例方法：对象的方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===私有方法==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、静态方法：必须使用static修饰，默认会被public修饰</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==静态方法==&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>假如现在有一个接口被10个类继承，现在要在接口中新增一个方法，如果没有新特性，需要在10个类中都实现这个方法。利用新特性，只需要在接口中增加一个默认方法即可</p>
<p><strong>增强接口能力，便于项目维护和扩展</strong></p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li>一个接口继承多个接口，如果多个接口中存在相同的方法声明，则此时不支持多继承</li>
<li>一个类实现多个接口，如果多个接口中存在相同的方法声明，则此时不支持多实现</li>
<li>一个类继承了父类，又同时实现了接口，父类中和接口中有同名的默认方法，实现类会有限使用父类的方法</li>
<li>一个类实现了多个接口，多个接口中有同名的默认方法，则这个类必须重写该方法。</li>
</ol>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>内部类是类中的五大成分之一（成员变量、方法、构造器、内部类、代码块），如果一个类定义在另一个类的内部，这个类就是内部类。</p>
<p>当一个类的内部，包含一个完整的事物，且这个事物没有必要单独设计时，就可以把这个事物设计成内部类。</p>
<p>比如：汽车、的内部有发动机，发动机是包含在汽车内部的一个完整事物，可以把发动机设计成内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">	<span class="comment">//内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Engine</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类有四种形式，分别是成员内部类、静态内部类、局部内部类、<strong>匿名内部类</strong>。前面三种了解即可</p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类就是类中的一个普通成员，类似于成员变量、成员方法。</p>
<p>在内部类中既可以访问自己类的成员，也可以访问外部类的成员。</p>
<p>如果内部类成员和外部类成员同名，可以使用**<code>类名.this.成员</code>**区分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String a=<span class="string">&quot;黑马&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span>  <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">88</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在内部类中既可以访问自己类的成员，也可以访问外部类的成员</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(age); <span class="comment">//88</span></span><br><span class="line">            System.out.println(a);   <span class="comment">//黑马</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">77</span>;</span><br><span class="line">            System.out.println(age); <span class="comment">//77</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.age); <span class="comment">//88</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.age); <span class="comment">//99</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外部类.内部类 变量名 = new 外部类().new 内部类();</span></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line"><span class="comment">//内部类是外部类的成员，要先创建外部类对象才能创建内部类对象</span></span><br><span class="line"><span class="comment">//调用内部类的方法</span></span><br><span class="line">in.test();</span><br></pre></td></tr></table></figure>

<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类属于外部类自己持有。静态内部类可以访问外部类的静态变量，但<strong>不能访问外部类的实例变量</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String schoolName=<span class="string">&quot;黑马&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="comment">//静态内部类访问外部类的静态变量，是可以的；</span></span><br><span class="line">        <span class="comment">//静态内部类访问外部类的实例变量，是不行的</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(schoolName); <span class="comment">//99</span></span><br><span class="line">            <span class="comment">//System.out.println(age);   //报错</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式：外部类.内部类 变量名 = new 外部类.内部类();</span></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br><span class="line">in.test();</span><br></pre></td></tr></table></figure>

<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类是定义在方法中的类，和局部变量一样，只能在方法中有效。所以局部内部类的局限性很强，一般在开发中是不会使用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Inner...show&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//局部内部类只能在方法中创建对象，并使用</span></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        in.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><h4 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h4><p>匿名内部类是一种<strong>特殊的局部内部类</strong>；且不需要为这个类声明名字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类/接口(参数值)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    重写父类/接口的方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>匿名内部类本质上是一个没有名字的子类<strong>对象</strong>、或者接口的实现类<strong>对象</strong>。</p>
<p>编译器会把这个匿名内部类编译成一个子类，然后立即创建一个子类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//这里后面new 的部分，其实就是一个Animal的子类对象</span></span><br><span class="line">        <span class="comment">//这里隐含的有多态的特性： Animal a = Animal子类对象;</span></span><br><span class="line">        <span class="comment">//如果某个类很少实例化，甚至只需要实例化一次，就不必声明名字，直接匿名创建对象</span></span><br><span class="line">        <span class="comment">//Animal a = new Cat();</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猫喵喵喵的叫~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a.cry(); <span class="comment">//直线上面重写的cry()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>在调用方法时，当方法的形参是一个接口或者抽象类，为了<strong>简化代码书写</strong>，而直接传递匿名内部类对象给方法。这样就可以少写一个类。</p>
<p><strong>通常自己不会用，一般只有在系统API需要传递接口或类对象时才用</strong>。比如在写GUI时绑定事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Swimming</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Swimming</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;狗刨飞快&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        go(s1);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Swimming</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猴子游泳也还行&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        go(s1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//形参是Swimming接口，实参可以接收任意Swimming接口的实现类对s象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(Swimming s)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始~~~~~~~~&quot;</span>);</span><br><span class="line">        s.swim();</span><br><span class="line">        System.out.println(<span class="string">&quot;结束~~~~~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java设计模式</title>
    <url>/2023/10/12/08-30-37/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>一个问题通常有n种解法，其中肯定有一种解法是最优的，这个最优的解法被人总结出来了，称之为<strong>设计模式</strong>。</p>
<p>关于设计模式，重点关注</p>
<ul>
<li>解决什么问题</li>
<li>怎么写</li>
</ul>
<span id="more"></span>

<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>确保一个类只有一个对象</p>
<h3 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h3><p>实现方法有很多种。主要的要点包括</p>
<ul>
<li>把类的<strong>构造器私有</strong>，确保外部无法创建对象。</li>
<li>定义一个<strong>类变量</strong>记住类的一个对象</li>
<li>定义一个<strong>类方法</strong>，返回对象。</li>
</ul>
<h4 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h4><p>拿对象时，对象早就创建好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单例类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="comment">// 2、定义一个类变量记住类的一个对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">	<span class="comment">// 1、私有构造器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3、定义一个类方法返回对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">getObject</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h4><p>拿对象时才开始创建对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单例类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="comment">// 2、定义一个类变量记住类的一个对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> A a;</span><br><span class="line">	<span class="comment">// 1、私有构造器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3、定义一个类方法返回对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> A <span class="title function_">getObject</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="literal">null</span>)&#123;</span><br><span class="line">            a=<span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>在某些业务场景下，使用单例模式，可以避免浪费内存。如任务管理器对象、全局只有一个，获取运行时对象。</p>
<h2 id="模板方法-设计模式"><a href="#模板方法-设计模式" class="headerlink" title="模板方法 设计模式"></a>模板方法 设计模式</h2><p><strong>主要解决方法中存在重复代码的问题</strong>。</p>
<p>比如两个方法大部分代码相同，只有少部分不同的代码。</p>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//用final修饰，防止被重写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;唱一首你喜欢的歌：&quot;</span>); <span class="comment">//相同部分</span></span><br><span class="line">        doSing(); <span class="comment">//不同部分</span></span><br><span class="line">        System.out.println(<span class="string">&quot;唱完了!&quot;</span>); <span class="comment">//相同部分</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doSing</span><span class="params">()</span>; <span class="comment">//把不同部分定义为抽象方法，强制子类实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一只小小小小鸟，想要飞就能飞的高~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们一起学猫叫，喵喵喵喵喵喵喵~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：搞清楚模板方法设计模式能解决什么问题，以及怎么写。</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.sing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul>
<li>定义一个抽象类，把子类中相同的代码写成一个模板方法(建议使用final修饰，防止重写)。</li>
<li>把模板方法中不能确定的代码写成抽象方法，并在模板方法中调用。</li>
<li>子类继承抽象类，实现父类的抽象方法。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk8新特性</title>
    <url>/2023/10/29/19-00-37/</url>
    <content><![CDATA[<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>用于简化匿名内部类代码的书写。只能简化<strong>函数式接口</strong>的匿名内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(被重写方法的形参列表) -&gt; &#123;</span><br><span class="line">    被重写方法的方法体代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>函数式接口：接口中只有一个抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> <span class="comment">//函数式接口注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Swimming</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：认识Lambda表达式.</span></span><br><span class="line">        <span class="comment">//1.创建一个Swimming接口的匿名内部类对象</span></span><br><span class="line">		<span class="type">Swimming</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swimming</span>()&#123;</span><br><span class="line">             <span class="meta">@Override</span></span><br><span class="line">             <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                 System.out.println(<span class="string">&quot;学生快乐的游泳~~~~&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">         s.swim();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//2.使用Lambda表达式对Swimming接口的匿名内部类进行简化</span></span><br><span class="line">        <span class="type">Swimming</span> <span class="variable">s1</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;学生快乐的游泳~~~~&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        s1.swim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译时，编译器会把Lambda表达式的简化写法复原，由于接口中只有一个方法，所以编译器能找到它。</p>
<h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><ol>
<li>参数类型可以不写</li>
<li>如果只有一个参数，参数类型和()都可以省略</li>
<li>如果方法体中只有一行代码，可以不写大括号和分号。<strong>如果这行代码是return语句，必须把return去掉</strong></li>
</ol>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><h3 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h3><p>原代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用Lambda简化后的形式</span></span><br><span class="line">        Arrays.sort(students, (o1, o2) -&gt; o1.getAge() - o2.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把Lambda表达式中的方法体用一个静态方法代替</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompareByData</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareByAge</span><span class="params">(Student o1, Student o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge() - o2.getAge(); <span class="comment">// 升序排序的规则</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(students, (o1, o2) -&gt; CompareByData.compareByAge(o1, o2));</span><br></pre></td></tr></table></figure>

<p>此时可以进一步化简。<strong>实际上就是用类名调用方法，但是把参数给省略了。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态方法引用：类名::方法名</span></span><br><span class="line">Arrays.sort(students, CompareByData::compareByAge);</span><br></pre></td></tr></table></figure>

<h3 id="实例方法引用"><a href="#实例方法引用" class="headerlink" title="实例方法引用"></a>实例方法引用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CompareByData</span> <span class="variable">compare</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CompareByData</span>();</span><br><span class="line">Arrays.sort(students, (o1, o2) -&gt; compare.compareByAgeDesc(o1, o2)); <span class="comment">// 降序</span></span><br><span class="line"></span><br><span class="line">Arrays.sort(students, compare::compareByAgeDesc); <span class="comment">// 降序</span></span><br></pre></td></tr></table></figure>

<h3 id="特点类型的方法引用"><a href="#特点类型的方法引用" class="headerlink" title="特点类型的方法引用"></a>特点类型的方法引用</h3><blockquote>
<p>Java约定：<br> 如果某个Lambda表达式里只是调用一个实例方法，并且前面参数列表中的第一个参数作为方法的主调，	后面的所有参数都是作为该实例方法的入参时，则就可以使用特定类型的方法引用。<br>格式：<br>    类型::方法名</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要求忽略首字符大小写进行排序。</span></span><br><span class="line">Arrays.sort(names, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line"><span class="comment">// 制定比较规则。o1 = &quot;Andy&quot;  o2 = &quot;angela&quot;</span></span><br><span class="line"><span class="keyword">return</span> o1.compareToIgnoreCase(o2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//lambda表达式写法</span></span><br><span class="line">Arrays.sort(names, ( o1,  o2) -&gt; o1.compareToIgnoreCase(o2) );</span><br><span class="line"><span class="comment">//特定类型的方法引用！</span></span><br><span class="line">Arrays.sort(names, String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure>



<h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、创建这个接口的匿名内部类对象。</span></span><br><span class="line"><span class="type">CreateCar</span> <span class="variable">cc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateCar</span>()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Car <span class="title function_">create</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Car</span>(name, price);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//2、使用匿名内部类改进</span></span><br><span class="line"><span class="type">CreateCar</span> <span class="variable">cc2</span> <span class="operator">=</span> (name,  price) -&gt; <span class="keyword">new</span> <span class="title class_">Car</span>(name, price);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、使用方法引用改进：构造器引用</span></span><br><span class="line"><span class="type">CreateCar</span> <span class="variable">cc3</span> <span class="operator">=</span> Car::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a><code>Stream</code></h2><p>专门用于<strong>对集合或者数组的便捷操作</strong>。</p>
<p>数据源-&gt;中间步骤(过滤，排序，去重)-&gt;获取结果</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、获取List集合的Stream流</span></span><br><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(names, <span class="string">&quot;张三丰&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;赵敏&quot;</span>,<span class="string">&quot;张强&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream = names.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、获取Set集合的Stream流</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(set, <span class="string">&quot;刘德华&quot;</span>,<span class="string">&quot;张曼玉&quot;</span>,<span class="string">&quot;蜘蛛精&quot;</span>,<span class="string">&quot;马德&quot;</span>,<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream1 = set.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、获取Map集合的Stream流,key与value要先分开操作</span></span><br><span class="line">Map&lt;String, Double&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">172.3</span>);</span><br><span class="line">map.put(<span class="string">&quot;迪丽热巴&quot;</span>, <span class="number">168.3</span>);</span><br><span class="line">map.put(<span class="string">&quot;马尔扎哈&quot;</span>, <span class="number">166.3</span>);</span><br><span class="line">map.put(<span class="string">&quot;卡尔扎巴&quot;</span>, <span class="number">168.3</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">Stream&lt;String&gt; ks = keys.stream();</span><br><span class="line"></span><br><span class="line">Collection&lt;Double&gt; values = map.values();</span><br><span class="line">Stream&lt;Double&gt; vs = values.stream();</span><br><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;String, Double&gt;&gt; entries = map.entrySet();</span><br><span class="line">Stream&lt;Map.Entry&lt;String, Double&gt;&gt; kvs = entries.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、获取数组的Stream流</span></span><br><span class="line">String[] names2 = &#123;<span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;东方不败&quot;</span>, <span class="string">&quot;唐大山&quot;</span>, <span class="string">&quot;独孤求败&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; s1 = Arrays.stream(names2);</span><br><span class="line">Stream&lt;String&gt; s2 = Stream.of(names2);</span><br></pre></td></tr></table></figure>



<h3 id="中间方法"><a href="#中间方法" class="headerlink" title="中间方法"></a>中间方法</h3><p><strong>中间方法指的是：调用完方法之后其结果是一个新的Stream流，于是可以继续调用方法，这样一来就可以支持链式编程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">scores.stream().filter(s -&gt; s &gt;= <span class="number">60</span>).sorted().forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">students.stream().filter(s -&gt; s.getAge() &gt;= <span class="number">23</span> &amp;&amp; s.getAge() &lt;= <span class="number">30</span>)</span><br><span class="line">                .sorted((o1, o2) -&gt; o2.getAge() - o1.getAge())</span><br><span class="line">                .forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">students.stream().sorted((o1, o2) -&gt; Double.compare(o2.getHeight(), o1.getHeight()))</span><br><span class="line">                .limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">students.stream().sorted((o1, o2) -&gt; Double.compare(o2.getHeight(), o1.getHeight()))</span><br><span class="line">                .skip(students.size() - <span class="number">2</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">168</span>).map(Student::getName)</span><br><span class="line">               .distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">students.stream().filter(s -&gt; s.getHeight() &gt; <span class="number">168</span>)</span><br><span class="line">                .distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure>



<h3 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h3><p>终结方法的特点是，调用完方法之后，其结果就不再是Stream流了，所以不支持链式编程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> students.stream().max((o1, o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight())).get();</span><br><span class="line"></span><br><span class="line">Map&lt;String, Double&gt; map =</span><br><span class="line">                students.stream().filter(a -&gt; a.getHeight() &gt; <span class="number">170</span>)</span><br><span class="line">                        .distinct().collect(Collectors.toMap(a -&gt; a.getName(), a -&gt; a.getHeight()));</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java常用API</title>
    <url>/2023/10/18/10-30-37/</url>
    <content><![CDATA[<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Object是java中所有类的祖先类，所以Java中所有类的对象都可以直接使用Object类中提供的一些方法。</p>
<span id="more"></span>

<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><h3 id="equals-Object-o"><a href="#equals-Object-o" class="headerlink" title="equals(Object o)"></a>equals(Object o)</h3><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><h2 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h2><p>Objects是一个工具类，提供了一些方法可以对任意对象进行操作。</p>
<h2 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h2><p>Java中<strong>万物皆对象</strong>，但8种基本数据类型还不是对象，所以要把它们变成对象，变成对象之后，可以提供一些方法对数据进行操作。</p>
<p>学习包装类，主要学习两点：</p>
<ul>
<li><ol>
<li>创建包装类的对象方式、自动装箱和拆箱的特性；</li>
</ol>
</li>
<li><ol start="2">
<li>利用包装类提供的方法对字符串和基本类型数据进行相互转换</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java注意事项</title>
    <url>/2023/10/30/19-00-37/</url>
    <content><![CDATA[<ul>
<li>case语句如果不加break，在第一次匹配成功时，后面所有语句都会执行，知道遇到break，不管case能不能匹配上</li>
</ul>
<span id="more"></span>

<p><img src="/pic/1.jpg"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程</title>
    <url>/2023/11/01/19-00-37/</url>
    <content><![CDATA[<h2 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h2><p>Java通过java.lang.Thread 类的对象来代表线程。 </p>
<h3 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h3><p>需要重写run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前thread输出：&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程类已经继承Thread，无法继承其他类，不利于功能的扩展。</p>
<h3 id="实现runnable接口"><a href="#实现runnable接口" class="headerlink" title="实现runnable接口"></a>实现runnable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建任务对象</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">//把任务对象交给一个线程对象处理</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(target).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展性强，但需要多一个Runnable对象。</p>
<h4 id="匿名内部类写法"><a href="#匿名内部类写法" class="headerlink" title="匿名内部类写法"></a>匿名内部类写法</h4><ul>
<li>创建Runnable的匿名内部类对象</li>
<li>交给Thread线程对象</li>
<li>调用线程对象的start启动线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="meta">@override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(target).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//或者将上面两步合起来</span></span><br><span class="line">        <span class="comment">//new Thread(new Runnable()&#123;</span></span><br><span class="line">        <span class="comment">//    @override</span></span><br><span class="line">        <span class="comment">//    public void run()&#123;</span></span><br><span class="line">        <span class="comment">//        System.out.println(&quot;子线程&quot;);</span></span><br><span class="line">        <span class="comment">//    &#125;</span></span><br><span class="line">        <span class="comment">//&#125;).start();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Runnable是函数式接口，可以用lambda简化</span></span><br><span class="line">        <span class="comment">//new Thread(()-&gt;&#123;</span></span><br><span class="line">        <span class="comment">//	  System.out.println(&quot;子线程&quot;);</span></span><br><span class="line">        <span class="comment">//&#125;).start();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现callable接口"><a href="#实现callable接口" class="headerlink" title="实现callable接口"></a>实现callable接口</h3><p><strong>以上两种方法都不能返回线程执行的结果</strong></p>
<p>使用Callable接口和FutureTask类可以返回线程执行后的结果。</p>
<ul>
<li>创建任务对象<br>定义一个类实现Callable接口，重写call方法，封装要做的事情，和要返回的数据。<br>把Callable类型的对象封装成FutureTask（线程任务对象）。</li>
<li>把线程<strong>任务对象</strong>交给Thread对象。</li>
<li>调用Thread对象的start方法启动线程。</li>
<li>线程执行完毕后、通过FutureTask对象的的get方法去获取线程任务执行的结果。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// callable是一个泛型接口，需要填返回类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="comment">// 2、必须重写call方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 描述线程的执行任务。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程MyThread输出：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 3、创建一个Callable的对象</span></span><br><span class="line">        Callable&lt;String&gt; call = <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        <span class="comment">// 4、把Callable的对象封装成一个FutureTask对象（任务对象）</span></span><br><span class="line">        <span class="comment">// 未来任务对象的作用？</span></span><br><span class="line">        <span class="comment">// 1、是一个任务对象，实现了Runnable对象.</span></span><br><span class="line">        <span class="comment">// 2、可以在线程执行完毕之后，用未来任务对象调用get方法获取线程执行完毕后的结果。</span></span><br><span class="line">        FutureTask&lt;String&gt; f  = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call);</span><br><span class="line">        <span class="comment">// 5、把任务对象交给一个Thread对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(f).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、获取线程执行完毕后返回的结果。</span></span><br><span class="line">        <span class="comment">// 注意：如果执行到这儿，假如上面的线程还没有执行完毕</span></span><br><span class="line">        <span class="comment">// 这里的代码会暂停，等待上面线程执行完毕后才会获取结果。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> f.get();</span><br><span class="line">        System.out.println(rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th>方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>继承Thread类</td>
<td>编程比较简单，可以直接使用Thread类中的方法</td>
<td>扩展性较差，不能再继承其他的类，不能返回线程执行的结果</td>
</tr>
<tr>
<td>实现Runnable接口</td>
<td>扩展性强，实现该接口的同时还可以继承其他的类。</td>
<td>编程相对复杂，不能返回线程执行的结果</td>
</tr>
<tr>
<td>实现Callable接口</td>
<td>扩展性强，实现该接口的同时还可以继承其他的类。<strong>可以得到线程执行的结果</strong></td>
<td>编程相对复杂</td>
</tr>
</tbody></table>
<h2 id="Thread常用方法"><a href="#Thread常用方法" class="headerlink" title="Thread常用方法"></a>Thread常用方法</h2><table>
<thead>
<tr>
<th>Thread提供的常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void run()</td>
<td>线程的任务方法</td>
</tr>
<tr>
<td>public void start()</td>
<td>启动线程</td>
</tr>
<tr>
<td>public String getName()</td>
<td>获取当前线程的名称，线程名称默认是Thread-索引</td>
</tr>
<tr>
<td>public void setName(String name)</td>
<td>为线程设置名称</td>
</tr>
<tr>
<td>public static Thread currentThread()</td>
<td>获取当前执行的线程对象</td>
</tr>
<tr>
<td>public static void sleep(long time)</td>
<td>让当前执行的线程休眠多少毫秒后，再继续执行</td>
</tr>
<tr>
<td>public final void join()</td>
<td>让调用当前这个方法的线程先执行完！</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Thread提供的常见构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Thread(String name)</td>
<td>可以为当前线程指定名称</td>
</tr>
<tr>
<td>public Thread(Runnable target)</td>
<td>封装Runnable对象成为线程对象</td>
</tr>
<tr>
<td>public Thread(Runnable target, String name)</td>
<td>封装Runnable对象成为线程对象，并指定线程名称</td>
</tr>
</tbody></table>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="存在原因"><a href="#存在原因" class="headerlink" title="存在原因"></a>存在原因</h3><ul>
<li>存在多个线程在同时执行</li>
<li>同时访问一个共享资源</li>
<li>存在修改该共享资源</li>
</ul>
<p>解决线程安全可以用线程同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="comment">// 1、创建一个账户对象，代表两个人的共享账户。</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;ICBC-110&quot;</span>, <span class="number">100000</span>);</span><br><span class="line">        <span class="comment">// 2、创建两个线程，分别代表小明 小红，再去同一个账户对象中取钱10万。</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小明&quot;</span>).start(); <span class="comment">// 小明</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小红&quot;</span>).start(); <span class="comment">// 小红</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>让多个线程实现先后依次访问共享资源，方法：<strong>加锁</strong>。有三种方式</p>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>把访问共享资源的核心<strong>代码</strong>给上锁，以此保证线程安全。</p>
<p>每次只允许一个线程加锁后进入，执行完毕后自动解锁，其他线程才可以进来执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized(同步锁) &#123;</span><br><span class="line">	访问共享资源的核心代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">    <span class="comment">// 先搞清楚是谁来取钱？</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">    <span class="comment">// this正好代表共享资源！</span></span><br><span class="line">    <span class="comment">// 选中代码后ctrl alt t</span></span><br><span class="line">    <span class="comment">//synchronized (&quot;lock&quot;) &#123; //锁对象可以任意取</span></span><br><span class="line">    <span class="comment">//字符串作为锁对象是全局唯一的。也就是说如果这个锁对象同时锁住了所有账户上的所有其他线程</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>建议把共享资源作为锁对象, 不要将随便无关的对象当做锁对象</li>
<li>对于实例方法，建议使用this作为锁对象</li>
<li>对于静态方法，建议把类的字节码(类名.class)当做锁对象</li>
</ol>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>把访问共享资源的核心<strong>方法</strong>给上锁，以此保证线程安全</p>
<p>每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步方法</span></span><br><span class="line"><span class="comment">// 把操作共享资源的方法用synchronized修饰</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">    <span class="comment">// 先搞清楚是谁来取钱？</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.money -= money;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码。</li>
<li>如果方法是实例方法：同步方法默认用this作为的锁对象。</li>
<li>如果方法是静态方法：同步方法默认用类名.class作为的锁对象。</li>
</ul>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>范围上：同步代码块锁的范围更小，同步方法锁的范围更大。因此同步代码块性能更好<br>可读性：同步方法更好。</p>
<h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><p>Lock锁是JDK5版本专门提供的一种锁对象，通过这个锁对象的方法来达到加锁，和释放锁的目的，使用起来<strong>更加灵活</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建锁对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">mylock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mylock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">            <span class="comment">// 1、判断余额是否足够</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money)&#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;来取钱&quot;</span> + money + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.money -= money;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;来取钱后，余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;来取钱：余额不足~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//加try catch finally防止加锁和解锁之间有异常，导致加了锁但没解锁</span></span><br><span class="line">            mylock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>当多个线程共同操作共享的资源时，线程间通过某种方式互相告知自己的状态，以相互协调，并避免无效的资源争夺。</p>
<p>常见的模型为生产者与消费者模型。</p>
<p>Object类的等待和唤醒方法：</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void wait()</td>
<td>让当前线程等待并释放所占锁，直到另一个线程调用notify()方法或 notifyAll()方法</td>
</tr>
<tr>
<td>void notify()</td>
<td>唤醒正在等待的单个线程</td>
</tr>
<tr>
<td>void notifyAll()</td>
<td>唤醒正在等待的所有线程</td>
</tr>
</tbody></table>
<p>注意：上述方法应该<strong>使用当前同步锁对象进行调用</strong>(只有锁对象知道谁等待谁唤醒)，此外，<strong>先唤醒再等待</strong></p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>以三个生产者，两个消费者为例。生产者生产完数据后应该让自己等待，通知其他消费者消费；消费者消费完数据之后应该让自己等待，同时通知生产者生成。</p>
<blockquote>
<p>1.先确定在这个案例中，什么是共享数据？<br>答：这里案例中桌子是共享数据，因为厨师和顾客都需要对桌子上的包子进行操作。</p>
<p>2.再确定有那几条线程？哪个是生产者，哪个是消费者？<br>答：厨师是生产者线程，3条生产者线程；<br>   顾客是消费者线程，2条消费者线程</p>
<p>3.什么时候将哪一个线程设置为什么状态<br>生产者线程(厨师)放包子：<br>     1)先判断是否有包子<br>     2)没有包子时，厨师开始做包子, 做完之后把别人唤醒，然后让自己等待<br>     3)有包子时，不做包子了，直接唤醒别人、然后让自己等待<br>     	<br>消费者线程(顾客)吃包子：<br>     1)先判断是否有包子<br>     2)有包子时，顾客开始吃包子, 吃完之后把别人唤醒，然后让自己等待<br>     3)没有包子时，不吃包子了，直接唤醒别人、然后让自己等待</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Desk</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放1个包子的方法</span></span><br><span class="line">    <span class="comment">// 厨师1 厨师2 厨师3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="comment">// 判断是否有包子。</span></span><br><span class="line">            <span class="keyword">if</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                list.add(name + <span class="string">&quot;做的肉包子&quot;</span>);</span><br><span class="line">                System.out.println(name + <span class="string">&quot;做了一个肉包子~~&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 唤醒别人, 等待自己</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 有包子了，不做了。</span></span><br><span class="line">                <span class="comment">// 唤醒别人, 等待自己</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 吃货1 吃货2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">if</span>(list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 有包子，吃了</span></span><br><span class="line">                System.out.println(name  + <span class="string">&quot;吃了：&quot;</span> + list.get(<span class="number">0</span>));</span><br><span class="line">                list.clear();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有包子</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//   需求：3个生产者线程，负责生产包子，每个线程每次只能生产1个包子放在桌子上</span></span><br><span class="line">        <span class="comment">//      2个消费者线程负责吃包子，每人每次只能从桌子上拿1个包子吃。</span></span><br><span class="line">        <span class="type">Desk</span> <span class="variable">desk</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Desk</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建3个生产者线程（3个厨师）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;厨师1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;厨师2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.put();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;厨师3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建2个消费者线程（2个吃货）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;吃货1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                desk.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;吃货2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池是可以复用线程的技术。</p>
<p>用户每发起一个请求，后台就需要创建一个新线程来处理，下次新任务来了肯定又要创建新线程处理的，  而创建新线程的开销是很大的，并且请求过多时，肯定会产生大量的线程出来，这样会严重影响系统的性能。</p>
<img src="D:/blog/source/pic/线程池工作原理.jpg" style="zoom:50%;" />

<p>线程池中有<strong>一定数量</strong>的工作线程，将<strong>任务对象</strong>(实现了runnable或callable)放入任务队列中，工作线程会依次执行这些任务，其余的任务在队列中等待。</p>
<p>由于线程数量是一定的，资源的耗费是可控的。</p>
<h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><p>JDK 5.0起提供了代表线程池的<strong>接口</strong>：ExecutorService。</p>
<h4 id="通过实现类创建对象"><a href="#通过实现类创建对象" class="headerlink" title="通过实现类创建对象"></a>通过实现类创建对象</h4><p>java提供了线程池接口的实现类，常用的是<code>ThreadPoolExecutor</code>。</p>
<img src="D:/blog/source/pic/ThreadPoolExecutor构造器.jpg" style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">3</span>,	<span class="comment">//核心线程数有3个</span></span><br><span class="line">    <span class="number">5</span>,  <span class="comment">//最大线程数有5个。   临时线程数=最大线程数-核心线程数=5-3=2</span></span><br><span class="line">    <span class="number">8</span>,	<span class="comment">//临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。</span></span><br><span class="line">    TimeUnit.SECONDS,<span class="comment">//时间单位（秒）</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), <span class="comment">//任务阻塞队列，没有来得及执行的任务在，任务队列中等待</span></span><br><span class="line">    Executors.defaultThreadFactory(), <span class="comment">//用于创建线程的工厂对象</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="comment">//拒绝策略</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会<strong>创建临时线程</strong>。</li>
<li>核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始<strong>拒绝任务</strong>。</li>
</ul>
<p>ExecutorService的常用方法</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void execute(Runnable command)</td>
<td>执行 Runnable 任务</td>
</tr>
<tr>
<td>Future<T> submit(Callable<T> task)</td>
<td>执行 Callable 任务，返回未来任务对象，用于获取线程返回的结果</td>
</tr>
<tr>
<td>void shutdown()</td>
<td>等全部任务执行完毕后，再关闭线程池！</td>
</tr>
<tr>
<td>List<Runnable> shutdownNow()</td>
<td>立刻关闭线程池，停止正在执行的任务，并返回队列中未执行的任务</td>
</tr>
</tbody></table>
<p>新任务拒绝策略</p>
<table>
<thead>
<tr>
<th><strong>策略</strong></th>
<th><strong>详解</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ThreadPoolExecutor.AbortPolicy</td>
<td>丢弃任务并抛出RejectedExecutionException异常。<strong>是默认的策略</strong></td>
</tr>
<tr>
<td>ThreadPoolExecutor.DiscardPolicy：</td>
<td>丢弃任务，但是不抛出异常 这是不推荐的做法</td>
</tr>
<tr>
<td>ThreadPoolExecutor.DiscardOldestPolicy</td>
<td>抛弃队列中等待最久的任务 然后把当前任务加入队列中</td>
</tr>
<tr>
<td>ThreadPoolExecutor.CallerRunsPolicy</td>
<td>由主线程负责调用任务的run()方法从而绕过线程池直接执行</td>
</tr>
</tbody></table>
<h4 id="通过工具类返回对象-少用"><a href="#通过工具类返回对象-少用" class="headerlink" title="通过工具类返回对象(少用)"></a>通过工具类返回对象(少用)</h4><p>Executors是一个线程池的工具类，提供了很多静态方法用于返回不同特点的线程池对象。</p>
<p>底层基本还是用ThreadPoolExecutor实现的</p>
<p><strong>大型并发系统不建议使用</strong></p>
<table>
<thead>
<tr>
<th><strong>方法名称</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>public static ExecutorService newFixedThreadPool(int nThreads)</td>
<td>创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它。</td>
</tr>
<tr>
<td>public static ExecutorService newSingleThreadExecutor()</td>
<td>创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程。</td>
</tr>
<tr>
<td>public static ExecutorService newCachedThreadPool()</td>
<td>线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了60s则会被回收掉。</td>
</tr>
<tr>
<td>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</td>
<td>创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务。</td>
</tr>
</tbody></table>
<h3 id="处理runnable任务"><a href="#处理runnable任务" class="headerlink" title="处理runnable任务"></a>处理runnable任务</h3><p>先准备一个线程任务类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 任务是干啥的？</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ==&gt; 输出666~~&quot;</span>);</span><br><span class="line">        <span class="comment">//为了模拟线程一直在执行，这里睡久一点</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">3</span>,	<span class="comment">//核心线程数有3个</span></span><br><span class="line">    <span class="number">5</span>,  <span class="comment">//最大线程数有5个。   临时线程数=最大线程数-核心线程数=5-3=2</span></span><br><span class="line">    <span class="number">8</span>,	<span class="comment">//临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。</span></span><br><span class="line">    TimeUnit.SECONDS,<span class="comment">//时间单位（秒）</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>), <span class="comment">//任务阻塞队列，没有来得及执行的任务在，任务队列中等待</span></span><br><span class="line">    Executors.defaultThreadFactory(), <span class="comment">//用于创建线程的工厂对象</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy() <span class="comment">//拒绝策略</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line">pool.execute(target); <span class="comment">// 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！</span></span><br><span class="line"><span class="comment">//下面4个任务在任务队列里排队</span></span><br><span class="line">pool.execute(target);</span><br><span class="line">pool.execute(target);</span><br><span class="line">pool.execute(target);</span><br><span class="line">pool.execute(target);</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务队列满了还有新任务，且线程池最大数量没达到，就创建临时线程</span></span><br><span class="line">pool.execute(target);</span><br><span class="line">pool.execute(target);</span><br><span class="line"><span class="comment">// 到了新任务的拒绝时机了！</span></span><br><span class="line">pool.execute(target);</span><br></pre></td></tr></table></figure>



<h3 id="处理callable任务"><a href="#处理callable任务" class="headerlink" title="处理callable任务"></a>处理callable任务</h3><p>callable任务相对于Runnable任务来说，就是多了一个返回值。</p>
<p>准备一个Callable线程任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、重写call方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 描述线程的任务，返回线程执行返回后的结果。</span></span><br><span class="line">        <span class="comment">// 需求：求1-n的和返回。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;求出了1-&quot;</span> + n + <span class="string">&quot;的和是：&quot;</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、通过ThreadPoolExecutor创建一个线程池对象。</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,</span><br><span class="line">            TimeUnit.SECONDS, </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用线程处理Callable任务。</span></span><br><span class="line">        Future&lt;String&gt; f1 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>));</span><br><span class="line">        Future&lt;String&gt; f2 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>));</span><br><span class="line">        Future&lt;String&gt; f3 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">300</span>));</span><br><span class="line">        Future&lt;String&gt; f4 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">400</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、执行完Callable任务后，需要获取返回结果。</span></span><br><span class="line">        System.out.println(f1.get());</span><br><span class="line">        System.out.println(f2.get());</span><br><span class="line">        System.out.println(f3.get());</span><br><span class="line">        System.out.println(f4.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>进程中的线程是由CPU负责调度执行的，但CPU能同时处理线程的数量有限，为了保证全部线程都能往前执行，CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。</p>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>在同一个时刻上，同时有多个线程在被CPU调度执行。</p>
<p><strong>多线程是并发和并行同时进行的</strong></p>
<h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p>线程从生到死的过程中，经历的各种状态及状态转换。</p>
<p>java中定义了6中状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        NEW,</span><br><span class="line">        RUNNABLE,</span><br><span class="line">        BLOCKED,</span><br><span class="line">        WAITING,</span><br><span class="line">        TIMED_WAITING,</span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/pic/线程生命周期.jpg" style="zoom: 80%;" />

<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>之前介绍的锁都是悲观锁：一上来就上锁，每次一个线程访问完毕后再解锁，线程安全但性能差。</p>
<p>乐观锁：一开始不上锁，要出现线程安全问题时才上锁，线程安全且性能好。</p>
<p>CAS算法(比较和修改)，把值取出来修改，在写回去之前比较最新的值和取出来的值，如果一样，说明中间没有别的线程修改，可以安全修改；如果不一样说明被别的线程修改过了，需要重新取最新值比较和修改。</p>
<p>把公共资源用Atomic修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java高级</title>
    <url>/2023/11/03/11-00-37/</url>
    <content><![CDATA[<span id="more"></span>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>java网络编程</title>
    <url>/2023/11/02/21-57-37/</url>
    <content><![CDATA[<h2 id="通信架构"><a href="#通信架构" class="headerlink" title="通信架构"></a>通信架构</h2><p>基本的通信架构有2种形式：CS架构（ Client客户端&#x2F;Server服务端 ） 、 BS架构(Browser浏览器&#x2F;Server服务端)。</p>
<span id="more"></span>

<h2 id="网络通信三要素"><a href="#网络通信三要素" class="headerlink" title="网络通信三要素"></a>网络通信三要素</h2><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>全称”互联网协议地址”，是设备在网络中的地址，是唯一的标识。有两种形式：IPv4、IPv6。</p>
<h4 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h4><p>有4字节，用点分十进制表示法</p>
<blockquote>
<p>11000000 10101000 00000001 01000010   —-&gt;   192.168.1.66</p>
</blockquote>
<p>IPv4总共32位，能容纳40多亿台设备，在全球范围内肯定是不够用的。</p>
<h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>共128位，号称可以为地球每一粒沙子编号。IPv6分成8段表示，每段每四位编码成一个十六进制位表示， 数之间用冒号（：）分开，即冒分十六进制表示法。</p>
<blockquote>
<p>2001:0db8:0000:0023:0008:0800:200c:417a</p>
</blockquote>
<h4 id="IP域名"><a href="#IP域名" class="headerlink" title="IP域名"></a>IP域名</h4><p>使用域名访问服务时，会先由本地DNS服务器将域名解析为IP地址进行访问。</p>
<h4 id="公网、内网"><a href="#公网、内网" class="headerlink" title="公网、内网"></a>公网、内网</h4><p>公网IP：是可以连接互联网的IP地址；</p>
<p>内网IP：也叫局域网IP，只能组织机构内部使用。<br>192.168. 开头的就是常见的局域网地址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用。</p>
<p>127.0.0.1、localhost：代表本机IP，只会寻找当前所在的主机。</p>
<h4 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h4><p>Java提供了对象来表示ip地址，常用方法如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static InetAddress getLocalHost()</td>
<td>获取本机IP，会以一个inetAddress的对象返回</td>
</tr>
<tr>
<td>public static InetAddress getByName(String host)</td>
<td>根据ip地址或者域名，返回一个inetAdress对象</td>
</tr>
<tr>
<td>public String getHostName()</td>
<td>获取该ip地址对象对应的主机名。</td>
</tr>
<tr>
<td>public String getHostAddress()</td>
<td>获取该ip地址对象中的ip地址信息。</td>
</tr>
<tr>
<td>public boolean isReachable(int timeout)</td>
<td>在指定毫秒内，判断主机与该ip对应的主机是否能连通</td>
</tr>
</tbody></table>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>程序在设备中唯一的标识，为一个 16 位的二进制，范围是 0~65535。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>周知端口：0~1023，被预先定义的知名应用占用（如：HTTP占用 80，FTP占用21） </li>
<li>注册端口：1024~49151，分配给用户进程或某些应用程序。</li>
<li>动态端口：49152到65535，之所以称为动态端口，是因为它 一般不固定分配某种进程，而是动态分配。</li>
</ul>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>连接和数据在网络中传输的规则。</p>
<ul>
<li>OSI网络参考模型：全球网络互联标准。</li>
<li>TCP&#x2F;IP网络模型：事实上的国际标准。</li>
</ul>
<table>
<thead>
<tr>
<th>OSI网络参考模型</th>
<th>TCP&#x2F;IP网络模型</th>
<th><strong>各层对应</strong></th>
<th><strong>面向操作</strong></th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>应用层</td>
<td>HTTP、FTP、SMTP…</td>
<td>应用程序需要关注的：浏览器，邮箱。程序员一般在这一层开发</td>
</tr>
<tr>
<td>表示层</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>会话层</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
<td>UDP、TCP…</td>
<td>选择使用的TCP , UDP协议</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
<td>IP…</td>
<td>封装源和目标IP</td>
</tr>
<tr>
<td>数据链路层</td>
<td>数据链路层+ 物理</td>
<td>比特流…</td>
<td>物理设备中传输</td>
</tr>
<tr>
<td>物理层</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>用户数据报协议，无连接、不可靠通信，但效率高，通常用于视频和语音。</p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul>
<li>特点：面向连接、可靠通信。</li>
<li>TCP的最终目的：要保证在不可靠的信道上实现可靠的传输。</li>
<li>TCP主要有三个步骤实现可靠传输：<strong>三次握手建立连接</strong>，双方均确认<strong>对方的收和发</strong>均无问题，四次挥手断开连接(a:b,我走了；b:a,等会,我看看数据传完没有；b:a,好了走吧；a:b,好的再见)。传输数据时也会进行确认。</li>
</ul>
<p>可靠连接：确定通信双方，收发消息都是正常无问题的！（全双工）</p>
<h2 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h2><p>Java提供了一个java.net.DatagramSocket类来实现UDP通信。发送端每次把要发送的数据（限制在64KB内）、接收端IP、等信息封装成一个数据包，发出去就不管了。</p>
<p><img src="/pic/UDP%E5%AF%B9%E8%B1%A1.jpg"></p>
<h3 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建客户端对象（发韭菜出去的人）</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(); <span class="comment">//这里会给发送端随机分配ip</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建数据包对象封装要发出去的数据（创建一个韭菜盘子）</span></span><br><span class="line">       <span class="comment">/* public DatagramPacket(byte buf[], int length,</span></span><br><span class="line"><span class="comment">             InetAddress address, int port)</span></span><br><span class="line"><span class="comment">               参数一：封装要发出去的数据。</span></span><br><span class="line"><span class="comment">               参数二：发送出去的数据大小（字节个数）</span></span><br><span class="line"><span class="comment">               参数三：服务端的IP地址（找到服务端主机）</span></span><br><span class="line"><span class="comment">               参数四：服务端程序的端口。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="string">&quot;我是快乐的客户端，我爱你abc&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length</span><br><span class="line">                , InetAddress.getLocalHost(),  <span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、开始正式发送这个数据包的数据出去了</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;客户端数据发送完毕~~~&quot;</span>);</span><br><span class="line">        socket.close(); <span class="comment">// 释放资源！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----服务端启动----&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建一个服务端对象（创建一个接韭菜的人） 注册端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、创建一个数据包对象，用于接收数据的（创建一个韭菜盘子）</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">64</span>]; <span class="comment">// 64KB.</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、开始正式使用数据包来接收客户端发来的数据</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、从字节数组中，把接收到的数据直接打印出来</span></span><br><span class="line">        <span class="comment">// 接收多少就倒出多少</span></span><br><span class="line">        <span class="comment">// 获取本次数据包接收了多少数据。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> packet.getLength();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> , len);</span><br><span class="line">        System.out.println(rs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取发送端的ip和端口</span></span><br><span class="line">        System.out.println(packet.getAddress().getHostAddress());</span><br><span class="line">        System.out.println(packet.getPort());</span><br><span class="line"></span><br><span class="line">        socket.close(); <span class="comment">// 释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h2><p>Java提供了一个java.net.Socket类来实现TCP通信。</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><table>
<thead>
<tr>
<th><strong>构造器</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>public Socket(String host , int port)</td>
<td>根据指定的服务器ip、端口号请求与服务端建立连接，连接通过，就获得了客户端socket</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>public OutputStream getOutputStream()</td>
<td>获得字节输出流对象</td>
</tr>
<tr>
<td>public InputStream getInputStream()</td>
<td>获得字节输入流对象</td>
</tr>
<tr>
<td>原始的字节流不是很好用，把原始的OutputStream包装为DataOutputStream比较好用。</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、创建Socket对象，并同时请求与服务端程序的连接。</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、从socket通信管道中得到一个字节输出流，用来发数据给服务端程序。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、把低级的字节输出流包装成数据输出流</span></span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(os);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、开始写数据出去了</span></span><br><span class="line">        dos.writeUTF(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        dos.close();</span><br><span class="line"></span><br><span class="line">        socket.close(); <span class="comment">// 释放连接资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><table>
<thead>
<tr>
<th><strong>构造器</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>public ServerSocket(int port)</td>
<td>为服务端程序注册端口</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>public Socket accept()</td>
<td>阻塞等待客户端的连接请求，一旦与某个客户端成功连接，则返回服务端这边的Socket对象。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----服务端启动成功-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、从socket通信管道中得到一个字节输入流。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、把原始的字节输入流包装成数据输入流</span></span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、使用数据输入流读取客户端发送过来的消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">        System.out.println(rs);</span><br><span class="line">        <span class="comment">// 也可以获取客户端的IP地址</span></span><br><span class="line">        System.out.println(socket.getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line">        dis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程改进"><a href="#多线程改进" class="headerlink" title="多线程改进"></a>多线程改进</h3><p>让服务端能够支持多个客户端通信，就需要用到多线程技术。</p>
<p>每当有一个客户端连接服务端，在服务端这边就为Socket开启一条线程取执行读取数据的操作，来多少个客户端，就有多少条线程。<strong>一个线程负责一条socket通信管道</strong></p>
<p>写一个服务端的读取数据的线程类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(is);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;有人下线了：&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line">                    dis.close();</span><br><span class="line">                    socket.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----服务端启动成功-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;有人上线了：&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。</span></span><br><span class="line">            <span class="type">ServerReaderThread</span> <span class="variable">mythread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerReaderThread</span>(socket);</span><br><span class="line">            mythread1.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="群聊案例"><a href="#群聊案例" class="headerlink" title="群聊案例"></a>群聊案例</h3><p>如何能让一个客户端的消息被多个客户端接收？</p>
<p>服务端维护一个集合，存储在线的socket，收到一个客户端的消息后转发给其他客户端。</p>
<h3 id="BS架构通信"><a href="#BS架构通信" class="headerlink" title="BS架构通信"></a>BS架构通信</h3><p>服务器必须给浏览器响应HTTP协议规定的数据格式，否则浏览器不识别返回的数据。</p>
<p>客户端程序不需要我们编写（浏览器就是），所以我们只需要写服务端就可以了。</p>
<p>先写一个线程类，用于按照HTTP协议的格式返回数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerReaderThread</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//  立即响应一个网页内容：“黑马程序员”给浏览器展示。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(os);</span><br><span class="line">            ps.println(<span class="string">&quot;HTTP/1.1 200 OK&quot;</span>);</span><br><span class="line">            ps.println(<span class="string">&quot;Content-Type:text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">            ps.println(); <span class="comment">// 必须换行</span></span><br><span class="line">            ps.println(<span class="string">&quot;&lt;div style=&#x27;color:red;font-size:120px;text-align:center&#x27;&gt;黑马程序员666&lt;div&gt;&quot;</span>);</span><br><span class="line">            ps.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写服务端的主程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----服务端启动成功-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 1、创建ServerSocket的对象，同时为服务端注册端口。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;有人上线了：&quot;</span> + socket.getRemoteSocketAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServerReaderThread</span>(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
