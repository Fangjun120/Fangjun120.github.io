<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/04/07/20-54-53/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>算法性能</title>
    <url>/2023/06/23/20-56-15/</url>
    <content><![CDATA[<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h4 id="什么是时间复杂度"><a href="#什么是时间复杂度" class="headerlink" title="什么是时间复杂度"></a>什么是时间复杂度</h4><p>时间复杂度是一个函数，它定性描述该算法的运行时间。</p>
<p>假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。</p>
<p><strong>大O用来表示上界</strong>，但代表的是一般情况，而不是严格的上界。就像快排的时间复杂度是O(nlogn)，但最坏情况下应该是O(n^2)。<strong>大O是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量</strong>。</p>
<p>所以我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大。</p>
<p>O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(nlogn)线性对数阶 &lt; O(n^2)平方阶 &lt; O(n^3)立方阶 &lt; O(2^n)指数阶</p>
<span id="more"></span>

<h4 id="复杂表达式的化简"><a href="#复杂表达式的化简" class="headerlink" title="复杂表达式的化简"></a>复杂表达式的化简</h4><ul>
<li>去掉加法常数项</li>
<li>去掉常数系数</li>
<li>保留最高项</li>
</ul>
<h4 id="log以什么为底"><a href="#log以什么为底" class="headerlink" title="log以什么为底"></a>log以什么为底</h4><p>说logn的时候，通常忽略了底数的描述。这是因为底可以被化简掉，无论以什么为底，套上O后效果都一样</p>
<h2 id="算法为什么会超时"><a href="#算法为什么会超时" class="headerlink" title="算法为什么会超时"></a>算法为什么会超时</h2><p>程序运行的时间超过了规定的时间，一般OJ（online judge）的超时时间就是1s。如果n的规模已经足够让$O(n)$的算法运行时间超过了1s，就应该考虑log(n)的解法了。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2023/06/23/21-00-00/</url>
    <content><![CDATA[<h2 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h2><p>数组是存放在<strong>连续内存空间</strong>上的<strong>相同类型数据</strong>的集合。正是因为数组在内存空间的地址上是连续的，所以在增删元素时，难免要移动其他元素的地址。</p>
<p><strong>数组的元素是不能删的，只能覆盖。</strong></p>
<p>关于二维数组的内存地址空间的连续性问题，不同的编程语言的内存管理不同。在C++中，二维数组是连续分布的；但在Java中二维数组的每一行头结点的地址是没有规则的。</p>
<span id="more"></span>



<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目的前提是数组为<strong>有序数组</strong>，同时题目还强调数组中<strong>无重复元素</strong>。二分法逻辑比较简单，但有两个容易搞错的点，即</p>
<ul>
<li><p><code>while(left &lt; right)</code>    or    <code>while(left &lt;= right)</code></p>
</li>
<li><p><code> right = middle</code>    or     <code>right = middle - 1</code></p>
</li>
</ul>
<p>主要原因在于<strong>对区间的定义没想清楚</strong>，在二分查找时要遵循<strong>循环不变量</strong>原则，区间的定义就是不变量。</p>
<p>区间的一般定义有两种，左闭右闭和左闭右开。因此衍生了两种主要的写法</p>
<h3 id="左闭右闭"><a href="#左闭右闭" class="headerlink" title="左闭右闭"></a>左闭右闭</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left=<span class="number">0</span>,right=nums.<span class="property">length</span>-<span class="number">1</span>,mid=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        mid=(left + right) &gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid]) left=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right=mid-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="左闭右开"><a href="#左闭右开" class="headerlink" title="左闭右开"></a>左闭右开</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left=<span class="number">0</span>,right=nums.<span class="property">length</span>,mid=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        mid=(left + right) &gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid]) left=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ul>
<li>35</li>
</ul>
<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>题目：给定一个数组nums和一个值val，<strong>原地</strong>移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
</blockquote>
<p>问题乍一看很简单，但涉及到数组的底层理论，即：数组元素不能删除，只能覆盖。</p>
<p>有一些库可以轻易实现该操作，例如vector中的erase操作，此题的本质就是实现erase函数。</p>
<h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> length=nums.<span class="property">length</span>; <span class="comment">// 记录下原数组的大小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;length;)&#123; <span class="comment">// 这里不能笼统的i+1，碰到要删除的元素时，元素整体前移，此时i不用+1</span></span><br><span class="line">        <span class="comment">// 此外，i&lt;length,而不是i&lt;nums.length,因为数组是动态变化的，length的值跟随数组变化</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i]==val)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=i;j&lt;length-<span class="number">1</span>;j++)&#123; <span class="comment">// 覆盖待删除元素 </span></span><br><span class="line">                nums[j]=nums[j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            length--; <span class="comment">// length--和for循环的位置不能变，否则for循环中条件要变</span></span><br><span class="line">        &#125;<span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>也叫快慢指针法，定义快慢指针</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">    <span class="comment">// j指针用于遍历原数组，是快指针</span></span><br><span class="line">    <span class="comment">// i指针用于构成新数组，是慢指针</span></span><br><span class="line">    <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;nums.<span class="property">length</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j]!=val)&#123; <span class="comment">// 快指针指向的元素不是待删元素时，可以插入到新数组</span></span><br><span class="line">            nums[i]=nums[j]; <span class="comment">// 插入到新数组中的i指针位置</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="相关题目-1"><a href="#相关题目-1" class="headerlink" title="相关题目"></a>相关题目</h3><ul>
<li><p>26</p>
</li>
<li><p>283</p>
</li>
</ul>
<h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>题目：给定一个 <strong>非递减</strong>的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减</strong> 排序。</p>
</blockquote>
<p>很容易想到暴力的方法，即先遍历数组，取每个元素的平方，再快排。</p>
<h3 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h3><p>观察数组，由于负数的存在，平方后数组中最大的元素在两边。因此可以在<strong>两边各放指针向中间靠拢</strong>，得到由大到小的元素，数组从后往前构造即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedSquares = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> new_num=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++) nums[i]*=nums[i]; <span class="comment">// 先遍历，得到元素的平方</span></span><br><span class="line">    <span class="keyword">var</span> index=nums.<span class="property">length</span>-<span class="number">1</span>,left=<span class="number">0</span>,right=nums.<span class="property">length</span>-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]&gt;nums[right])&#123;</span><br><span class="line">            new_num[index--]=nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            new_num[index--]=nums[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p><strong>思考：为什么这个算法不能原地工作？</strong></p>
<p>如果原地工作，则index初始指向原数组的最后一位，当right指向的元素大于left指向的元素时，只需要把index–即可；但若反过来，则需要把left指向的元素赋到index位置，此时index指向的元素会被覆盖，数组的元素就不对了，即使把index指向的元素先取出来，等覆盖后left位置空出来再赋给left，这样会导致数组元素排列的无序性。</p>
<h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>题目：给定一个含有n个正整数的数组和一个正整数s，找出该数组中满足其和 ≥ s 的<strong>长度最小的连续</strong>子数组，并返回其长度。如果不存在符 合条件的子数组，返回 0。</p>
</blockquote>
<p>暴力方法：两个循环，一个遍历数组起始位置，一个遍历数组结束位置，组合出所有可能的数组位置从而得到长度。</p>
<p>该问题的一个很自然的思路是从小到大列举数组的长度，看最小能满足条件的长度是多少。但这样就需要列举数组长度个 结果。</p>
<p>刚刚那种思路是<strong>固定窗口大小，改变窗口位置</strong>。那能不能<strong>固定窗口位置，改变窗口大小</strong>呢？</p>
<p>由此想到，可以遍历数组，遍历窗口的<strong>起始位置</strong>，增加窗口大小直到满足条件，由此可得在该位置下最小的窗口大小，在一次完整的遍历之后即可得到全局解。<strong>本质上也是双指针</strong>的方法。</p>
<p>但是如果遍历起始位置，其方法与暴力破解没有区别。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="keyword">function</span>(<span class="params">target, nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum,result=<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 以i为头的子数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        j=i;sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(sum&lt;target&amp;&amp;j&lt;nums.<span class="property">length</span>)&#123;</span><br><span class="line">            sum+=nums[j];j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=target)&#123;</span><br><span class="line">            <span class="keyword">if</span>((j-i)&lt;result) result=j-i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result==<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>) result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>那么再换个思路，如果<strong>遍历窗口的结束位置</strong>呢? 在遍历结束位置时，只有<strong>当条件已经满足才后移起始位置</strong>以得到该结束位置下满足条件的最小解。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="keyword">function</span> (<span class="params">target, nums</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result=<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>; <span class="comment">// 全局最优解</span></span><br><span class="line">  <span class="keyword">var</span> sum=<span class="number">0</span>; <span class="comment">// 当前选中数组的和</span></span><br><span class="line">  <span class="keyword">var</span> start=<span class="number">0</span>; <span class="comment">// 初始起始位置为0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> end=<span class="number">0</span>;end&lt;nums.<span class="property">length</span>;end++)&#123;</span><br><span class="line">    sum+=nums[end]; <span class="comment">// 每次先计算数组和</span></span><br><span class="line">    <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">      sum-=nums[start++]; <span class="comment">// 找到该结束位置下满足条件的最小长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      sum += nums[--start]; <span class="comment">// 出循环时已经不满足条件，重新满足条件</span></span><br><span class="line">      result = <span class="title class_">Math</span>.<span class="title function_">min</span>(result, end - start + <span class="number">1</span>); <span class="comment">// 记录结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>) result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 以上写法还有优化的空间</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  for(var end=0;end&lt;nums.length;end++)&#123;</span></span><br><span class="line"><span class="comment">    sum+=nums[end];</span></span><br><span class="line"><span class="comment">    while(sum&gt;=target)&#123;</span></span><br><span class="line"><span class="comment">      result=Math.min(result,end-start+1);</span></span><br><span class="line"><span class="comment">      sum-=nums[start++];</span></span><br><span class="line"><span class="comment">    &#125; // 出while时不满足&gt;=target条件，直接end++，上面已经记录过结果</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  return result==Number.MAX_VALUE?0:result;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，每个元素在滑动窗后进来和出去各操作一次，复杂度为2×n</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="相关题目-2"><a href="#相关题目-2" class="headerlink" title="相关题目"></a>相关题目</h3><ul>
<li>904</li>
</ul>
<h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>题目：给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
</blockquote>
<p>这道题并没有涉及到什么算法，而是一道模拟题。在循环时一定要遵循<strong>循环不变量</strong>原则，判断边界时确定好左闭右开 ，循环时就用左闭右开</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 左闭右开原则</span></span><br><span class="line"><span class="keyword">var</span> generateMatrix = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> count = n/<span class="number">2</span>;</span><br><span class="line">    count=count&gt;(n&gt;&gt;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>:count; <span class="comment">// 循环次数，n/2上取整</span></span><br><span class="line">    <span class="keyword">var</span> ans=<span class="keyword">new</span> <span class="title class_">Array</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;n;i++) ans[i]=<span class="keyword">new</span> <span class="title class_">Array</span>(n);<span class="comment">// 构造数组</span></span><br><span class="line">    <span class="keyword">var</span> index=<span class="number">1</span>; <span class="comment">// 填入数组中的数字</span></span><br><span class="line">    <span class="keyword">var</span> col=<span class="number">0</span>; <span class="comment">// 列</span></span><br><span class="line">    <span class="keyword">var</span> row=<span class="number">0</span>; <span class="comment">// 行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">1</span>;j&lt;=count;j++)&#123; </span><br><span class="line">        <span class="keyword">var</span> temp=n-(<span class="number">2</span>*j-<span class="number">1</span>); <span class="comment">// 该循环次数下，每条边要填几个数字</span></span><br><span class="line">        <span class="comment">// 四条边的循环填入数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;temp;i++) ans[row][col++]=index++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;temp;i++) ans[row++][col]=index++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;temp;i++) ans[row][col--]=index++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;temp;i++) ans[row--][col]=index++;</span><br><span class="line">        row++;col++;<span class="comment">// 回到下一次循环的正确位置</span></span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="number">0</span>) ans[--row][--col]=index; <span class="comment">// n为奇数时，最后一个数组填不上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 O(n^2)</li>
<li>空间复杂度 O(1)</li>
</ul>
<h3 id="相关题目-3"><a href="#相关题目-3" class="headerlink" title="相关题目"></a>相关题目</h3><ul>
<li>54</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>二分法</li>
<li>双指针法</li>
<li>滑动窗口法</li>
<li>模拟行为</li>
</ul>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png" alt="img"  />]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2023/06/26/09-00-00/</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>不同于数组在内存中的连续分布，链表中的结点<strong>散乱分布</strong>在内存中，通过指针域的指针链接各个结点。</p>
<h3 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">	val;</span><br><span class="line">	next=<span class="literal">null</span>;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">value</span>)&#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">val</span>=value;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">next</span>=<span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表对比数组"><a href="#链表对比数组" class="headerlink" title="链表对比数组"></a>链表对比数组</h3><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195200276.png" alt="链表-链表与数据性能对比"></p>
<span id="more"></span>

<h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><blockquote>
<p>题目：删除链表中等于给定值 val 的所有结点。</p>
</blockquote>
<p>题目本身并不难，可以在链表中直接删除。但是如果头指针也要删除就需要特殊处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElements = <span class="keyword">function</span>(<span class="params">head, val</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>&amp;&amp;head.<span class="property">val</span>==val)&#123; </span><br><span class="line">        <span class="comment">//确保head不为null，否则head.val报错</span></span><br><span class="line">        <span class="comment">// 对需要删除的头结点单独处理</span></span><br><span class="line">        head=head.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span>) <span class="keyword">return</span> head; <span class="comment">// 如果本身为空或全删完了</span></span><br><span class="line">    <span class="keyword">var</span> ret=head;</span><br><span class="line">    <span class="keyword">while</span>(head.<span class="property">next</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.<span class="property">next</span>.<span class="property">val</span>==val) head.<span class="property">next</span>=head.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">else</span> head=head.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<p>有没有对所有结点一视同仁的方法呢？答案是在头结点之前添加一个<strong>虚拟头结点</strong>，这是处理链表常用的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElements = <span class="keyword">function</span>(<span class="params">head, val</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    list.<span class="property">next</span>=head; <span class="comment">// 设立虚头结点</span></span><br><span class="line">    <span class="keyword">var</span> ret=list;</span><br><span class="line">    <span class="keyword">while</span>(ret.<span class="property">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ret.<span class="property">next</span>.<span class="property">val</span>==val)&#123;</span><br><span class="line">            ret.<span class="property">next</span>=ret.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> ret=ret.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><blockquote>
<p>题目：实现链表的增删改查函数</p>
</blockquote>
<p>注意：头指针不能动</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MyLinkedList</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">index</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span> (<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="variable language_">this</span>.<span class="property">size</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> list = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">head</span>);<span class="comment">//虚头结点</span></span><br><span class="line">  <span class="keyword">while</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    list = list.<span class="property">next</span>;</span><br><span class="line">    index--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list.<span class="property">val</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addAtHead</span> = <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> list = <span class="keyword">new</span> <span class="title class_">Node</span>(val, <span class="variable language_">this</span>.<span class="property">head</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">head</span> = list;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addAtTail</span> = <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(val, <span class="literal">null</span>); <span class="comment">// 定义待插入结点</span></span><br><span class="line">  <span class="keyword">var</span> temp = <span class="variable language_">this</span>.<span class="property">head</span>; <span class="comment">// 遍历指针</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">head</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = node; <span class="variable language_">this</span>.<span class="property">size</span>++; <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (temp.<span class="property">next</span> != <span class="literal">null</span>) temp = temp.<span class="property">next</span>;</span><br><span class="line">  temp.<span class="property">next</span> = node;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; index </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addAtIndex</span> = <span class="keyword">function</span> (<span class="params">index, val</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="variable language_">this</span>.<span class="property">size</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(val, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">var</span> list = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">head</span>);</span><br><span class="line">  <span class="keyword">var</span> result=list;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">head</span> == <span class="literal">null</span>) &#123; <span class="variable language_">this</span>.<span class="property">head</span> = node;<span class="variable language_">this</span>.<span class="property">size</span>++; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    index--; list = list.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">  node.<span class="property">next</span> = list.<span class="property">next</span>;</span><br><span class="line">  list.<span class="property">next</span> = node;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">head</span>=result.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">index</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">deleteAtIndex</span> = <span class="keyword">function</span> (<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="variable language_">this</span>.<span class="property">size</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">var</span> temp = index;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span>--;</span><br><span class="line">  <span class="keyword">var</span> list = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">head</span>);</span><br><span class="line">  <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    index--; list = list.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  list.<span class="property">next</span> = list.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">  <span class="keyword">if</span> (temp == <span class="number">0</span>) <span class="variable language_">this</span>.<span class="property">head</span> = list.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><blockquote>
<p>题目：反转一个单链表。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,<span class="literal">null</span>); <span class="comment">// 构造带虚头结点的链表</span></span><br><span class="line">    <span class="keyword">var</span> new_node;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123; <span class="comment">// 遍历原链表</span></span><br><span class="line">        new_node=<span class="keyword">new</span> <span class="title class_">ListNode</span>(head.<span class="property">val</span>,<span class="literal">null</span>);</span><br><span class="line">        new_node.<span class="property">next</span>=ret.<span class="property">next</span>; <span class="comment">// 头插法</span></span><br><span class="line">        ret.<span class="property">next</span>=new_node;</span><br><span class="line">        head=head.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>可以实现原地翻转</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> cur=head;</span><br><span class="line">    <span class="keyword">var</span> pre=<span class="literal">null</span>;<span class="comment">// pre始终在cur左边，即反转以后cur.next=pre</span></span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">        head=head.<span class="property">next</span>;</span><br><span class="line">        cur.<span class="property">next</span>=pre;</span><br><span class="line">        <span class="comment">// 把pre和cur都向右移动一个元素</span></span><br><span class="line">        pre=cur;</span><br><span class="line">        cur=head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre; <span class="comment">// 最终head和cur都为null，pre是反转之后的head</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h3 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverse = <span class="keyword">function</span>(<span class="params">pre,cur</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="literal">null</span>) <span class="keyword">return</span> pre;</span><br><span class="line">    <span class="keyword">var</span> temp=cur.<span class="property">next</span>;</span><br><span class="line">    cur.<span class="property">next</span>=pre;</span><br><span class="line">    pre=cur;</span><br><span class="line">    cur=temp;<span class="comment">//一次反转操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reverse</span>(pre,cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reverse</span>(<span class="literal">null</span>,head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n), 要递归处理链表的每个结点</li>
<li>空间复杂度: O(n), 递归调用了 n 层栈空间</li>
</ul>
<h2 id="交换结点"><a href="#交换结点" class="headerlink" title="交换结点"></a>交换结点</h2><blockquote>
<p>题目：给定一个链表，两两交换其中相邻的结点，并返回交换后的链表。不能只是单纯的改变结点内部的值，而是需要实际的进行结点交换。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> temp=head;</span><br><span class="line">    <span class="keyword">var</span> pre=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">    <span class="title function_">swap</span>(temp,pre);</span><br><span class="line">    <span class="keyword">return</span> pre.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> swap = <span class="keyword">function</span>(<span class="params">cur,pre</span>) &#123; </span><br><span class="line">    <span class="comment">// 交换cur和cur.next,pre.next=cur;</span></span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="literal">null</span>||cur.<span class="property">next</span>==<span class="literal">null</span>) <span class="keyword">return</span>; <span class="comment">// 剩余结点不足两个，无法交换</span></span><br><span class="line">    <span class="keyword">var</span> temp=cur.<span class="property">next</span>;</span><br><span class="line">    <span class="comment">// 交换开始</span></span><br><span class="line">    cur.<span class="property">next</span>=cur.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    temp.<span class="property">next</span>=cur;</span><br><span class="line">    pre.<span class="property">next</span>=temp;</span><br><span class="line">    <span class="comment">// 交换结束</span></span><br><span class="line">    <span class="comment">// 指针扫过已交换的元素，为下次交换准备</span></span><br><span class="line">    pre=cur;</span><br><span class="line">    cur=cur.<span class="property">next</span></span><br><span class="line">    <span class="title function_">swap</span>(cur,pre); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除倒数第N个结点"><a href="#删除倒数第N个结点" class="headerlink" title="删除倒数第N个结点"></a>删除倒数第N个结点</h2><blockquote>
<p>题目：删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 设两个指针，让他们相隔n位，同时后移</span></span><br><span class="line"><span class="comment">// 右边的指针到尾巴时，左边的指针刚好到待删元素的前一位</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span>(<span class="params">head, n</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">    <span class="keyword">var</span> pre=list;</span><br><span class="line">    <span class="keyword">var</span> behind=list;</span><br><span class="line">    <span class="keyword">if</span>(head.<span class="property">next</span>==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        pre=pre.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pre!=<span class="literal">null</span>&amp;&amp;pre.<span class="property">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">        pre=pre.<span class="property">next</span>;</span><br><span class="line">        behind=behind.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    behind.<span class="property">next</span>=behind.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">return</span> list.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><blockquote>
<p>题目：给你两个单链表的头结点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始结点。如果两个链表没有交点，返回 <code>null</code> 。</p>
</blockquote>
<p>很容易想到暴力的方法，遍历headA和headB</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">headA</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">headB</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="keyword">function</span>(<span class="params">headA, headB</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(headA==<span class="literal">null</span>||headB==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(headA!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> head=headB</span><br><span class="line">        <span class="keyword">while</span>(headB!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(headA==headB) <span class="keyword">return</span> headA;</span><br><span class="line">            headB=headB.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        headA=headA.<span class="property">next</span>;</span><br><span class="line">        headB=head; <span class="comment">// headB每次从头开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n^2)</li>
<li>空间复杂度: O(1)</li>
</ul>
<p>换一种思路，如果能让headA和headB在平行位置上一起移动，遍历一遍之后很容易得到结果。而headA和headB在长度上不一样，抓住这个<strong>长度差</strong>，让更长的率先移动直到长度相同即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">headA</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">headB</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="keyword">function</span>(<span class="params">headA, headB</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> lenA=<span class="number">0</span>,lenB=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> tempA=headA,tempB=headB;</span><br><span class="line">    <span class="keyword">while</span>(tempA!=<span class="literal">null</span>)&#123;</span><br><span class="line">        lenA++;</span><br><span class="line">        tempA=tempA.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tempB!=<span class="literal">null</span>)&#123;</span><br><span class="line">        lenB++;</span><br><span class="line">        tempB=tempB.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="comment">// 先得到headA和headB的长度</span></span><br><span class="line">    <span class="keyword">if</span>(lenA&gt;lenB)&#123;</span><br><span class="line">        <span class="keyword">var</span> len=lenA-lenB;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++) headA=headA.<span class="property">next</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lenB&gt;lenA)&#123;</span><br><span class="line">        <span class="keyword">var</span> len=lenB-lenA;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++) headB=headB.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="comment">// 消耗更长的一方的多余长度</span></span><br><span class="line">    <span class="keyword">while</span>(headA!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==headB) <span class="keyword">return</span> headA;</span><br><span class="line">        headA=headA.<span class="property">next</span>;</span><br><span class="line">        headB=headB.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//没有交点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><blockquote>
<p>题目：给定一个链表的头结点  <code>head</code> ，返回链表开始入环的第一个结点。 如果链表无环，则返回 <code>null</code>。</p>
</blockquote>
<p>这道题目其实包含了两个问题：</p>
<ul>
<li>判断有没有环<ul>
<li>环的特点就是无论后移多少次，始终在环里转圈。根据这个特点可以定义快慢指针，快指针每次前进两格，慢指针每次前进一格。若两指针能相遇，则说明有环。</li>
</ul>
</li>
<li>找到环的入口<ul>
<li>设头结点到环的入口结点距离为x，由于快指针每次比慢指针多走1格，因此他们一定在<strong>慢指针没走满一圈环的时候相遇</strong>，设入口结点到相遇结点的距离为y，环中剩下的距离为z</li>
<li><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png" alt="img"></li>
<li>则fast指针走过的结点数&#x3D;slow指针走过的结点数*2：<code>(x + y) * 2 = x + y + n (y + z)</code>（假设fast指针在环内走了n圈遇到慢指针，必定有n&gt;&#x3D;1）</li>
<li>最后是要求x，把x放一边：<code>x = (n - 1) (y + z) + z</code></li>
<li><strong>在头结点定义index1指针，相遇结点定义index2指针，让他们同时同速移动，他们第一次相遇的结点就是环的入口结点</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到相遇结点</span></span><br><span class="line">    <span class="keyword">var</span> fast=head,slow=head;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">null</span>)&#123;</span><br><span class="line">        fast=fast.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// fast为空说明没有环</span></span><br><span class="line">        fast=fast.<span class="property">next</span>; <span class="comment">// fast要连移两步,中间要判断一下是否为空，否则有可能空指针</span></span><br><span class="line">        slow=slow.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(fast==slow)&#123; <span class="comment">// 相遇结点</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fast==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 求结点入口</span></span><br><span class="line">    <span class="keyword">var</span> index1=head,index2=fast;</span><br><span class="line">    <span class="keyword">while</span>(index1!=index2)&#123; <span class="comment">// index1和index2首次相遇的地方就是结点入口</span></span><br><span class="line">        index1=index1.<span class="property">next</span>;</span><br><span class="line">        index2=index2.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)<ul>
<li>快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个index指针走的次数也小于链表长度，总体为走的次数小于 2n</li>
</ul>
</li>
<li>空间复杂度: O(1)</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很多时候对链表头结点的处理要单独考虑，为链表设立<strong>虚拟头结点</strong>可以更方便。</p>
<p>双指针法在链表的应用也很广泛，特别是涉及到距离时。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2023/06/27/12-00-00/</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p> 哈希表也叫散列表，是根据<strong>关键码</strong>的值而<strong>直接进行访问</strong>的数据结构。</p>
</blockquote>
<p>其实数组就是一张哈希表，数组的索引下标就是关键码，通过下标可以直接访问数组中的元素。</p>
<p>一般哈希表用于<strong>快速判断一个元素是否出现在集合中</strong>，是一种空间换时间的策略。</p>
<span id="more"></span>

<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>假如要查询一个名字是否在学校里，只需要初始化把这所学校里学生的名字都存在哈希表里，将学生姓名<strong>映射到哈希表</strong>上就涉及到了hash function ，也就是哈希函数。</p>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423484818.png" alt="哈希表2" style="zoom: 67%;" />



<h3 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h3><p>即不同的名字映射到了同一个索引上。</p>
<h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>发生碰撞的元素都被存储在以该索引为头结点的链表中。</p>
<p>这种方法要选择适当的哈希表的大小，既不会因为哈希表数组空而浪费内存，也不会因为链表长而在查找上浪费时间。</p>
<h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><p>首先要确保tableSize大于dataSize。这种方法就是给产生碰撞的元素再找一个空位放置，根据不同的找空位方法还可细分。</p>
<h3 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h3><ol>
<li><p>数组</p>
</li>
<li><p>set(集合)</p>
</li>
<li><p>map(映射)</p>
</li>
</ol>
<h2 id="字母异位词"><a href="#字母异位词" class="headerlink" title="字母异位词"></a>字母异位词</h2><blockquote>
<p>题目：给定两个字符串 s 和 t ，判断s 和 t 中每个字符出现的次数是否相同。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// charCodeAt()方法，返回字符串第一个字符的Unicode编码值</span></span><br><span class="line"><span class="comment">// for..in可遍历Array, Object对象，且会遍历到新添加的成员属性。(历史遗留)</span></span><br><span class="line"><span class="comment">// for..of可遍历iterable可被迭代的对象(不包括Object)。且只遍历属于对象本身的属性。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">t</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用数组的解法</span></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>!=t.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">var</span> base=<span class="string">&quot;a&quot;</span>.<span class="title function_">charCodeAt</span>();<span class="comment">//获取a的unicode编码值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> s)&#123;</span><br><span class="line">        arr[i.<span class="title function_">charCodeAt</span>()-base]++;<span class="comment">//统计s串中各字符的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> t)&#123;</span><br><span class="line">        arr[i.<span class="title function_">charCodeAt</span>()-base]--;</span><br><span class="line">        <span class="keyword">if</span>(arr[i.<span class="title function_">charCodeAt</span>()-base]&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用map的解法</span></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>!=t.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> s)&#123;</span><br><span class="line">        <span class="keyword">var</span> temp=arr.<span class="title function_">get</span>(i)||<span class="number">0</span>;</span><br><span class="line">        arr.<span class="title function_">set</span>(i,temp+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!arr.<span class="title function_">get</span>(i)) <span class="comment">// 这里包含了两种情况，一是为0，二是undefined </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        arr.<span class="title function_">set</span>(i, arr.<span class="title function_">get</span>(i)-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><h2 id="数组交集"><a href="#数组交集" class="headerlink" title="数组交集"></a>数组交集</h2><blockquote>
<p>题目：给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回它们的交集 。输出结果中的每个元素一定是唯一的。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersection = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> num1=<span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">var</span> ret=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> nums1)&#123;</span><br><span class="line">        num1.<span class="title function_">add</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> nums2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1.<span class="title function_">has</span>(i)&amp;&amp;!ret.<span class="title function_">includes</span>(i)) ret.<span class="title function_">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="相关题目-1"><a href="#相关题目-1" class="headerlink" title="相关题目"></a>相关题目</h3>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>js基础</title>
    <url>/2023/06/27/20-56-15/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JS &#x3D; ECMAScript(语法) + DOM(页面文档对象模型) + BOM(浏览器对象模型)  </p>
<ul>
<li>DOM和BOM都是Web API</li>
</ul>
<p>文档：</p>
<p><code>https://developer.mozilla.org/zh-CN</code></p>
<p><code>https://developer.mozilla.org/zh-CN/docs/web/javascript</code></p>
<span id="more"></span>

<h3 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h3><p>JavaScript 程序不能独立运行，它需要被嵌入 HTML 中，然后浏览器才能执行 JavaScript 代码。通过 <code>script</code> 标签将 JavaScript 代码引入到 HTML 中，有两种方式：</p>
<h4 id="内部方式"><a href="#内部方式" class="headerlink" title="内部方式"></a>内部方式</h4><p>通过 <code>script</code> 标签包裹 JavaScript 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JavaScript 基础 - 引入方式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--通常写到文件底部，因为浏览器是按照代码顺序加载的，如果先加载的js涉及到修改其下方的html，可能会失败--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&#x27;嗨，欢迎来传智播学习前端技术！&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// js一句代码结束后可以不写;</span></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="外部形式"><a href="#外部形式" class="headerlink" title="外部形式"></a>外部形式</h4><p>一般将 JavaScript 代码写在独立的以 .js 结尾的文件中，然后通过 <code>script</code> 标签的 <code>src</code> 属性引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo.js</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JavaScript 基础 - 引入方式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;demo.js&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  	<span class="comment">// 这里的代码会被忽略</span></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="输入输出语句"><a href="#输入输出语句" class="headerlink" title="输入输出语句"></a>输入输出语句</h3><table>
<thead>
<tr>
<th>方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>alert(msg)</td>
<td align="left">浏览器弹出警示框</td>
</tr>
<tr>
<td>console.log(msg)</td>
<td align="left">浏览器控制台打印输出信息</td>
</tr>
<tr>
<td>prompt(info)</td>
<td align="left">浏览器弹出输入框，用户可以输入</td>
</tr>
<tr>
<td>document.write()</td>
<td align="left">向html文档中输出内容，可以识别标签</td>
</tr>
</tbody></table>
<p>注：<code>alert</code>和<code>prompt</code>会跳过页面渲染先被执行。</p>
<h3 id="let和var"><a href="#let和var" class="headerlink" title="let和var"></a>let和var</h3><p>JavaScript 使用专门的关键字 <code>let</code> 和 <code>var</code> 来声明（定义）变量，在使用时需要注意一些细节：</p>
<p>以下是使用 <code>let</code> 时的注意事项：</p>
<ol>
<li>允许声明时赋值</li>
<li><strong>不允许重复声明</strong></li>
<li>允许同时声明多个变量并赋值</li>
<li>JavaScript 中内置的一些关键字不能被当做变量名</li>
</ol>
<p><code>var</code>和<code>let</code>的区别在于</p>
<ul>
<li><strong>var允许重复声明</strong>。</li>
<li>可以先使用再声明</li>
<li>变量提升，是全局变量，没有块级作用域</li>
</ul>
<p>因此 <code>let</code> 相较 <code>var</code> 更严谨，推荐使用 <code>let</code>。</p>
<h3 id="变量名命名规则"><a href="#变量名命名规则" class="headerlink" title="变量名命名规则"></a>变量名命名规则</h3><p>关于变量的名称（标识符）有一系列的规则需要遵守：</p>
<ol>
<li>只能是字母、数字、下划线、$，且不能能数字开头</li>
<li>字母区分大小写，如 Age 和 age 是不同的变量</li>
<li>JavaScript 内部已占用于单词（关键字或保留字）不允许使用</li>
<li>尽量保证变量具有一定的语义，见字知义</li>
</ol>
<p>注：所谓关键字是指 JavaScript 内部使用的词语，如 <code>let</code> 和<code>var</code>，保留字是指 JavaScript 内部目前没有使用的词语，但是将来可能会使用词语。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>概念：使用 <code>const</code> 声明的变量称为“常量”。</p>
<p>使用场景：当某个变量永远不会改变的时候，就可以使用<code>const</code>来声明，而不是let。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意： 常量不允许重新赋值,声明的时候必须赋值（初始化）</p>
</blockquote>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>js是<strong>弱数据类型</strong>的语言，主要有五大基本数据类型，可以通过 <code>typeof</code> 关键字检测数据类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typeof有两种使用方法</span></span><br><span class="line"><span class="comment">// 作为运算符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 函数形式</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(<span class="literal">null</span>))</span><br></pre></td></tr></table></figure>



<h4 id="number类型"><a href="#number类型" class="headerlink" title="number类型"></a>number类型</h4><p>包括整数、小数、正数、负数。在number中有一个特殊的值，叫做<code>NaN</code>，代表计算错误，任何对NaN的操作都会返回NaN。</p>
<h4 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h4><p>通过单引号 、双引号或反引号包裹的数据都叫字符串，单引号和双引号没有本质上的区别，推荐使用单引号。</p>
<p>字符串可以拼接，但比较麻烦。</p>
<p>注意事项：</p>
<ol>
<li>无论单引号或是双引号必须成对使用</li>
<li>单引号&#x2F;双引号<strong>可以互相嵌套</strong>，但是不能自已嵌套自已</li>
<li>必要时可以使用转义符 <code>\</code>，输出单引号或双引号</li>
</ol>
<h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age=<span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我&#x27;</span>+age+<span class="string">&#x27;岁&#x27;</span>) <span class="comment">// 字符串拼接</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我<span class="subst">$&#123;age&#125;</span>岁了`</span>) <span class="comment">// 模板字符串，必须用反引号</span></span><br></pre></td></tr></table></figure>



<h4 id="boolean类型"><a href="#boolean类型" class="headerlink" title="boolean类型"></a>boolean类型</h4><h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><p>未定义是比较特殊的类型，只有一个值 undefined。变量未初始化时，其默认值为 undefined。因为js是弱数据类型的语言，未经初始化，解释器也不知道变量是何类型</p>
<p>一般很少【直接】为某个变量赋值为 undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只声明了变量，并末赋值</span></span><br><span class="line"><span class="keyword">let</span> tmp;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="keyword">typeof</span> tmp) <span class="comment">// 结果为 undefined</span></span><br></pre></td></tr></table></figure>

<p>通常用于检查一个数据是否被传递过来</p>
<h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>null表示赋值了，但是内容为空。可以把null作为<strong>尚未创建的对象</strong></p>
<p>如果一个变量里确定存放的是对象，但该对象还没准备好，就可以先放个null</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> data); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>+<span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span>+<span class="number">1</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>



<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>某些运算符被执行时，<strong>系统内部自动将数据类型进行转换</strong>，这种转换称为隐式转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">13</span> <span class="comment">// 数值</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="string">&#x27;2&#x27;</span> <span class="comment">// 字符串</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num + num2) <span class="comment">//字符串拼接 132</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num - num2) <span class="comment">//数字加减 11</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num * num2) <span class="comment">// 26</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="string">&#x27;12&#x27;</span>) <span class="comment">// 转为数字型</span></span><br></pre></td></tr></table></figure>

<p>转换类型不明显</p>
<h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><p>编写程序时过度依靠系统内部的隐式转换是不严禁的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显式将字符串 12 转换成数值 12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&#x27;12&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;12.2pp&#x27;</span>)) <span class="comment">//12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;a12a&#x27;</span>)) <span class="comment">//NaN 只能取开头的数字</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;12.2pp&#x27;</span>)) <span class="comment">//12.2</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
