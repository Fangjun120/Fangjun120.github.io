<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/04/07/20-54-53/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>算法性能</title>
    <url>/2023/06/23/20-56-15/</url>
    <content><![CDATA[<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h4 id="什么是时间复杂度"><a href="#什么是时间复杂度" class="headerlink" title="什么是时间复杂度"></a>什么是时间复杂度</h4><p>时间复杂度是一个函数，它定性描述该算法的运行时间。</p>
<p>假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示，随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。</p>
<p><strong>大O用来表示上界</strong>，但代表的是一般情况，而不是严格的上界。就像快排的时间复杂度是O(nlogn)，但最坏情况下应该是O(n^2)。<strong>大O是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量</strong>。</p>
<p>所以我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大。</p>
<p>O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(nlogn)线性对数阶 &lt; O(n^2)平方阶 &lt; O(n^3)立方阶 &lt; O(2^n)指数阶</p>
<span id="more"></span>

<h4 id="复杂表达式的化简"><a href="#复杂表达式的化简" class="headerlink" title="复杂表达式的化简"></a>复杂表达式的化简</h4><ul>
<li>去掉加法常数项</li>
<li>去掉常数系数</li>
<li>保留最高项</li>
</ul>
<h4 id="log以什么为底"><a href="#log以什么为底" class="headerlink" title="log以什么为底"></a>log以什么为底</h4><p>说logn的时候，通常忽略了底数的描述。这是因为底可以被化简掉，无论以什么为底，套上O后效果都一样</p>
<h2 id="算法为什么会超时"><a href="#算法为什么会超时" class="headerlink" title="算法为什么会超时"></a>算法为什么会超时</h2><p>程序运行的时间超过了规定的时间，一般OJ（online judge）的超时时间就是1s。如果n的规模已经足够让$O(n)$的算法运行时间超过了1s，就应该考虑log(n)的解法了。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2023/06/23/21-00-00/</url>
    <content><![CDATA[<h2 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h2><p>数组是存放在<strong>连续内存空间</strong>上的<strong>相同类型数据</strong>的集合。正是因为数组在内存空间的地址上是连续的，所以在增删元素时，难免要移动其他元素的地址。</p>
<p><strong>数组的元素是不能删的，只能覆盖。</strong></p>
<p>关于二维数组的内存地址空间的连续性问题，不同的编程语言的内存管理不同。在C++中，二维数组是连续分布的；但在Java中二维数组的每一行头结点的地址是没有规则的。</p>
<span id="more"></span>



<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目的前提是数组为<strong>有序数组</strong>，同时题目还强调数组中<strong>无重复元素</strong>。二分法逻辑比较简单，但有两个容易搞错的点，即</p>
<ul>
<li><p><code>while(left &lt; right)</code>    or    <code>while(left &lt;= right)</code></p>
</li>
<li><p><code> right = middle</code>    or     <code>right = middle - 1</code></p>
</li>
</ul>
<p>主要原因在于<strong>对区间的定义没想清楚</strong>，在二分查找时要遵循<strong>循环不变量</strong>原则，区间的定义就是不变量。</p>
<p>区间的一般定义有两种，左闭右闭和左闭右开。因此衍生了两种主要的写法</p>
<h3 id="左闭右闭"><a href="#左闭右闭" class="headerlink" title="左闭右闭"></a>左闭右闭</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left=<span class="number">0</span>,right=nums.<span class="property">length</span>-<span class="number">1</span>,mid=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        mid=(left + right) &gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid]) left=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right=mid-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="左闭右开"><a href="#左闭右开" class="headerlink" title="左闭右开"></a>左闭右开</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> left=<span class="number">0</span>,right=nums.<span class="property">length</span>,mid=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        mid=(left + right) &gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==nums[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid]) left=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(logn)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ul>
<li>35</li>
</ul>
<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>题目：给定一个数组nums和一个值val，<strong>原地</strong>移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
</blockquote>
<p>问题乍一看很简单，但涉及到数组的底层理论，即：数组元素不能删除，只能覆盖。</p>
<p>有一些库可以轻易实现该操作，例如vector中的erase操作，此题的本质就是实现erase函数。</p>
<h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> length=nums.<span class="property">length</span>; <span class="comment">// 记录下原数组的大小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;length;)&#123; <span class="comment">// 这里不能笼统的i+1，碰到要删除的元素时，元素整体前移，此时i不用+1</span></span><br><span class="line">        <span class="comment">// 此外，i&lt;length,而不是i&lt;nums.length,因为数组是动态变化的，length的值跟随数组变化</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i]==val)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=i;j&lt;length-<span class="number">1</span>;j++)&#123; <span class="comment">// 覆盖待删除元素 </span></span><br><span class="line">                nums[j]=nums[j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            length--; <span class="comment">// length--和for循环的位置不能变，否则for循环中条件要变</span></span><br><span class="line">        &#125;<span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>也叫快慢指针法，定义快慢指针</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向更新 新数组下标的位置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">    <span class="comment">// j指针用于遍历原数组，是快指针</span></span><br><span class="line">    <span class="comment">// i指针用于构成新数组，是慢指针</span></span><br><span class="line">    <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;nums.<span class="property">length</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j]!=val)&#123; <span class="comment">// 快指针指向的元素不是待删元素时，可以插入到新数组</span></span><br><span class="line">            nums[i]=nums[j]; <span class="comment">// 插入到新数组中的i指针位置</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="相关题目-1"><a href="#相关题目-1" class="headerlink" title="相关题目"></a>相关题目</h3><ul>
<li><p>26</p>
</li>
<li><p>283</p>
</li>
</ul>
<h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>题目：给定一个 <strong>非递减</strong>的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减</strong> 排序。</p>
</blockquote>
<p>很容易想到暴力的方法，即先遍历数组，取每个元素的平方，再快排。</p>
<h3 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h3><p>观察数组，由于负数的存在，平方后数组中最大的元素在两边。因此可以在<strong>两边各放指针向中间靠拢</strong>，得到由大到小的元素，数组从后往前构造即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedSquares = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> new_num=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++) nums[i]*=nums[i]; <span class="comment">// 先遍历，得到元素的平方</span></span><br><span class="line">    <span class="keyword">var</span> index=nums.<span class="property">length</span>-<span class="number">1</span>,left=<span class="number">0</span>,right=nums.<span class="property">length</span>-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]&gt;nums[right])&#123;</span><br><span class="line">            new_num[index--]=nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            new_num[index--]=nums[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p><strong>思考：为什么这个算法不能原地工作？</strong></p>
<p>如果原地工作，则index初始指向原数组的最后一位，当right指向的元素大于left指向的元素时，只需要把index–即可；但若反过来，则需要把left指向的元素赋到index位置，此时index指向的元素会被覆盖，数组的元素就不对了，即使把index指向的元素先取出来，等覆盖后left位置空出来再赋给left，这样会导致数组元素排列的无序性。</p>
<h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>题目：给定一个含有n个正整数的数组和一个正整数s，找出该数组中满足其和 ≥ s 的<strong>长度最小的连续</strong>子数组，并返回其长度。如果不存在符 合条件的子数组，返回 0。</p>
</blockquote>
<p>暴力方法：两个循环，一个遍历数组起始位置，一个遍历数组结束位置，组合出所有可能的数组位置从而得到长度。</p>
<p>该问题的一个很自然的思路是从小到大列举数组的长度，看最小能满足条件的长度是多少。但这样就需要列举数组长度个 结果。</p>
<p>刚刚那种思路是<strong>固定窗口大小，改变窗口位置</strong>。那能不能<strong>固定窗口位置，改变窗口大小</strong>呢？</p>
<p>由此想到，可以遍历数组，遍历窗口的<strong>起始位置</strong>，增加窗口大小直到满足条件，由此可得在该位置下最小的窗口大小，在一次完整的遍历之后即可得到全局解。<strong>本质上也是双指针</strong>的方法。</p>
<p>但是如果遍历起始位置，其方法与暴力破解没有区别。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="keyword">function</span>(<span class="params">target, nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum,result=<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 以i为头的子数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        j=i;sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(sum&lt;target&amp;&amp;j&lt;nums.<span class="property">length</span>)&#123;</span><br><span class="line">            sum+=nums[j];j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=target)&#123;</span><br><span class="line">            <span class="keyword">if</span>((j-i)&lt;result) result=j-i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result==<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>) result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>那么再换个思路，如果<strong>遍历窗口的结束位置</strong>呢? 在遍历结束位置时，只有<strong>当条件已经满足才后移起始位置</strong>以得到该结束位置下满足条件的最小解。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="keyword">function</span> (<span class="params">target, nums</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result=<span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>; <span class="comment">// 全局最优解</span></span><br><span class="line">  <span class="keyword">var</span> sum=<span class="number">0</span>; <span class="comment">// 当前选中数组的和</span></span><br><span class="line">  <span class="keyword">var</span> start=<span class="number">0</span>; <span class="comment">// 初始起始位置为0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> end=<span class="number">0</span>;end&lt;nums.<span class="property">length</span>;end++)&#123;</span><br><span class="line">    sum+=nums[end]; <span class="comment">// 每次先计算数组和</span></span><br><span class="line">    <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">      sum-=nums[start++]; <span class="comment">// 找到该结束位置下满足条件的最小长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      sum += nums[--start]; <span class="comment">// 出循环时已经不满足条件，重新满足条件</span></span><br><span class="line">      result = <span class="title class_">Math</span>.<span class="title function_">min</span>(result, end - start + <span class="number">1</span>); <span class="comment">// 记录结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>) result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 以上写法还有优化的空间</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  for(var end=0;end&lt;nums.length;end++)&#123;</span></span><br><span class="line"><span class="comment">    sum+=nums[end];</span></span><br><span class="line"><span class="comment">    while(sum&gt;=target)&#123;</span></span><br><span class="line"><span class="comment">      result=Math.min(result,end-start+1);</span></span><br><span class="line"><span class="comment">      sum-=nums[start++];</span></span><br><span class="line"><span class="comment">    &#125; // 出while时不满足&gt;=target条件，直接end++，上面已经记录过结果</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  return result==Number.MAX_VALUE?0:result;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)，每个元素在滑动窗后进来和出去各操作一次，复杂度为2×n</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="相关题目-2"><a href="#相关题目-2" class="headerlink" title="相关题目"></a>相关题目</h3><ul>
<li>904</li>
</ul>
<h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>题目：给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
</blockquote>
<p>这道题并没有涉及到什么算法，而是一道模拟题。在循环时一定要遵循<strong>循环不变量</strong>原则，判断边界时确定好左闭右开 ，循环时就用左闭右开</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 左闭右开原则</span></span><br><span class="line"><span class="keyword">var</span> generateMatrix = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> count = n/<span class="number">2</span>;</span><br><span class="line">    count=count&gt;(n&gt;&gt;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>)+<span class="number">1</span>:count; <span class="comment">// 循环次数，n/2上取整</span></span><br><span class="line">    <span class="keyword">var</span> ans=<span class="keyword">new</span> <span class="title class_">Array</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;n;i++) ans[i]=<span class="keyword">new</span> <span class="title class_">Array</span>(n);<span class="comment">// 构造数组</span></span><br><span class="line">    <span class="keyword">var</span> index=<span class="number">1</span>; <span class="comment">// 填入数组中的数字</span></span><br><span class="line">    <span class="keyword">var</span> col=<span class="number">0</span>; <span class="comment">// 列</span></span><br><span class="line">    <span class="keyword">var</span> row=<span class="number">0</span>; <span class="comment">// 行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">1</span>;j&lt;=count;j++)&#123; </span><br><span class="line">        <span class="keyword">var</span> temp=n-(<span class="number">2</span>*j-<span class="number">1</span>); <span class="comment">// 该循环次数下，每条边要填几个数字</span></span><br><span class="line">        <span class="comment">// 四条边的循环填入数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;temp;i++) ans[row][col++]=index++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;temp;i++) ans[row++][col]=index++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;temp;i++) ans[row][col--]=index++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;temp;i++) ans[row--][col]=index++;</span><br><span class="line">        row++;col++;<span class="comment">// 回到下一次循环的正确位置</span></span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="number">0</span>) ans[--row][--col]=index; <span class="comment">// n为奇数时，最后一个数组填不上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 O(n^2)</li>
<li>空间复杂度 O(1)</li>
</ul>
<h3 id="相关题目-3"><a href="#相关题目-3" class="headerlink" title="相关题目"></a>相关题目</h3><ul>
<li>54</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>二分法</li>
<li>双指针法</li>
<li>滑动窗口法</li>
<li>模拟行为</li>
</ul>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png" alt="img"  />]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2023/06/26/09-00-00/</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>不同于数组在内存中的连续分布，链表中的结点<strong>散乱分布</strong>在内存中，通过指针域的指针链接各个结点。</p>
<h3 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">	val;</span><br><span class="line">	next=<span class="literal">null</span>;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">value</span>)&#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">val</span>=value;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">next</span>=<span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表对比数组"><a href="#链表对比数组" class="headerlink" title="链表对比数组"></a>链表对比数组</h3><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195200276.png" alt="链表-链表与数据性能对比"></p>
<span id="more"></span>

<h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><blockquote>
<p>题目：删除链表中等于给定值 val 的所有结点。</p>
</blockquote>
<p>题目本身并不难，可以在链表中直接删除。但是如果头指针也要删除就需要特殊处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElements = <span class="keyword">function</span>(<span class="params">head, val</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>&amp;&amp;head.<span class="property">val</span>==val)&#123; </span><br><span class="line">        <span class="comment">//确保head不为null，否则head.val报错</span></span><br><span class="line">        <span class="comment">// 对需要删除的头结点单独处理</span></span><br><span class="line">        head=head.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span>) <span class="keyword">return</span> head; <span class="comment">// 如果本身为空或全删完了</span></span><br><span class="line">    <span class="keyword">var</span> ret=head;</span><br><span class="line">    <span class="keyword">while</span>(head.<span class="property">next</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.<span class="property">next</span>.<span class="property">val</span>==val) head.<span class="property">next</span>=head.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">else</span> head=head.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<p>有没有对所有结点一视同仁的方法呢？答案是在头结点之前添加一个<strong>虚拟头结点</strong>，这是处理链表常用的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElements = <span class="keyword">function</span>(<span class="params">head, val</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    list.<span class="property">next</span>=head; <span class="comment">// 设立虚头结点</span></span><br><span class="line">    <span class="keyword">var</span> ret=list;</span><br><span class="line">    <span class="keyword">while</span>(ret.<span class="property">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ret.<span class="property">next</span>.<span class="property">val</span>==val)&#123;</span><br><span class="line">            ret.<span class="property">next</span>=ret.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> ret=ret.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><blockquote>
<p>题目：实现链表的增删改查函数</p>
</blockquote>
<p>注意：头指针不能动</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">val, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MyLinkedList</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">index</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span> (<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="variable language_">this</span>.<span class="property">size</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> list = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">head</span>);<span class="comment">//虚头结点</span></span><br><span class="line">  <span class="keyword">while</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    list = list.<span class="property">next</span>;</span><br><span class="line">    index--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list.<span class="property">val</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addAtHead</span> = <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> list = <span class="keyword">new</span> <span class="title class_">Node</span>(val, <span class="variable language_">this</span>.<span class="property">head</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">head</span> = list;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addAtTail</span> = <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(val, <span class="literal">null</span>); <span class="comment">// 定义待插入结点</span></span><br><span class="line">  <span class="keyword">var</span> temp = <span class="variable language_">this</span>.<span class="property">head</span>; <span class="comment">// 遍历指针</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">head</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = node; <span class="variable language_">this</span>.<span class="property">size</span>++; <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (temp.<span class="property">next</span> != <span class="literal">null</span>) temp = temp.<span class="property">next</span>;</span><br><span class="line">  temp.<span class="property">next</span> = node;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; index </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addAtIndex</span> = <span class="keyword">function</span> (<span class="params">index, val</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="variable language_">this</span>.<span class="property">size</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(val, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">var</span> list = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">head</span>);</span><br><span class="line">  <span class="keyword">var</span> result=list;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">head</span> == <span class="literal">null</span>) &#123; <span class="variable language_">this</span>.<span class="property">head</span> = node;<span class="variable language_">this</span>.<span class="property">size</span>++; <span class="keyword">return</span>; &#125;</span><br><span class="line">  <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    index--; list = list.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">  node.<span class="property">next</span> = list.<span class="property">next</span>;</span><br><span class="line">  list.<span class="property">next</span> = node;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">head</span>=result.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">index</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyLinkedList</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">deleteAtIndex</span> = <span class="keyword">function</span> (<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="variable language_">this</span>.<span class="property">size</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">var</span> temp = index;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span>--;</span><br><span class="line">  <span class="keyword">var</span> list = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">head</span>);</span><br><span class="line">  <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    index--; list = list.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  list.<span class="property">next</span> = list.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">  <span class="keyword">if</span> (temp == <span class="number">0</span>) <span class="variable language_">this</span>.<span class="property">head</span> = list.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><blockquote>
<p>题目：反转一个单链表。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,<span class="literal">null</span>); <span class="comment">// 构造带虚头结点的链表</span></span><br><span class="line">    <span class="keyword">var</span> new_node;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123; <span class="comment">// 遍历原链表</span></span><br><span class="line">        new_node=<span class="keyword">new</span> <span class="title class_">ListNode</span>(head.<span class="property">val</span>,<span class="literal">null</span>);</span><br><span class="line">        new_node.<span class="property">next</span>=ret.<span class="property">next</span>; <span class="comment">// 头插法</span></span><br><span class="line">        ret.<span class="property">next</span>=new_node;</span><br><span class="line">        head=head.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(n)</li>
</ul>
<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>可以实现原地翻转</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> cur=head;</span><br><span class="line">    <span class="keyword">var</span> pre=<span class="literal">null</span>;<span class="comment">// pre始终在cur左边，即反转以后cur.next=pre</span></span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">        head=head.<span class="property">next</span>;</span><br><span class="line">        cur.<span class="property">next</span>=pre;</span><br><span class="line">        <span class="comment">// 把pre和cur都向右移动一个元素</span></span><br><span class="line">        pre=cur;</span><br><span class="line">        cur=head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre; <span class="comment">// 最终head和cur都为null，pre是反转之后的head</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h3 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverse = <span class="keyword">function</span>(<span class="params">pre,cur</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="literal">null</span>) <span class="keyword">return</span> pre;</span><br><span class="line">    <span class="keyword">var</span> temp=cur.<span class="property">next</span>;</span><br><span class="line">    cur.<span class="property">next</span>=pre;</span><br><span class="line">    pre=cur;</span><br><span class="line">    cur=temp;<span class="comment">//一次反转操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reverse</span>(pre,cur);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="keyword">function</span>(<span class="params">head</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reverse</span>(<span class="literal">null</span>,head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n), 要递归处理链表的每个结点</li>
<li>空间复杂度: O(n), 递归调用了 n 层栈空间</li>
</ul>
<h2 id="交换结点"><a href="#交换结点" class="headerlink" title="交换结点"></a>交换结点</h2><blockquote>
<p>题目：给定一个链表，两两交换其中相邻的结点，并返回交换后的链表。不能只是单纯的改变结点内部的值，而是需要实际的进行结点交换。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> swapPairs = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> temp=head;</span><br><span class="line">    <span class="keyword">var</span> pre=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">    <span class="title function_">swap</span>(temp,pre);</span><br><span class="line">    <span class="keyword">return</span> pre.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> swap = <span class="keyword">function</span>(<span class="params">cur,pre</span>) &#123; </span><br><span class="line">    <span class="comment">// 交换cur和cur.next,pre.next=cur;</span></span><br><span class="line">    <span class="keyword">if</span>(cur==<span class="literal">null</span>||cur.<span class="property">next</span>==<span class="literal">null</span>) <span class="keyword">return</span>; <span class="comment">// 剩余结点不足两个，无法交换</span></span><br><span class="line">    <span class="keyword">var</span> temp=cur.<span class="property">next</span>;</span><br><span class="line">    <span class="comment">// 交换开始</span></span><br><span class="line">    cur.<span class="property">next</span>=cur.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    temp.<span class="property">next</span>=cur;</span><br><span class="line">    pre.<span class="property">next</span>=temp;</span><br><span class="line">    <span class="comment">// 交换结束</span></span><br><span class="line">    <span class="comment">// 指针扫过已交换的元素，为下次交换准备</span></span><br><span class="line">    pre=cur;</span><br><span class="line">    cur=cur.<span class="property">next</span></span><br><span class="line">    <span class="title function_">swap</span>(cur,pre); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除倒数第N个结点"><a href="#删除倒数第N个结点" class="headerlink" title="删除倒数第N个结点"></a>删除倒数第N个结点</h2><blockquote>
<p>题目：删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 设两个指针，让他们相隔n位，同时后移</span></span><br><span class="line"><span class="comment">// 右边的指针到尾巴时，左边的指针刚好到待删元素的前一位</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="keyword">function</span>(<span class="params">head, n</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">    <span class="keyword">var</span> pre=list;</span><br><span class="line">    <span class="keyword">var</span> behind=list;</span><br><span class="line">    <span class="keyword">if</span>(head.<span class="property">next</span>==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        pre=pre.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pre!=<span class="literal">null</span>&amp;&amp;pre.<span class="property">next</span>!=<span class="literal">null</span>)&#123;</span><br><span class="line">        pre=pre.<span class="property">next</span>;</span><br><span class="line">        behind=behind.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    behind.<span class="property">next</span>=behind.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">return</span> list.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><blockquote>
<p>题目：给你两个单链表的头结点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始结点。如果两个链表没有交点，返回 <code>null</code> 。</p>
</blockquote>
<p>很容易想到暴力的方法，遍历headA和headB</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">headA</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">headB</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="keyword">function</span>(<span class="params">headA, headB</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(headA==<span class="literal">null</span>||headB==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(headA!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> head=headB</span><br><span class="line">        <span class="keyword">while</span>(headB!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(headA==headB) <span class="keyword">return</span> headA;</span><br><span class="line">            headB=headB.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        headA=headA.<span class="property">next</span>;</span><br><span class="line">        headB=head; <span class="comment">// headB每次从头开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n^2)</li>
<li>空间复杂度: O(1)</li>
</ul>
<p>换一种思路，如果能让headA和headB在平行位置上一起移动，遍历一遍之后很容易得到结果。而headA和headB在长度上不一样，抓住这个<strong>长度差</strong>，让更长的率先移动直到长度相同即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">headA</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">headB</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="keyword">function</span>(<span class="params">headA, headB</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> lenA=<span class="number">0</span>,lenB=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> tempA=headA,tempB=headB;</span><br><span class="line">    <span class="keyword">while</span>(tempA!=<span class="literal">null</span>)&#123;</span><br><span class="line">        lenA++;</span><br><span class="line">        tempA=tempA.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tempB!=<span class="literal">null</span>)&#123;</span><br><span class="line">        lenB++;</span><br><span class="line">        tempB=tempB.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="comment">// 先得到headA和headB的长度</span></span><br><span class="line">    <span class="keyword">if</span>(lenA&gt;lenB)&#123;</span><br><span class="line">        <span class="keyword">var</span> len=lenA-lenB;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++) headA=headA.<span class="property">next</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lenB&gt;lenA)&#123;</span><br><span class="line">        <span class="keyword">var</span> len=lenB-lenA;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++) headB=headB.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="comment">// 消耗更长的一方的多余长度</span></span><br><span class="line">    <span class="keyword">while</span>(headA!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==headB) <span class="keyword">return</span> headA;</span><br><span class="line">        headA=headA.<span class="property">next</span>;</span><br><span class="line">        headB=headB.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//没有交点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><blockquote>
<p>题目：给定一个链表的头结点  <code>head</code> ，返回链表开始入环的第一个结点。 如果链表无环，则返回 <code>null</code>。</p>
</blockquote>
<p>这道题目其实包含了两个问题：</p>
<ul>
<li>判断有没有环<ul>
<li>环的特点就是无论后移多少次，始终在环里转圈。根据这个特点可以定义快慢指针，快指针每次前进两格，慢指针每次前进一格。若两指针能相遇，则说明有环。</li>
</ul>
</li>
<li>找到环的入口<ul>
<li>设头结点到环的入口结点距离为x，由于快指针每次比慢指针多走1格，因此他们一定在<strong>慢指针没走满一圈环的时候相遇</strong>，设入口结点到相遇结点的距离为y，环中剩下的距离为z</li>
<li><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png" alt="img"></li>
<li>则fast指针走过的结点数&#x3D;slow指针走过的结点数*2：<code>(x + y) * 2 = x + y + n (y + z)</code>（假设fast指针在环内走了n圈遇到慢指针，必定有n&gt;&#x3D;1）</li>
<li>最后是要求x，把x放一边：<code>x = (n - 1) (y + z) + z</code></li>
<li><strong>在头结点定义index1指针，相遇结点定义index2指针，让他们同时同速移动，他们第一次相遇的结点就是环的入口结点</strong>。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到相遇结点</span></span><br><span class="line">    <span class="keyword">var</span> fast=head,slow=head;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">null</span>)&#123;</span><br><span class="line">        fast=fast.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// fast为空说明没有环</span></span><br><span class="line">        fast=fast.<span class="property">next</span>; <span class="comment">// fast要连移两步,中间要判断一下是否为空，否则有可能空指针</span></span><br><span class="line">        slow=slow.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(fast==slow)&#123; <span class="comment">// 相遇结点</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fast==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 求结点入口</span></span><br><span class="line">    <span class="keyword">var</span> index1=head,index2=fast;</span><br><span class="line">    <span class="keyword">while</span>(index1!=index2)&#123; <span class="comment">// index1和index2首次相遇的地方就是结点入口</span></span><br><span class="line">        index1=index1.<span class="property">next</span>;</span><br><span class="line">        index2=index2.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n)<ul>
<li>快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个index指针走的次数也小于链表长度，总体为走的次数小于 2n</li>
</ul>
</li>
<li>空间复杂度: O(1)</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很多时候对链表头结点的处理要单独考虑，为链表设立<strong>虚拟头结点</strong>可以更方便。</p>
<p>双指针法在链表的应用也很广泛，特别是涉及到距离时。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2023/06/27/12-00-00/</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p> 哈希表也叫散列表，是根据<strong>关键码</strong>的值而<strong>直接进行访问</strong>的数据结构。</p>
</blockquote>
<p>其实数组就是一张哈希表，数组的索引下标就是关键码，通过下标可以直接访问数组中的元素。</p>
<p>一般哈希表用于<strong>快速判断一个元素是否出现在集合中</strong>，是一种空间换时间的策略。</p>
<span id="more"></span>

<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>假如要查询一个名字是否在学校里，只需要初始化把这所学校里学生的名字都存在哈希表里，将学生姓名<strong>映射到哈希表</strong>上就涉及到了hash function ，也就是哈希函数。</p>
<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423484818.png" alt="哈希表2" style="zoom: 67%;" />



<h3 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h3><p>即不同的名字映射到了同一个索引上。</p>
<h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p>发生碰撞的元素都被存储在以该索引为头结点的链表中。</p>
<p>这种方法要选择适当的哈希表的大小，既不会因为哈希表数组空而浪费内存，也不会因为链表长而在查找上浪费时间。</p>
<h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h4><p>首先要确保tableSize大于dataSize。这种方法就是给产生碰撞的元素再找一个空位放置，根据不同的找空位方法还可细分。</p>
<h3 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h3><ol>
<li><p>数组</p>
</li>
<li><p>set(集合)</p>
</li>
<li><p>map(映射)</p>
</li>
</ol>
<h2 id="字母异位词"><a href="#字母异位词" class="headerlink" title="字母异位词"></a>字母异位词</h2><blockquote>
<p>题目：给定两个字符串 s 和 t ，判断s 和 t 中每个字符出现的次数是否相同。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// charCodeAt()方法，返回字符串第一个字符的Unicode编码值</span></span><br><span class="line"><span class="comment">// for..in可遍历Array, Object对象，且会遍历到新添加的成员属性。(历史遗留)</span></span><br><span class="line"><span class="comment">// for..of可遍历iterable可被迭代的对象(不包括Object)。且只遍历属于对象本身的属性。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">t</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用数组的解法</span></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>!=t.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">26</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">var</span> base=<span class="string">&quot;a&quot;</span>.<span class="title function_">charCodeAt</span>();<span class="comment">//获取a的unicode编码值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> s)&#123;</span><br><span class="line">        arr[i.<span class="title function_">charCodeAt</span>()-base]++;<span class="comment">//统计s串中各字符的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> t)&#123;</span><br><span class="line">        arr[i.<span class="title function_">charCodeAt</span>()-base]--;</span><br><span class="line">        <span class="keyword">if</span>(arr[i.<span class="title function_">charCodeAt</span>()-base]&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="keyword">function</span>(<span class="params">s, t</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用map的解法</span></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="property">length</span>!=t.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> s)&#123;</span><br><span class="line">        <span class="keyword">var</span> temp=arr.<span class="title function_">get</span>(i)||<span class="number">0</span>;</span><br><span class="line">        arr.<span class="title function_">set</span>(i,temp+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!arr.<span class="title function_">get</span>(i)) <span class="comment">// 这里包含了两种情况，一是为0，二是undefined </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        arr.<span class="title function_">set</span>(i, arr.<span class="title function_">get</span>(i)-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ul>
<li>383</li>
<li>49</li>
</ul>
<h2 id="数组交集"><a href="#数组交集" class="headerlink" title="数组交集"></a>数组交集</h2><blockquote>
<p>题目：给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回它们的交集 。输出结果中的每个元素一定是唯一的。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> intersection = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> num1=<span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">var</span> ret=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> nums1)&#123;</span><br><span class="line">        num1.<span class="title function_">add</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> nums2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1.<span class="title function_">has</span>(i)&amp;&amp;!ret.<span class="title function_">includes</span>(i)) ret.<span class="title function_">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="相关题目-1"><a href="#相关题目-1" class="headerlink" title="相关题目"></a>相关题目</h3><ul>
<li>350</li>
</ul>
<h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><blockquote>
<p>题目：判断一个数 <code>n</code> 是不是快乐数</p>
<p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。</p>
</blockquote>
<p>本题的重点在于无限循环，如果不是快乐数，计算出来的平方和一定会出现重复</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isHappy = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> list=<span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">    <span class="keyword">let</span> num=<span class="title function_">mySum</span>(n);</span><br><span class="line">    <span class="keyword">while</span>(num!=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.<span class="title function_">has</span>(num)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        list.<span class="title function_">add</span>(num);</span><br><span class="line">        num=<span class="title function_">mySum</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 计算一个数字各数位的平方和</span></span><br><span class="line"><span class="keyword">var</span> mySum = <span class="keyword">function</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">10</span>) <span class="keyword">return</span> n*n;</span><br><span class="line">    <span class="keyword">let</span> str=n+<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">0</span>;</span><br><span class="line">    str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">i</span>=&gt;</span>&#123;res+=<span class="title class_">Number</span>(i)*<span class="title class_">Number</span>(i)&#125;)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><blockquote>
<p>题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
</blockquote>
<p>本题的思路是在遍历时寻找元素匹配的另一半是否出现过，很自然想到用哈希表。常用的哈希表中，如果用数组会造成大量空间浪费；用set会出错（3+3&#x3D;6）,所以map比较合适</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> list=<span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> minus=target-nums[i] <span class="comment">// 差值</span></span><br><span class="line">        <span class="keyword">if</span>(list.<span class="title function_">has</span>(minus))&#123;</span><br><span class="line">            <span class="keyword">return</span> [list.<span class="title function_">get</span>(minus),i]</span><br><span class="line">        &#125;</span><br><span class="line">        list.<span class="title function_">set</span>(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加"></a>四数相加</h2><blockquote>
<p>题目：给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p>
<ul>
<li>0 &lt;&#x3D; i, j, k, l &lt; n</li>
<li>nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0</li>
</ul>
</blockquote>
<p>将四个数组两两一组，分别遍历两个数组中不同元素之和的所有情况，得到一个数组和一个map。之后遍历该数组，在map查找有无与之匹配的解，map中的value存放的是出现这个和的次数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums3</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums4</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fourSumCount = <span class="keyword">function</span>(<span class="params">nums1, nums2, nums3, nums4</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> list1=<span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// nums1和nums2的遍历组合</span></span><br><span class="line">    <span class="keyword">let</span> list2=[] <span class="comment">// nums3和nums4的遍历组合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums1.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;nums2.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">let</span> temp=nums1[i]+nums2[j]</span><br><span class="line">            <span class="keyword">let</span> num=list1.<span class="title function_">get</span>(temp)</span><br><span class="line">            list1.<span class="title function_">set</span>(temp,num==<span class="literal">undefined</span>?<span class="number">1</span>:num+<span class="number">1</span>) <span class="comment">// 构造list1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums3.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;nums4.<span class="property">length</span>;j++)&#123;</span><br><span class="line">            list2.<span class="title function_">push</span>(nums3[i]+nums4[j]); <span class="comment">// 构造list2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;list2.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> val=<span class="number">0</span>-list2[i];</span><br><span class="line">        <span class="keyword">if</span>(list1.<span class="title function_">get</span>(val)!=<span class="literal">undefined</span>) res+=list1.<span class="title function_">get</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度: O(n^2)</li>
<li>空间复杂度: O(n^2)，最坏情况下A和B的值各不相同，相加产生的数字个数为 n^2</li>
</ul>
<h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><blockquote>
<p>题目：给定一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。返回所有和为 0 且不重复的三元组。</p>
<p><strong>答案中不可以包含重复的三元组</strong></p>
</blockquote>
<p>注意题目条件：<strong>答案中不可以包含重复的三元组</strong>，即使有两组三元组均满足条件，但若内部元素值一样，则违反了这个条件</p>
<p>这道题用哈希法来做会遇到一个很棘手的问题，就是题目里说的不能包含重复的三元组。对重复的三元组去重很麻烦，也很费时。所以<strong>哈希法并不合适</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> list = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Set</span>() <span class="comment">// 用于去除重复数组，但set不能去除重复数组</span></span><br><span class="line">  <span class="keyword">let</span> ans=[]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> num = list.<span class="title function_">get</span>(nums[i])</span><br><span class="line">    list.<span class="title function_">set</span>(nums[i], num == <span class="literal">undefined</span> ? <span class="number">1</span> : num + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> num = list.<span class="title function_">get</span>(nums[i])</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="literal">undefined</span>) <span class="keyword">continue</span></span><br><span class="line">    list.<span class="title function_">set</span>(nums[i], num - <span class="number">1</span> == <span class="number">0</span> ? <span class="literal">undefined</span> : num - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> numm = list.<span class="title function_">get</span>(nums[j])</span><br><span class="line">      <span class="keyword">if</span>(numm==<span class="literal">undefined</span>) <span class="keyword">continue</span></span><br><span class="line">      list.<span class="title function_">set</span>(nums[j], numm - <span class="number">1</span> == <span class="number">0</span> ? <span class="literal">undefined</span> : numm - <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">let</span> tar = <span class="number">0</span> - nums[i] - nums[j];</span><br><span class="line">      <span class="keyword">if</span> (list.<span class="title function_">get</span>(tar) != <span class="literal">undefined</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp=<span class="keyword">new</span> <span class="title class_">Array</span>()</span><br><span class="line">        res.<span class="title function_">add</span>([nums[i], nums[j], tar].<span class="title function_">sort</span>())</span><br><span class="line">        list.<span class="title function_">set</span>(tar, list.<span class="title function_">get</span>(tar) - <span class="number">1</span> == <span class="number">0</span> ? <span class="literal">undefined</span> : list.<span class="title function_">get</span>(tar) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">//list.set(nums[j], list.get(nums[j]) == undefined ? 1 : list.get(nums[j]) + 1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//list.set(nums[i], list.get(nums[i]) == undefined ? 1 : list.get(nums[i]) + 1)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> i <span class="keyword">of</span> res) ans.<span class="title function_">push</span>(i)</span><br><span class="line">  <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>本题使用双指针法的重要前置操作是<strong>数组排序</strong>。整体思路比较简单，但<strong>如何去重是关键</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ans=[]</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b) <span class="comment">//从小到大排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="comment">// 对i指针去重</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; </span><br><span class="line">        <span class="keyword">let</span> left=i+<span class="number">1</span>,right=nums.<span class="property">length</span>-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]&gt;<span class="number">0</span>) right--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]&lt;<span class="number">0</span>) left++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans.<span class="title function_">push</span>([nums[i],nums[left],nums[right]])</span><br><span class="line">                <span class="comment">// 对right去重</span></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right-<span class="number">1</span>]) right--;</span><br><span class="line">                <span class="comment">// 对left去重</span></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                left++;right--</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><blockquote>
<p>题目：给定一个整数数组 nums ，返回所有和为 0 且不重复的四元组。</p>
</blockquote>
<p>四数之和与三数之和本质上都是一个做法，套两个循环，<code>nums[i]</code>和<code>nums[j]</code>为定值，设头尾指针移动。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fourSum = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">4</span>) <span class="keyword">return</span> [];</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 去重i</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 去重j</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] === nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">let</span> l = j + <span class="number">1</span>, r = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">                <span class="keyword">const</span> sum = nums[i] + nums[j] + nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; target) &#123; l++; <span class="keyword">continue</span>&#125;</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; target) &#123; r--; <span class="keyword">continue</span>&#125;</span><br><span class="line">                res.<span class="title function_">push</span>([nums[i], nums[j], nums[l], nums[r]]);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 对nums[left]和nums[right]去重</span></span><br><span class="line">                <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] === nums[++l]);</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] === nums[--r]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="数组的缺陷"><a href="#数组的缺陷" class="headerlink" title="数组的缺陷"></a>数组的缺陷</h3><ul>
<li>数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。</li>
<li>如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</li>
</ul>
<h3 id="set的缺陷"><a href="#set的缺陷" class="headerlink" title="set的缺陷"></a>set的缺陷</h3><ul>
<li>set是一个集合，里面放的元素只能是一个key</li>
</ul>
<h3 id="map的缺陷"><a href="#map的缺陷" class="headerlink" title="map的缺陷"></a>map的缺陷</h3><ul>
<li>map可以算是万能的哈希表，但<strong>map要维护红黑树或者符号表，而且还要做哈希函数的运算</strong>，效率不高</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>js基础</title>
    <url>/2023/06/27/20-56-15/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>JS &#x3D; ECMAScript(语法) + DOM(页面文档对象模型) + BOM(浏览器对象模型)  </p>
<ul>
<li>DOM和BOM都是Web API</li>
</ul>
<p>文档：</p>
<p><code>https://developer.mozilla.org/zh-CN</code></p>
<p><code>https://developer.mozilla.org/zh-CN/docs/web/javascript</code></p>
<span id="more"></span>

<h3 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h3><p>JavaScript 程序不能独立运行，它需要被嵌入 HTML 中，然后浏览器才能执行 JavaScript 代码。通过 <code>script</code> 标签将 JavaScript 代码引入到 HTML 中，有两种方式：</p>
<h4 id="内部方式"><a href="#内部方式" class="headerlink" title="内部方式"></a>内部方式</h4><p>通过 <code>script</code> 标签包裹 JavaScript 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JavaScript 基础 - 引入方式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--通常写到文件底部，因为浏览器是按照代码顺序加载的，如果先加载的js涉及到修改其下方的html，可能会失败--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&#x27;嗨，欢迎来传智播学习前端技术！&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// js一句代码结束后可以不写;</span></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="外部形式"><a href="#外部形式" class="headerlink" title="外部形式"></a>外部形式</h4><p>一般将 JavaScript 代码写在独立的以 .js 结尾的文件中，然后通过 <code>script</code> 标签的 <code>src</code> 属性引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo.js</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>JavaScript 基础 - 引入方式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;demo.js&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  	<span class="comment">// 这里的代码会被忽略</span></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="输入输出语句"><a href="#输入输出语句" class="headerlink" title="输入输出语句"></a>输入输出语句</h3><table>
<thead>
<tr>
<th>方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>alert(msg)</td>
<td align="left">浏览器弹出警示框</td>
</tr>
<tr>
<td>console.log(msg)</td>
<td align="left">浏览器控制台打印输出信息</td>
</tr>
<tr>
<td>prompt(info)</td>
<td align="left">浏览器弹出输入框，用户可以输入</td>
</tr>
<tr>
<td>document.write()</td>
<td align="left">向html文档中输出内容，可以识别标签</td>
</tr>
</tbody></table>
<p>注：<code>alert</code>和<code>prompt</code>会跳过页面渲染先被执行。</p>
<h3 id="let和var"><a href="#let和var" class="headerlink" title="let和var"></a>let和var</h3><p>JavaScript 使用专门的关键字 <code>let</code> 和 <code>var</code> 来声明（定义）变量，在使用时需要注意一些细节：</p>
<p>以下是使用 <code>let</code> 时的注意事项：</p>
<ol>
<li>允许声明时赋值</li>
<li><strong>不允许重复声明</strong></li>
<li>允许同时声明多个变量并赋值</li>
<li>JavaScript 中内置的一些关键字不能被当做变量名</li>
</ol>
<p><code>var</code>和<code>let</code>的区别在于</p>
<ul>
<li><strong>var允许重复声明</strong>。</li>
<li>可以先使用再声明</li>
<li>变量提升，是全局变量，没有块级作用域</li>
</ul>
<p>因此 <code>let</code> 相较 <code>var</code> 更严谨，推荐使用 <code>let</code>。</p>
<h3 id="变量名命名规则"><a href="#变量名命名规则" class="headerlink" title="变量名命名规则"></a>变量名命名规则</h3><p>关于变量的名称（标识符）有一系列的规则需要遵守：</p>
<ol>
<li>只能是字母、数字、下划线、$，且不能能数字开头</li>
<li>字母区分大小写，如 Age 和 age 是不同的变量</li>
<li>JavaScript 内部已占用于单词（关键字或保留字）不允许使用</li>
<li>尽量保证变量具有一定的语义，见字知义</li>
</ol>
<p>注：所谓关键字是指 JavaScript 内部使用的词语，如 <code>let</code> 和<code>var</code>，保留字是指 JavaScript 内部目前没有使用的词语，但是将来可能会使用词语。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>概念：使用 <code>const</code> 声明的变量称为“常量”。</p>
<p>使用场景：当某个变量永远不会改变的时候，就可以使用<code>const</code>来声明，而不是let。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意： 常量不允许重新赋值,声明的时候必须赋值（初始化）</p>
</blockquote>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul>
<li><code>==</code> 左右两边值是否相等</li>
<li><code>===</code> 左右两边是否类型和值都相等</li>
<li><code>!=</code> 两边操作数不相等时返回true</li>
<li><code>!==</code> 操作数或类型不等时返回true</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>js中有两大数据类型，分别是<strong>值类型(基本类型)<strong>和</strong>引用类型(对象类型)</strong></p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>基本类型在存储时<strong>变量中存储的是值本身</strong>，存储在栈区</p>
<p>js是<strong>弱数据类型</strong>的语言，主要有五大基本数据类型，可以通过 <code>typeof</code> 关键字检测数据类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typeof有两种使用方法</span></span><br><span class="line"><span class="comment">// 作为运算符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 函数形式</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(<span class="literal">null</span>))</span><br></pre></td></tr></table></figure>

<h4 id="number类型"><a href="#number类型" class="headerlink" title="number类型"></a>number类型</h4><p>包括整数、小数、正数、负数。在number中有一个特殊的值，叫做<code>NaN</code>，代表计算错误，任何对NaN的操作都会返回NaN。</p>
<h4 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h4><p>通过单引号 、双引号或反引号包裹的数据都叫字符串，单引号和双引号没有本质上的区别，推荐使用单引号。</p>
<p>字符串可以拼接，但比较麻烦。</p>
<p>注意事项：</p>
<ol>
<li>无论单引号或是双引号必须成对使用</li>
<li>单引号&#x2F;双引号<strong>可以互相嵌套</strong>，但是不能自已嵌套自已</li>
<li>必要时可以使用转义符 <code>\</code>，输出单引号或双引号</li>
</ol>
<h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age=<span class="number">20</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我&#x27;</span>+age+<span class="string">&#x27;岁&#x27;</span>) <span class="comment">// 字符串拼接</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我<span class="subst">$&#123;age&#125;</span>岁了`</span>) <span class="comment">// 模板字符串，必须用反引号</span></span><br></pre></td></tr></table></figure>



<h4 id="boolean类型"><a href="#boolean类型" class="headerlink" title="boolean类型"></a>boolean类型</h4><h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><p>未定义是比较特殊的类型，只有一个值 undefined。变量未初始化时，其默认值为 undefined。因为js是弱数据类型的语言，未经初始化，解释器也不知道变量是何类型</p>
<p>一般很少【直接】为某个变量赋值为 undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只声明了变量，并末赋值</span></span><br><span class="line"><span class="keyword">let</span> tmp;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="keyword">typeof</span> tmp) <span class="comment">// 结果为 undefined</span></span><br></pre></td></tr></table></figure>

<p>通常用于检查一个数据是否被传递过来</p>
<h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><p>null表示赋值了，但是内容为空。可以把null作为<strong>尚未创建的对象</strong></p>
<p>如果一个变量里确定存放的是对象，但该对象还没准备好，就可以先放个null</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data=<span class="literal">null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> data); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>+<span class="number">1</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span>+<span class="number">1</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>复杂数据类型，在存储变量时**存储的是地址(引用)**，在栈区存地址，实际存储在堆区</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h5><ul>
<li>push  尾部追加</li>
<li>unshift  头部增加</li>
</ul>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><ul>
<li>pop  删除最后一个</li>
<li>shift   删除第一个</li>
<li>splice(删除的下标，删除的个数)</li>
</ul>
<h5 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr)&#123; <span class="comment">// 通常不同for in遍历数组</span></span><br><span class="line">    <span class="comment">// i是数组的索引号，但是是字符串</span></span><br><span class="line">    arr[i] <span class="comment">// 这样也可以拿到元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> arr) i <span class="comment">// i就是元素</span></span><br></pre></td></tr></table></figure>



<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="命名函数"><a href="#命名函数" class="headerlink" title="命名函数"></a>命名函数</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//函数体代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getSum</span>();</span><br></pre></td></tr></table></figure>



<h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><h6 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;函数表达式&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure>



<h6 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h6><p>避免全局变量之间的污染</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; xxx  &#125;)();</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;xxxx&#125;());</span><br><span class="line"><span class="comment">//多个立即执行函数要用;隔开</span></span><br></pre></td></tr></table></figure>

<h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><p>采取就近原则的方式来查找变量最终的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">&#x27;22&#x27;</span>;</span><br><span class="line">    <span class="title function_">fn2</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">        <span class="title function_">fn3</span>();</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">fn3</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//a的值 4</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">//b的值 22</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>();</span><br></pre></td></tr></table></figure>

<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><h5 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h5><p>对象(object)是一种数据类型，可以理解为一种无序的数据集合。它由<strong>属性和方法</strong>两部分构成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person=&#123; <span class="comment">// 定义对象</span></span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;fj&#x27;</span>,</span><br><span class="line">	<span class="attr">sing</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="property">age</span>=<span class="number">20</span> <span class="comment">// 动态追加属性</span></span><br><span class="line">person[<span class="string">&#x27;age&#x27;</span>]=<span class="number">20</span> <span class="comment">// 这样也能得到属性</span></span><br><span class="line">person.<span class="property">move</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 动态追加方法</span></span><br><span class="line"><span class="comment">//也可以删除属性  delete person.name ，在严格模式下不允许，仅了解</span></span><br></pre></td></tr></table></figure>

<h5 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 得到属性名</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[i]) <span class="comment">// 得到属性值</span></span><br><span class="line">    <span class="comment">// console.log(obj.i) //这个写法是错误的，i是个字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常使用**<code>for in</code>遍历对象，其遍历的是键名，遍历的结果是个字符串**；<code>for of</code>遍历带有iterator接口的，例如set、map、array</p>
<h5 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h5><p>如<code>Math</code>、<code>Date</code>、<code>Number</code>等</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>某些运算符被执行时，<strong>系统内部自动将数据类型进行转换</strong>，这种转换称为隐式转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">13</span> <span class="comment">// 数值</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="string">&#x27;2&#x27;</span> <span class="comment">// 字符串</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num + num2) <span class="comment">//字符串拼接 132</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num - num2) <span class="comment">//数字加减 11</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num * num2) <span class="comment">// 26</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="string">&#x27;12&#x27;</span>) <span class="comment">// 转为数字型</span></span><br></pre></td></tr></table></figure>

<p>转换类型不明显</p>
<h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><p>编写程序时过度依靠系统内部的隐式转换是不严禁的，因为隐式转换规律并不清晰，大多是靠经验总结的规律。为了避免因隐式转换带来的问题，通常根逻辑需要对数据进行显示转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显式将字符串 12 转换成数值 12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>(<span class="string">&#x27;12&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;12.2pp&#x27;</span>)) <span class="comment">//12</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&#x27;a12a&#x27;</span>)) <span class="comment">//NaN 只能取开头的数字</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(<span class="string">&#x27;12.2pp&#x27;</span>)) <span class="comment">//12.2</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2023/06/29/11-00-00/</url>
    <content><![CDATA[<h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><span id="more"></span>

<blockquote>
<p>题目：给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
</blockquote>
<p>一些同学可能为了处理逻辑：每隔2k个字符的前k的字符，写了一堆逻辑代码或者再搞一个计数器，来统计2k，再统计前k个字符。</p>
<p>其实在遍历字符串的过程中，只要让 i +&#x3D; (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。</p>
<p><strong>所以当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseStr = <span class="keyword">function</span>(<span class="params">s, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> len=s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> res=s.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// 字符串无法更改，先变成数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i+=<span class="number">2</span>*k)&#123; <span class="comment">//每次移动2k</span></span><br><span class="line">        k=i+k&gt;len?len-<span class="attr">i</span>:k <span class="comment">// 剩余字符&lt;k,则全部反转;&gt;k则反转前k个</span></span><br><span class="line">        <span class="keyword">let</span> left=i  <span class="comment">// 待反转字符的头指针</span></span><br><span class="line">        <span class="keyword">let</span> right=i+k-<span class="number">1</span> <span class="comment">// 待反转字符的尾指针</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">let</span> temp=res[left]</span><br><span class="line">            res[left++]=res[right]</span><br><span class="line">            res[right--]=temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// 变成字符串返回</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><blockquote>
<p>题目：实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
</blockquote>
<p>这道题如果用split库函数非常简单，但也失去了意义。</p>
<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> replaceSpace = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(s); <span class="comment">// 转化为数组</span></span><br><span class="line">    <span class="keyword">let</span> count=<span class="number">0</span>; <span class="comment">// 空格的数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==<span class="string">&#x27; &#x27;</span>) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left = arr.<span class="property">length</span>-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> right = arr.<span class="property">length</span>+count*<span class="number">2</span>-<span class="number">1</span>; <span class="comment">//将所有空格替换之后的长度</span></span><br><span class="line">    <span class="keyword">while</span>(left&gt;=<span class="number">0</span>)&#123; <span class="comment">// 从后向前依次遍历，若从前向后需要重新分配空间</span></span><br><span class="line">        <span class="keyword">if</span>(arr[left]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            arr[right--]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            arr[right--]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            arr[right--]=<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            arr[right--]=arr[left]</span><br><span class="line">        &#125;</span><br><span class="line">        left--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="翻转字符串中的单词"><a href="#翻转字符串中的单词" class="headerlink" title="翻转字符串中的单词"></a>翻转字符串中的单词</h2><blockquote>
<p>题目：给你一个字符串 s ，请你反转字符串中 单词 的顺序。</p>
<p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p>
<p>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p>
<p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
</blockquote>
<p>在不申请额外空间的前提下，这类问题的基本范式是<strong>局部反转+整体反转</strong></p>
<ol>
<li>移除多余空格</li>
<li>将整个字符串反转</li>
<li>将每个单词反转</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseWords = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(s)</span><br><span class="line">    <span class="title function_">removeMoreSpace</span>(arr) <span class="comment">// js参数传递时，基本类型是值传递，引用类型是引用传递</span></span><br><span class="line">    <span class="comment">// 翻转</span></span><br><span class="line">    <span class="title function_">reverse</span>(arr, <span class="number">0</span>, arr.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] === <span class="string">&#x27; &#x27;</span> || i === arr.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="comment">// 翻转单词</span></span><br><span class="line">            <span class="title function_">reverse</span>(arr, start, i - <span class="number">1</span>);</span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除多余空格</span></span><br><span class="line"><span class="keyword">var</span> removeMoreSpace=<span class="keyword">function</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> fast=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> slow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast&lt;arr.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[fast]==<span class="string">&#x27; &#x27;</span>&amp;&amp;(fast==<span class="number">0</span>||arr[fast-<span class="number">1</span>]==<span class="string">&#x27; &#x27;</span>)) fast++</span><br><span class="line">        <span class="keyword">else</span> arr[slow++]=arr[fast++]</span><br><span class="line">    &#125;</span><br><span class="line">    arr.<span class="property">length</span>=arr[slow-<span class="number">1</span>]==<span class="string">&#x27; &#x27;</span>?slow-<span class="number">1</span>:slow</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 翻转从start到end的字符</span></span><br><span class="line"><span class="keyword">var</span> reverse=<span class="keyword">function</span>(<span class="params">arr,start,end</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> left = start;</span><br><span class="line">    <span class="keyword">let</span> right = end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        [arr[left], arr[right]] = [arr[right], arr[left]];</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串匹配-KMP"><a href="#字符串匹配-KMP" class="headerlink" title="字符串匹配-KMP"></a>字符串匹配-KMP</h2><blockquote>
<p>题目：给定两个字符串 haystack 和 needle，在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标(下标从 0 开始)，否则返回 -1 。 </p>
</blockquote>
<p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再做匹配了</strong></p>
<h3 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h3><p>包含首字母，不包含尾字母的所有子串</p>
<h3 id="前缀表"><a href="#前缀表" class="headerlink" title="前缀表"></a>前缀表</h3><p>前缀表中存储的是前缀和该字符串本身的<strong>最长相等前后缀</strong></p>
<h3 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h3><p>在文本串和模式串分别设指针开始匹配，当匹配不上的时候，查询前一个字符的前缀表。不必从头开始匹配，而是从前一个字符的最长相等前后缀的后一位开始。原理是不匹配的那一位的前面所有字符都是匹配的，此时找到最长相等前后缀，既然该子串的前缀和后缀相等，那么前缀也是匹配的，所以<strong>跳过必然匹配的前缀，从前缀后面开始匹配即可</strong>。</p>
<p>而这个前缀表的数字正好代表了下次匹配时需要跳过的前缀长度，比如查询到对应的前缀表数字是2，那么下一次匹配时就跳过模式串前两个字符，从索引为2的位置开始。所以<strong>前缀表上最长相等前后缀刚好代表了下一次需要跳转到的位置</strong>，因此<strong>可以直接把前缀表当成next数组</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">haystack</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">needle</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> strStr = <span class="keyword">function</span> (<span class="params">haystack, needle</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.<span class="property">length</span> === <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getNext</span> = (<span class="params">needle</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> next = [];</span><br><span class="line">        <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">        next.<span class="title function_">push</span>(j);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; needle.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] !== needle[j])</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (needle[i] === needle[j])</span><br><span class="line">                j++;</span><br><span class="line">            next.<span class="title function_">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> next = <span class="title function_">getNext</span>(needle);</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; haystack.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] !== needle[j])</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] === needle[j])</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (j === needle.<span class="property">length</span>)</span><br><span class="line">            <span class="keyword">return</span> (i - needle.<span class="property">length</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>js tips</title>
    <url>/2023/07/01/10-30-15/</url>
    <content><![CDATA[<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=<span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">2</span>); <span class="comment">// 这一句要加;</span></span><br><span class="line">[arr[<span class="number">1</span>], arr[<span class="number">0</span>]] = [arr[<span class="number">0</span>], arr[<span class="number">1</span>]]; <span class="comment">// 前面的语句要加分号</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure>

<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>js在参数传递时，对于基本数据类型是值传递方式；对于引用数据类型是引用传递</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num</span>)&#123; <span class="comment">// 值传递</span></span><br><span class="line">  num+=<span class="number">10</span></span><br><span class="line">  <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>(a)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)			<span class="comment">//10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(a))		<span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">modifyArray</span>(<span class="params">arr</span>) &#123; <span class="comment">// 引用传递</span></span><br><span class="line">  arr.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="title function_">modifyArray</span>(nums);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nums); <span class="comment">// 输出 [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>虽然传递对象时是通过引用传递，但是<strong>如果在函数内部将参数重新赋值为一个新的对象，这个赋值操作对原始对象并没有影响</strong>。这是因为在函数内部，参数变量被重新赋值，指向了一个新的对象，而不是修改原始对象的引用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">replaceObj</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  obj = &#123;<span class="attr">a</span>: <span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="title function_">replaceObj</span>(person);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// 输出 &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
