<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fangjun120.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="介绍redis是一个基于 C 语言开发的开源 NoSQL 数据库，Redis 的数据是保存在内存中的（内存数据库，支持持久化）">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="https://fangjun120.github.io/2024/03/06/11-00-37/index.html">
<meta property="og:site_name" content="eidolon的小窝">
<meta property="og:description" content="介绍redis是一个基于 C 语言开发的开源 NoSQL 数据库，Redis 的数据是保存在内存中的（内存数据库，支持持久化）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fangjun120.github.io/pic/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="https://fangjun120.github.io/pic/%E8%B7%B3%E8%A1%A81.png">
<meta property="og:image" content="https://fangjun120.github.io/pic/redis%E5%A4%9A%E7%BA%BF%E7%A8%8B">
<meta property="article:published_time" content="2024-03-06T03:00:37.000Z">
<meta property="article:modified_time" content="2024-03-06T14:29:52.769Z">
<meta property="article:author" content="Fang Jun">
<meta property="article:tag" content="八股">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fangjun120.github.io/pic/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg">

<link rel="canonical" href="https://fangjun120.github.io/2024/03/06/11-00-37/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis | eidolon的小窝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">eidolon的小窝</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">做有趣的人</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fangjun120.github.io/2024/03/06/11-00-37/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eidolon的小窝">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-06 11:00:37 / 修改时间：22:29:52" itemprop="dateCreated datePublished" datetime="2024-03-06T11:00:37+08:00">2024-03-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>redis是一个基于 C 语言开发的开源 NoSQL 数据库，Redis 的数据是保存在内存中的（内存数据库，支持持久化）</p>
<span id="more"></span>

<p>⭐⭐ Redis快在哪？</p>
<ul>
<li>基于内存</li>
<li>基于 <strong>Reactor 模式</strong><ul>
<li>通过一个或多个输入同时传递给服务处理器的服务请求的<strong>事件驱动处理模式</strong>，服务端程序处理传入<strong>多路请求</strong> (IO多路复用)，并将它们同步分派给请求对应的处理线程。</li>
</ul>
</li>
<li>优化数据结构</li>
</ul>
<img src="/pic/redis数据结构.jpg" alt="Redis 数据类型概览" style="zoom:67%;" />

<p>⭐ 为什么要用redis&#x2F;缓存？</p>
<ul>
<li>高性能<ul>
<li>操作缓存就是直接操作内存，所以速度相当快。</li>
</ul>
</li>
<li>高并发<ul>
<li>MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g），使用 Redis 缓存之后很容易达到 10w+</li>
</ul>
</li>
</ul>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>单线程或单进程<strong>同时监测若干个文件描述符</strong>是否可以执行IO操作的能力。多路指的是<strong>多个socket连接</strong>，复用指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。</p>
<p>epoll是最新的也是目前最好的多路复用技术。采用多路 I&#x2F;O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p>
<h2 id="三种常见的缓存读写策略"><a href="#三种常见的缓存读写策略" class="headerlink" title="三种常见的缓存读写策略"></a>三种常见的缓存读写策略</h2><h3 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h3><p>服务端需要<strong>同时维系 db 和 cache</strong>，并且是以 db 的结果为准。</p>
<p><strong>写</strong>：</p>
<ul>
<li>先更新 db</li>
<li>然后直接删除 cache 。</li>
</ul>
<p><strong>读</strong> :</p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache 中读取不到的话，就从 db 中读取数据返回</li>
<li>再把数据放到 cache 中。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>首次请求数据一定不在 cache<ul>
<li>将热点数据可以提前放入 cache 中。</li>
</ul>
</li>
<li>写操作频繁，导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。</li>
</ul>
<h3 id="Read-x2F-Write-Through-Pattern（读写穿透）"><a href="#Read-x2F-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read&#x2F;Write Through Pattern（读写穿透）"></a>Read&#x2F;Write Through Pattern（读写穿透）</h3><p>服务端<strong>把 cache 视为主要数据存储</strong>，从中读取数据并将数据写入其中。<strong>cache 服务负责与db的同步</strong>，从而减轻了应用程序的职责。</p>
<p>但是开发中很少见， Redis 并没有提供 cache 将数据写入 db 的功能。</p>
<p><strong>写：</strong></p>
<ul>
<li>先查 cache，cache 中不存在，直接更新 db。</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）。</li>
</ul>
<p><strong>读：</strong></p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回 。</li>
<li>读取不到的话，由cache服务自己从 db 加载，写入到 cache 后返回响应。</li>
</ul>
<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 <strong>cache 服务自己来写入缓存</strong>的，这对客户端是透明的。</p>
<h3 id="Write-Behind-Pattern（异步缓存写入）"><a href="#Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Pattern（异步缓存写入）"></a>Write Behind Pattern（异步缓存写入）</h3><p> 和 Read&#x2F;Write Through Pattern 很相似，两者都是<strong>由 cache 服务来负责同步数据</strong>。</p>
<p>不同之处在于：Read&#x2F;Write Through 是同步更新 cache 和 db，而 Write Behind 则是<strong>只更新缓存</strong>，不直接更新 db，而是改为<strong>异步批量的方式来更新 db</strong>。</p>
<p>适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>
<h2 id="RediSearch-VS-ES"><a href="#RediSearch-VS-ES" class="headerlink" title="RediSearch VS ES"></a>RediSearch VS ES</h2><p>Redis 是可以实现全文搜索引擎功能的，需要借助 <strong>RediSearch</strong> ，这是一个基于 Redis 的搜索引擎模块。</p>
<p>RediSearch 支持中文分词、聚合统计、停用词、同义词、拼写检查、标签查询、向量相似度查询、多关键词搜索、分页搜索等功能，算是一个功能比较完善的全文搜索引擎了。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>性能更优秀：依赖 Redis 自身的高性能，基于内存操作（Elasticsearch 基于磁盘）。</p>
</li>
<li><p>较低内存占用实现快速索引：RediSearch 内部使用<strong>压缩的倒排索引</strong>，所以可以用较低的内存占用来实现索引的快速构建。</p>
</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>数据量限制：Elasticsearch 可以支持 PB 级别的数据量，可以轻松扩展到多个节点，利用分片机制提高可用性和性能。RedisSearch 是基于 Redis 实现的，其能存储的数据量受限于 Redis 的内存容量，不太适合存储大规模的数据（内存昂贵，扩展能力较差）。</p>
</li>
<li><p>分布式能力较差：Elasticsearch 是为分布式环境设计的，可以轻松扩展到多个节点。虽然 RedisSearch 支持分布式部署，但在实际应用中可能会面临一些挑战，如数据分片、节点间通信、数据一致性等问题。</p>
</li>
<li><p>聚合功能较弱：Elasticsearch 提供了丰富的聚合功能，而 RediSearch 的聚合功能相对较弱，只支持简单的聚合操作。</p>
</li>
<li><p>生态较差：Elasticsearch 可以轻松和常见的一些系统&#x2F;软件集成比如 Hadoop、Spark、Kibana，而 RedisSearch 则不具备该优势</p>
</li>
</ul>
<p>Elasticsearch 适用于全文搜索、复杂查询、实时数据分析和聚合的场景，而 RediSearch 适用于快速数据存储、缓存和简单查询的场景。</p>
<h2 id="sorted-set底层实现"><a href="#sorted-set底层实现" class="headerlink" title="sorted set底层实现"></a>sorted set底层实现</h2><p>Redis 有个比较常用的数据结构叫<strong>有序集合(sorted set，简称 zset)<strong>，可以保证有序且元素唯一，经常用于排行榜等需要进行统计排列的场景，是</strong>基于跳表和压缩表实现</strong>的。</p>
<ul>
<li>当有序集合对象同时满足以下两个条件时，使用 ziplist：<ol>
<li>键值对数量少于 128 个；</li>
<li>每个元素的长度小于 64 字节。</li>
</ol>
</li>
<li>如果不满足上述两个条件，那么使用 skiplist</li>
</ul>
<h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p>ziplist是一块<strong>连续的内存空间</strong>，元素之间紧挨着存储，没有任何冗余空隙。它的设计目标就是为了提高存储效率。ziplist可以用于存储字符串或整数，其中整数是按真正的<strong>二进制表示进行编码</strong>的，而不是编码成字符串序列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ziplist</span>&lt;</span>T&gt; &#123;</span><br><span class="line">    int32 zlbytes;       <span class="comment">// 整个压缩列表占用字节数，包含本身</span></span><br><span class="line">    int32 zltail_offset; <span class="comment">// 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点，从而可以在ziplist尾部快速的执行push，pop操作</span></span><br><span class="line">    int16 zllength;      <span class="comment">// 元素个数,最大值为2^16-1，若元素数量超出最大值，该字段失效</span></span><br><span class="line">    T[] entries;         <span class="comment">// 元素内容列表，挨个挨个紧凑存储</span></span><br><span class="line">    int8 zlend;          <span class="comment">// ziplist最后一个字节，标志压缩列表的结束，值恒为 0xFF（255）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h3><p>跳表在原始<strong>链表</strong>基础上，<strong>建立多级索引</strong>将增删改查的时间复杂度变为O(log n)。</p>
<p>以下图跳表为例，其原始链表存储按序存储 1-10，有 2 级索引，每级索引的索引个数都是基于下层元素个数的一半。</p>
<img src="/pic/跳表1.png" alt="img" style="zoom: 80%;" />

<p>查询元素 6：</p>
<ul>
<li>从 2 级索引开始，先来到节点 4。</li>
<li>查看 4 的后继节点，是 8 的 2 级索引，这个值大于 6，说明 2 级索引后续的索引都是大于 6 的，没有再往后搜寻的必要，我们索引向下查找。</li>
<li>来到 4 的 1 级索引，比对其后继节点为 6，查找结束。</li>
</ul>
<p>索引需要尽可能保证每一个上<strong>级索引都是下级索引的一半</strong>。</p>
<p>另外在增删元素是还伴随索引的增加和删除。</p>
<h4 id="vs-平衡树"><a href="#vs-平衡树" class="headerlink" title="vs 平衡树"></a>vs 平衡树</h4><p>平衡树的插入、删除和查询的时间复杂度和跳表一样都是 **O(log n)**。但是平衡树的每一次插入或者删除操作都需要保证整颗树左右节点的绝对平衡，只要不平衡就要通过旋转操作来保持平衡，这个过程是比较耗时的。</p>
<p>跳表是一种可以用来代替平衡树的数据结构。跳表使用<strong>概率平衡</strong>而不是严格强制的平衡，因此，跳表中的插入和删除算法比平衡树的等效算法简单得多，速度也快得多。</p>
<h4 id="vs-红黑树"><a href="#vs-红黑树" class="headerlink" title="vs 红黑树"></a>vs 红黑树</h4><p>红黑树是一个<strong>黑平衡树</strong>，相较于平衡树，维持平衡的开销要小一些。跳表的实现更简单，效率也更高。</p>
<h4 id="vs-B-树"><a href="#vs-B-树" class="headerlink" title="vs B+树"></a>vs B+树</h4><p>B+树更适合作为数据库和文件系统中常用的索引结构之一，它的核心思想是通过尽可能少的 IO ，定位到尽可能多的索引来获得查询数据。</p>
<p>对于 Redis 这种内存数据库来说，它对这些并不感冒，因为 Redis 作为内存数据库它不可能存储大量的数据，所以对于索引不需要通过 B+树这种方式进行维护，只需按照概率进行随机维护即可，节约内存。</p>
<p>而且使用跳表实现 zset 时相较前者来说更简单一些，在进行插入时只需通过索引将数据插入到链表中合适的位置再随机维护一定高度的索引即可，也不需要像 B+树那样插入时发现失衡时还需要对节点分裂与合并。</p>
<h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>对于<strong>读写命令</strong>来说，Redis 一直是<strong>单线程</strong>模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求。</p>
<h3 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h3><p>Redis基于Reactor模型 (高性能 IO 的基石) 设计了一套高效的事件处理模型。Redis 采用<strong>事件驱动机制</strong>来处理大量的网络IO。开发了自己的<strong>网络事件处理器</strong>，称为<strong>文本事件处理器</strong>。通过IO多路复用程序同时监听多个套接字，将套接字关联到不同的事件处理器。</p>
<p>文件事件处理器（file event handler）主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p>大体上说，6.0之前主要使用单线程进行处理，为什么不使用多线程？</p>
<ul>
<li>单线程容易并且更容易维护</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ul>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>为了提高网络IO读写性能，Redis 6.0引入多线程，默认是禁用的，需要修改redis.conf配置文件：<code>io-threads-do-reads yes</code>来开启支持。开启多线程后，还需要设置线程数，否则是不生效的。同样修改redis.conf配置文件<code>io-threads 4</code></p>
<p><img src="/pic/redis%E5%A4%9A%E7%BA%BF%E7%A8%8B" alt="图片"></p>
<h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>实际还有一些后台线程用于执行一些比较耗时的操作</p>
<ul>
<li><p>通过 <code>bio_close_file</code> 后台线程来释放 AOF &#x2F; RDB 等过程中产生的临时文件资源。</p>
</li>
<li><p>通过 <code>bio_aof_fsync</code> 后台线程调用 <code>fsync</code> 函数将系统内核缓冲区 还未同步到到磁盘 的数据 强制刷到磁盘（ AOF 文件）。</p>
</li>
<li><p>通过 <code>bio_lazy_free</code>后台线程释放 大对象（已删除）占用的内存空间.</p>
</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h3><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。</p>
<ul>
<li>节省内存<ul>
<li>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</li>
</ul>
</li>
<li>业务方便<ul>
<li>验证码有效期</li>
</ul>
</li>
</ul>
<h3 id="redis判断过期原理"><a href="#redis判断过期原理" class="headerlink" title="redis判断过期原理"></a>redis判断过期原理</h3><p>Redis 通过 <strong>过期字典</strong>（可以看作是 hash 表）来保存数据过期的时间，过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    dict *dict;     <span class="comment">//数据库键空间,保存着数据库中所有键值对</span></span><br><span class="line">    dict *expires   <span class="comment">// 过期字典,保存着键的过期时间</span></span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<h3 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h3><p>redis怎么删除过期的数据呢</p>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>只会在取出 key 的时候才对数据进行过期检查。这样<strong>对 CPU 最友好</strong>，但是可能会造成太多过期 key 没有被删除。</p>
<h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。对<strong>内存友好</strong>。</p>
<p>Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 。</p>
<h3 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h3><p><strong>和操作系统内存淘汰类似</strong>，Redis 提供 6 种数据淘汰策略，按是否设置过期时间可以分为两种，volatile前缀是从已设置过期时间的数据中选；allkeys前缀是从全局数据中选</p>
<ol>
<li><p>volatile-lru（least recently used）：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选<strong>最近最少使用</strong>的数据淘汰。</p>
</li>
<li><p>volatile-ttl：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选<strong>将要过期</strong>的数据淘汰。</p>
</li>
<li><p>volatile-random：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中<strong>任意选择</strong>数据淘汰。</p>
</li>
<li><p>allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除<strong>最近最少使用</strong>的 key（这个是最常用的）。</p>
</li>
<li><p>allkeys-random：从数据集（<code>server.db[i].dict</code>）中任<strong>意选择</strong>数据淘汰。</p>
</li>
<li><p>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧</p>
</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol>
<li>volatile-lfu（least frequently used）：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选<strong>最不经常使用</strong>的数据淘汰。</li>
<li>allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在整个键空间中，移除<strong>最不经常使用</strong>的 key。</li>
</ol>
<p>⭐⭐ 如何保证redis里的是热点数据？</p>
<ul>
<li>可以使用内存淘汰机制实现，使用allkeys-lru淘汰策略，频繁被访问的数据会被保留下来。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%85%AB%E8%82%A1/" rel="tag"># 八股</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/03/02/11-00-37/" rel="prev" title="黑马点评">
      <i class="fa fa-chevron-left"></i> 黑马点评
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">IO多路复用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5"><span class="nav-number">3.</span> <span class="nav-text">三种常见的缓存读写策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache-Aside-Pattern%EF%BC%88%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">3.1.</span> <span class="nav-text">Cache Aside Pattern（旁路缓存模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">3.1.1.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-x2F-Write-Through-Pattern%EF%BC%88%E8%AF%BB%E5%86%99%E7%A9%BF%E9%80%8F%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">Read&#x2F;Write Through Pattern（读写穿透）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Write-Behind-Pattern%EF%BC%88%E5%BC%82%E6%AD%A5%E7%BC%93%E5%AD%98%E5%86%99%E5%85%A5%EF%BC%89"><span class="nav-number">3.3.</span> <span class="nav-text">Write Behind Pattern（异步缓存写入）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RediSearch-VS-ES"><span class="nav-number">4.</span> <span class="nav-text">RediSearch VS ES</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">4.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="nav-number">4.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sorted-set%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.</span> <span class="nav-text">sorted set底层实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ziplist"><span class="nav-number">5.1.</span> <span class="nav-text">ziplist</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#skiplist"><span class="nav-number">5.2.</span> <span class="nav-text">skiplist</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vs-%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="nav-number">5.2.1.</span> <span class="nav-text">vs 平衡树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vs-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">5.2.2.</span> <span class="nav-text">vs 红黑树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vs-B-%E6%A0%91"><span class="nav-number">5.2.3.</span> <span class="nav-text">vs B+树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="nav-number">6.</span> <span class="nav-text">持久化机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.</span> <span class="nav-text">线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.1.</span> <span class="nav-text">单线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">7.2.</span> <span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="nav-number">7.3.</span> <span class="nav-text">后台线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">8.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-number">8.1.</span> <span class="nav-text">过期时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E5%88%A4%E6%96%AD%E8%BF%87%E6%9C%9F%E5%8E%9F%E7%90%86"><span class="nav-number">8.2.</span> <span class="nav-text">redis判断过期原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-number">8.3.</span> <span class="nav-text">过期删除策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="nav-number">8.3.1.</span> <span class="nav-text">惰性删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="nav-number">8.3.2.</span> <span class="nav-text">定期删除</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">8.4.</span> <span class="nav-text">内存淘汰机制</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fang Jun</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">95</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fang Jun</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":300},"mobile":{"show":false},"rect":"opacity:0.7","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
