<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fangjun120.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="介绍redis是一个基于 C 语言开发的开源 NoSQL 数据库，Redis 的数据是保存在内存中的（内存数据库，支持持久化）">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="https://fangjun120.github.io/2024/03/06/11-00-37/index.html">
<meta property="og:site_name" content="eidolon的小窝">
<meta property="og:description" content="介绍redis是一个基于 C 语言开发的开源 NoSQL 数据库，Redis 的数据是保存在内存中的（内存数据库，支持持久化）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fangjun120.github.io/pic/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg">
<meta property="og:image" content="https://fangjun120.github.io/pic/%E8%B7%B3%E8%A1%A81.png">
<meta property="og:image" content="https://fangjun120.github.io/pic/AOF%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://fangjun120.github.io/pic/redis%E5%A4%9A%E7%BA%BF%E7%A8%8B">
<meta property="og:image" content="https://fangjun120.github.io/pic/bigkey%E5%88%A4%E5%AE%9A%E6%A0%87%E5%87%86.png">
<meta property="article:published_time" content="2024-03-06T03:00:37.000Z">
<meta property="article:modified_time" content="2024-03-08T03:34:17.758Z">
<meta property="article:author" content="Fang Jun">
<meta property="article:tag" content="八股">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fangjun120.github.io/pic/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg">

<link rel="canonical" href="https://fangjun120.github.io/2024/03/06/11-00-37/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis | eidolon的小窝</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">eidolon的小窝</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">做有趣的人</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fangjun120.github.io/2024/03/06/11-00-37/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Fang Jun">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="eidolon的小窝">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-06 11:00:37" itemprop="dateCreated datePublished" datetime="2024-03-06T11:00:37+08:00">2024-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-08 11:34:17" itemprop="dateModified" datetime="2024-03-08T11:34:17+08:00">2024-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>redis是一个基于 C 语言开发的开源 NoSQL 数据库，Redis 的数据是保存在内存中的（内存数据库，支持持久化）</p>
<span id="more"></span>

<p>⭐⭐ Redis快在哪？</p>
<ul>
<li>基于内存</li>
<li>基于 <strong>Reactor 模式</strong><ul>
<li>通过一个或多个输入同时传递给服务处理器的服务请求的<strong>事件驱动处理模式</strong>，服务端程序处理传入<strong>多路请求</strong> (IO多路复用)，并将它们同步分派给请求对应的处理线程。</li>
</ul>
</li>
<li>优化数据结构</li>
</ul>
<img src="/pic/redis数据结构.jpg" alt="Redis 数据类型概览" style="zoom:67%;" />

<p>⭐ 为什么要用redis&#x2F;缓存？</p>
<ul>
<li>高性能<ul>
<li>操作缓存就是直接操作内存，所以速度相当快。</li>
</ul>
</li>
<li>高并发<ul>
<li>MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g），使用 Redis 缓存之后很容易达到 10w+</li>
</ul>
</li>
</ul>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>单线程或单进程<strong>同时监测若干个文件描述符</strong>是否可以执行IO操作的能力。多路指的是<strong>多个socket连接</strong>，复用指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。</p>
<p>epoll是最新的也是目前最好的多路复用技术。采用多路 I&#x2F;O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p>
<h2 id="三种常见的缓存读写策略"><a href="#三种常见的缓存读写策略" class="headerlink" title="三种常见的缓存读写策略"></a>三种常见的缓存读写策略</h2><h3 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h3><p>服务端需要<strong>同时维系 db 和 cache</strong>，并且是以 db 的结果为准。</p>
<p><strong>写</strong>：</p>
<ul>
<li>先更新 db</li>
<li>然后直接删除 cache 。</li>
</ul>
<p><strong>读</strong> :</p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache 中读取不到的话，就从 db 中读取数据返回</li>
<li>再把数据放到 cache 中。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>首次请求数据一定不在 cache<ul>
<li>将热点数据可以提前放入 cache 中。</li>
</ul>
</li>
<li>写操作频繁，导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。</li>
</ul>
<h3 id="Read-x2F-Write-Through-Pattern（读写穿透）"><a href="#Read-x2F-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read&#x2F;Write Through Pattern（读写穿透）"></a>Read&#x2F;Write Through Pattern（读写穿透）</h3><p>服务端<strong>把 cache 视为主要数据存储</strong>，从中读取数据并将数据写入其中。<strong>cache 服务负责与db的同步</strong>，从而减轻了应用程序的职责。</p>
<p>但是开发中很少见， Redis 并没有提供 cache 将数据写入 db 的功能。</p>
<p><strong>写：</strong></p>
<ul>
<li>先查 cache，cache 中不存在，直接更新 db。</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）。</li>
</ul>
<p><strong>读：</strong></p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回 。</li>
<li>读取不到的话，由cache服务自己从 db 加载，写入到 cache 后返回响应。</li>
</ul>
<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 <strong>cache 服务自己来写入缓存</strong>的，这对客户端是透明的。</p>
<h3 id="Write-Behind-Pattern（异步缓存写入）"><a href="#Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Pattern（异步缓存写入）"></a>Write Behind Pattern（异步缓存写入）</h3><p> 和 Read&#x2F;Write Through Pattern 很相似，两者都是<strong>由 cache 服务来负责同步数据</strong>。</p>
<p>不同之处在于：Read&#x2F;Write Through 是同步更新 cache 和 db，而 Write Behind 则是<strong>只更新缓存</strong>，不直接更新 db，而是改为<strong>异步批量的方式来更新 db</strong>。</p>
<p>适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>
<h2 id="RediSearch-VS-ES"><a href="#RediSearch-VS-ES" class="headerlink" title="RediSearch VS ES"></a>RediSearch VS ES</h2><p>Redis 是可以实现全文搜索引擎功能的，需要借助 <strong>RediSearch</strong> ，这是一个基于 Redis 的搜索引擎模块。</p>
<p>RediSearch 支持中文分词、聚合统计、停用词、同义词、拼写检查、标签查询、向量相似度查询、多关键词搜索、分页搜索等功能，算是一个功能比较完善的全文搜索引擎了。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>性能更优秀：依赖 Redis 自身的高性能，基于内存操作（Elasticsearch 基于磁盘）。</p>
</li>
<li><p>较低内存占用实现快速索引：RediSearch 内部使用<strong>压缩的倒排索引</strong>，所以可以用较低的内存占用来实现索引的快速构建。</p>
</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>数据量限制：Elasticsearch 可以支持 PB 级别的数据量，可以轻松扩展到多个节点，利用分片机制提高可用性和性能。RedisSearch 是基于 Redis 实现的，其能存储的数据量受限于 Redis 的内存容量，不太适合存储大规模的数据（内存昂贵，扩展能力较差）。</p>
</li>
<li><p>分布式能力较差：Elasticsearch 是为分布式环境设计的，可以轻松扩展到多个节点。虽然 RedisSearch 支持分布式部署，但在实际应用中可能会面临一些挑战，如数据分片、节点间通信、数据一致性等问题。</p>
</li>
<li><p>聚合功能较弱：Elasticsearch 提供了丰富的聚合功能，而 RediSearch 的聚合功能相对较弱，只支持简单的聚合操作。</p>
</li>
<li><p>生态较差：Elasticsearch 可以轻松和常见的一些系统&#x2F;软件集成比如 Hadoop、Spark、Kibana，而 RedisSearch 则不具备该优势</p>
</li>
</ul>
<p>Elasticsearch 适用于全文搜索、复杂查询、实时数据分析和聚合的场景，而 RediSearch 适用于快速数据存储、缓存和简单查询的场景。</p>
<h2 id="sorted-set底层实现"><a href="#sorted-set底层实现" class="headerlink" title="sorted set底层实现"></a>sorted set底层实现</h2><p>Redis 有个比较常用的数据结构叫<strong>有序集合(sorted set，简称 zset)<strong>，可以保证有序且元素唯一，经常用于排行榜等需要进行统计排列的场景，是</strong>基于跳表和压缩表实现</strong>的。</p>
<ul>
<li>当有序集合对象同时满足以下两个条件时，使用 ziplist：<ol>
<li>键值对数量少于 128 个；</li>
<li>每个元素的长度小于 64 字节。</li>
</ol>
</li>
<li>如果不满足上述两个条件，那么使用 skiplist</li>
</ul>
<h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p>ziplist是一块<strong>连续的内存空间</strong>，元素之间紧挨着存储，没有任何冗余空隙。它的设计目标就是为了提高存储效率。ziplist可以用于存储字符串或整数，其中整数是按真正的<strong>二进制表示进行编码</strong>的，而不是编码成字符串序列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ziplist</span>&lt;</span>T&gt; &#123;</span><br><span class="line">    int32 zlbytes;       <span class="comment">// 整个压缩列表占用字节数，包含本身</span></span><br><span class="line">    int32 zltail_offset; <span class="comment">// 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点，从而可以在ziplist尾部快速的执行push，pop操作</span></span><br><span class="line">    int16 zllength;      <span class="comment">// 元素个数,最大值为2^16-1，若元素数量超出最大值，该字段失效</span></span><br><span class="line">    T[] entries;         <span class="comment">// 元素内容列表，挨个挨个紧凑存储</span></span><br><span class="line">    int8 zlend;          <span class="comment">// ziplist最后一个字节，标志压缩列表的结束，值恒为 0xFF（255）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h3><p>跳表在原始<strong>链表</strong>基础上，<strong>建立多级索引</strong>将增删改查的时间复杂度变为O(log n)。</p>
<p>以下图跳表为例，其原始链表存储按序存储 1-10，有 2 级索引，每级索引的索引个数都是基于下层元素个数的一半。</p>
<img src="/pic/跳表1.png" alt="img" style="zoom: 80%;" />

<p>查询元素 6：</p>
<ul>
<li>从 2 级索引开始，先来到节点 4。</li>
<li>查看 4 的后继节点，是 8 的 2 级索引，这个值大于 6，说明 2 级索引后续的索引都是大于 6 的，没有再往后搜寻的必要，我们索引向下查找。</li>
<li>来到 4 的 1 级索引，比对其后继节点为 6，查找结束。</li>
</ul>
<p>索引需要尽可能保证每一个上<strong>级索引都是下级索引的一半</strong>。</p>
<p>另外在增删元素是还伴随索引的增加和删除。</p>
<h4 id="vs-平衡树"><a href="#vs-平衡树" class="headerlink" title="vs 平衡树"></a>vs 平衡树</h4><p>平衡树的插入、删除和查询的时间复杂度和跳表一样都是 **O(log n)**。但是平衡树的每一次插入或者删除操作都需要保证整颗树左右节点的绝对平衡，只要不平衡就要通过旋转操作来保持平衡，这个过程是比较耗时的。</p>
<p>跳表是一种可以用来代替平衡树的数据结构。跳表使用<strong>概率平衡</strong>而不是严格强制的平衡，因此，跳表中的插入和删除算法比平衡树的等效算法简单得多，速度也快得多。</p>
<h4 id="vs-红黑树"><a href="#vs-红黑树" class="headerlink" title="vs 红黑树"></a>vs 红黑树</h4><p>红黑树是一个<strong>黑平衡树</strong>，相较于平衡树，维持平衡的开销要小一些。跳表的实现更简单，效率也更高。</p>
<h4 id="vs-B-树"><a href="#vs-B-树" class="headerlink" title="vs B+树"></a>vs B+树</h4><p>B+树更适合作为数据库和文件系统中常用的索引结构之一，它的核心思想是通过尽可能少的 IO ，定位到尽可能多的索引来获得查询数据。</p>
<p>对于 Redis 这种内存数据库来说，它对这些并不感冒，因为 Redis 作为内存数据库它不可能存储大量的数据，所以对于索引不需要通过 B+树这种方式进行维护，只需按照概率进行随机维护即可，节约内存。</p>
<p>而且使用跳表实现 zset 时相较前者来说更简单一些，在进行插入时只需通过索引将数据插入到链表中合适的位置再随机维护一定高度的索引即可，也不需要像 B+树那样插入时发现失衡时还需要对节点分裂与合并。</p>
<h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>Redis Database。通过创建<strong>快照</strong>获得数据在 <strong>某个时间点</strong> 上的副本，快照持久化是 Redis <strong>默认</strong>采用的持久化方式，在 <code>redis.conf</code> 配置文件中默认有此下配置</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>    #在<span class="number">900</span>秒(<span class="number">15</span>分钟)之后，如果至少有<span class="number">1</span>个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br><span class="line">save <span class="number">300</span> <span class="number">10</span>   #在<span class="number">300</span>秒(<span class="number">5</span>分钟)之后，如果至少有<span class="number">10</span>个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span> #在<span class="number">60</span>秒(<span class="number">1</span>分钟)之后，如果至少有<span class="number">10000</span>个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br></pre></td></tr></table></figure>

<p>redis提供了两个命令生成快照</p>
<ul>
<li>save，同步操作，会阻塞主线程</li>
<li>bgsave，fork一个子线程，不阻塞主线程，<strong>默认</strong>。</li>
</ul>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>Append-only file。与快照持久化相比，AOF 持久化的<strong>实时性</strong>更好。开启 AOF 持久化后，每执行一条更改数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式（ <code>fsync</code>策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中。</p>
<img src="/pic/AOF流程.png" alt="AOF 工作基本流程"  />

<ul>
<li>write：写入系统内核缓冲区后直接返回，不会立刻同步到硬盘。</li>
<li>fsync：强制刷新系统内核缓冲区 (同步到磁盘)</li>
</ul>
<h4 id="fsync策略"><a href="#fsync策略" class="headerlink" title="fsync策略"></a>fsync策略</h4><ul>
<li><code>appendfsync always</code><ul>
<li>主线程调用 <code>write</code> 执行写操作后，后台线程（ <code>aof_fsync</code> 线程）<strong>立即</strong>会调用 <code>fsync</code> 函数同步 AOF 文件（刷盘），<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能（<code>write</code> + <code>fsync</code>）。</li>
</ul>
</li>
<li><code>appendfsync everysec</code><ul>
<li>主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程（ <code>aof_fsync</code> 线程）<strong>每秒钟</strong>调用 <code>fsync</code> 函数（系统调用）同步一次 AOF 文件（<code>write</code>+<code>fsync</code>，<code>fsync</code>间隔为 1 秒）</li>
</ul>
</li>
<li><code>appendfsync no</code><ul>
<li>主线程调用 <code>write</code> 执行写操作后立即返回，让<strong>操作系统决定</strong>何时进行同步，Linux 下一般为 30 秒一次（<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定）。</li>
</ul>
</li>
</ul>
<h4 id="记录AOF日志文件"><a href="#记录AOF日志文件" class="headerlink" title="记录AOF日志文件"></a>记录AOF日志文件</h4><p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在<strong>执行完命令之后</strong>再记录日志</p>
<ul>
<li>避免额外的检查开销，AOF记录日志不会对命令进行语法检查</li>
<li>执行命令完之后再记录，不会阻塞当前命令的执行。</li>
</ul>
<p>风险</p>
<ul>
<li>刚执行完命令就宕机，导致对应的修改丢失</li>
<li>可能阻塞后续其他命令的执行 (AOF记录日志在主线程进行)</li>
</ul>
<h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>AOF文件过大时，redis会在后台自动重写产生新的AOF文件，数据一样但体积更小。重写期间的redis命令会写到AOF<strong>重写缓冲区</strong>，当重写完成后，重写缓冲区中的所有内容被追加到新AOF文件的末尾，并替代旧的AOF文件。</p>
<h4 id="AOF校验"><a href="#AOF校验" class="headerlink" title="AOF校验"></a>AOF校验</h4><p>Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。通过<strong>校验和</strong> (对整个 AOF 文件内容进行 CRC64 算法计算得出的数字) 验证AOF文件。</p>
<p>如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。</p>
<h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<h3 id="RDB-VS-AOF"><a href="#RDB-VS-AOF" class="headerlink" title="RDB VS AOF"></a>RDB VS AOF</h3><p><strong>RDB</strong></p>
<ul>
<li><p>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。</p>
</li>
<li><p>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</p>
</li>
</ul>
<p><strong>AOF</strong></p>
<ul>
<li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li>
<li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li>
<li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li>
</ul>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>对于<strong>读写命令</strong>来说，Redis 一直是<strong>单线程</strong>模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求。</p>
<h3 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h3><p>Redis基于Reactor模型 (高性能 IO 的基石) 设计了一套高效的事件处理模型。Redis 采用<strong>事件驱动机制</strong>来处理大量的网络IO。开发了自己的<strong>网络事件处理器</strong>，称为<strong>文本事件处理器</strong>。通过IO多路复用程序同时监听多个套接字，将套接字关联到不同的事件处理器。</p>
<p>文件事件处理器（file event handler）主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p>大体上说，6.0之前主要使用单线程进行处理，为什么不使用多线程？</p>
<ul>
<li>单线程容易并且更容易维护</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ul>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>为了提高网络IO读写性能，Redis 6.0引入多线程，默认是禁用的，需要修改redis.conf配置文件：<code>io-threads-do-reads yes</code>来开启支持。开启多线程后，还需要设置线程数，否则是不生效的。同样修改redis.conf配置文件<code>io-threads 4</code></p>
<p><img src="/pic/redis%E5%A4%9A%E7%BA%BF%E7%A8%8B" alt="图片"></p>
<h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>实际还有一些后台线程用于执行一些比较耗时的操作</p>
<ul>
<li><p>通过 <code>bio_close_file</code> 后台线程来释放 AOF &#x2F; RDB 等过程中产生的临时文件资源。</p>
</li>
<li><p>通过 <code>bio_aof_fsync</code> 后台线程调用 <code>fsync</code> 函数将系统内核缓冲区 还未同步到到磁盘 的数据 强制刷到磁盘（ AOF 文件）。</p>
</li>
<li><p>通过 <code>bio_lazy_free</code>后台线程释放 大对象（已删除）占用的内存空间.</p>
</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h3><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。</p>
<ul>
<li>节省内存<ul>
<li>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</li>
</ul>
</li>
<li>业务方便<ul>
<li>验证码有效期</li>
</ul>
</li>
</ul>
<h3 id="redis判断过期原理"><a href="#redis判断过期原理" class="headerlink" title="redis判断过期原理"></a>redis判断过期原理</h3><p>Redis 通过 <strong>过期字典</strong>（可以看作是 hash 表）来保存数据过期的时间，过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    dict *dict;     <span class="comment">//数据库键空间,保存着数据库中所有键值对</span></span><br><span class="line">    dict *expires   <span class="comment">// 过期字典,保存着键的过期时间</span></span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<h3 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h3><p>redis怎么删除过期的数据呢</p>
<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>只会在取出 key 的时候才对数据进行过期检查。这样<strong>对 CPU 最友好</strong>，但是可能会造成太多过期 key 没有被删除。</p>
<h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。对<strong>内存友好</strong>。</p>
<p>Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 。</p>
<h3 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h3><p><strong>和操作系统内存淘汰类似</strong>，Redis 提供 6 种数据淘汰策略，按是否设置过期时间可以分为两种，volatile前缀是从已设置过期时间的数据中选；allkeys前缀是从全局数据中选</p>
<ol>
<li><p>volatile-lru（least recently used）：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选<strong>最近最少使用</strong>的数据淘汰。</p>
</li>
<li><p>volatile-ttl：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选<strong>将要过期</strong>的数据淘汰。</p>
</li>
<li><p>volatile-random：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中<strong>任意选择</strong>数据淘汰。</p>
</li>
<li><p>allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除<strong>最近最少使用</strong>的 key（这个是最常用的）。</p>
</li>
<li><p>allkeys-random：从数据集（<code>server.db[i].dict</code>）中任<strong>意选择</strong>数据淘汰。</p>
</li>
<li><p>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧</p>
</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol>
<li>volatile-lfu（least frequently used）：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选<strong>最不经常使用</strong>的数据淘汰。</li>
<li>allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在整个键空间中，移除<strong>最不经常使用</strong>的 key。</li>
</ol>
<p>⭐⭐ 如何保证redis里的是热点数据？</p>
<ul>
<li>可以使用内存淘汰机制实现，使用allkeys-lru淘汰策略，频繁被访问的数据会被保留下来。</li>
</ul>
<h2 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h2><p>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。注意<strong>不要和sql中的事务混淆</strong>，redis事务不满足原子性和持久性，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。</p>
<p>在实际开发中，通常使用<strong>Lua</strong>脚本代替事务的功能。但是使用Lua脚本也无法实现原子性，Lua脚本不会回滚。</p>
<h3 id="对比sql事务"><a href="#对比sql事务" class="headerlink" title="对比sql事务"></a>对比sql事务</h3><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>redis事务不满足原子性，如果有命令出错了，其他的命令仍能正常运行；并且不支持回滚。</p>
<p>redis事务不满足持久性，AOF持久化策略中，no和everysec都会存在数据丢失的情况，always性能太差，基本不用。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>mysql的事务基于<strong>undo&#x2F;redo日志</strong>实现。undo记录修改前状态，rollback基于undo日志实现；redo记录修改后的状态，commit基于redo日志实现。<strong>redo日志是innodb专有的</strong>，所以innodb会支持事务</p>
<p>redis实现事务，是基于<strong>commands队列</strong></p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="减少网络传输"><a href="#减少网络传输" class="headerlink" title="减少网络传输"></a>减少网络传输</h3><p>Redis 命令的执行可以简化为以下 4 步：</p>
<ul>
<li>发送命令</li>
<li>命令排队</li>
<li>命令执行</li>
<li>返回结果</li>
</ul>
<p>耗费时间之和称为 <strong>Round Trip Time (RTT,往返时间)</strong> ，也就是<strong>数据在网络上传输的时间</strong>。</p>
<h4 id="原生批量操作"><a href="#原生批量操作" class="headerlink" title="原生批量操作"></a>原生批量操作</h4><p>使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。Redis 中有一些原生支持批量操作的命令</p>
<ul>
<li><p><code>MGET</code>(获取一个或多个指定 key 的值)、<code>MSET</code>(设置一个或多个指定 key 的值)</p>
</li>
<li><p><code>SADD</code>（向指定集合添加一个或多个元素）</p>
</li>
</ul>
<h4 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h4><p>对于不支持批量操作的命令，我们可以利用 <strong>pipeline（流水线)</strong> 将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。</p>
<ul>
<li><p>原生批量操作命令是原子操作，pipeline 是非原子操作。</p>
</li>
<li><p>pipeline 可以打包不同的命令，原生批量操作命令不可以。</p>
</li>
<li><p>原生批量操作命令是 Redis 服务端支持实现的，而 pipeline 需要服务端和客户端的共同实现</p>
</li>
</ul>
<h4 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h4><h3 id="BigKey"><a href="#BigKey" class="headerlink" title="BigKey"></a>BigKey</h3><p>如果一个 key 对应的 <strong>value 所占用的内存比较大</strong>，那这个 key 就可以看作是 bigkey</p>
<p><img src="/pic/bigkey%E5%88%A4%E5%AE%9A%E6%A0%87%E5%87%86.png" alt="bigkey 判定标准"></p>
<h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><ul>
<li>程序设计不当，比如直接使用 String 类型存储较大的文件对应的二进制数据。</li>
<li>对于业务的数据规模考虑不周到，比如使用集合类型的时候没有考虑到数据量的快速增长。</li>
<li>未及时清理垃圾数据，比如哈希中冗余了大量的无用键值对。</li>
</ul>
<h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><ul>
<li><p>客户端超时阻塞：由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</p>
</li>
<li><p>网络阻塞：每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</p>
</li>
<li><p>工作线程阻塞：如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令</p>
</li>
</ul>
<h4 id="发现bigkey"><a href="#发现bigkey" class="headerlink" title="发现bigkey"></a>发现bigkey</h4><ul>
<li>使用 Redis 自带的 <code>--bigkeys</code> 参数来查找。</li>
<li>使用 Redis 自带的 SCAN 命令</li>
<li>借助公有云的 Redis 分析服务</li>
</ul>
<h4 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h4><ul>
<li><p><strong>分割 bigkey</strong>：将一个 bigkey 分割为多个小 key。例如，将一个含有上万字段数量的 Hash 按照一定策略（比如二次哈希）拆分为多个 Hash。</p>
</li>
<li><p><strong>手动清理</strong>：Redis 4.0+ 可以使用 <code>UNLINK</code> 命令来异步删除一个或多个指定的 key。Redis 4.0 以下可以考虑使用 <code>SCAN</code> 命令结合 <code>DEL</code> 命令来分批次删除。</p>
</li>
<li><p><strong>采用合适的数据结构</strong>：例如，文件二进制数据不使用 String 保存、使用 HyperLogLog 统计页面 UV、Bitmap 保存状态信息（0&#x2F;1）。</p>
</li>
<li><p><strong>开启 lazy-free（惰性删除&#x2F;延迟释放）</strong>：lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</p>
</li>
</ul>
<h3 id="hotKey"><a href="#hotKey" class="headerlink" title="hotKey"></a>hotKey</h3><p>hotkey 出现的原因主要是某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。</p>
<h4 id="危害-1"><a href="#危害-1" class="headerlink" title="危害"></a>危害</h4><p>处理 hotkey 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。会引发缓存击穿问题。</p>
<h4 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h4><ul>
<li><p>使用 Redis 自带的 <code>--hotkeys</code> 参数来查找。</p>
</li>
<li><p>使用<code>MONITOR</code> 命令</p>
<ul>
<li>实时查看redis所有操作，对性能影响很大，禁止长时间开启。</li>
</ul>
</li>
<li><p>根据业务情况提前预估。</p>
</li>
</ul>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ul>
<li>读写分离<ul>
<li>主节点处理写请求，从节点处理读请求</li>
</ul>
</li>
<li>使用redis cluster<ul>
<li>将热点数据分散存储在多个redis节点上</li>
</ul>
</li>
<li>二级缓存<ul>
<li>hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中</li>
</ul>
</li>
</ul>
<h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><h4 id="定位慢查询命令"><a href="#定位慢查询命令" class="headerlink" title="定位慢查询命令"></a>定位慢查询命令</h4><p>在 <code>redis.conf</code> 文件中，我们可以使用 <code>slowlog-log-slower-than</code> 参数设置耗时命令的阈值，并使用 <code>slowlog-max-len</code> 参数设置耗时命令的最大记录条数。redis服务器会把执行时间超过阈值的命令记录在<strong>慢查询日志</strong>中。</p>
<p>使用<code>SLOWLOG GET</code>命令获取日志内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SLOWLOG GET      <span class="comment">#慢日志查询</span></span><br><span class="line">   1) (<span class="built_in">integer</span>) 5                <span class="comment">#唯一渐进的日志标识符。</span></span><br><span class="line">   2) (<span class="built_in">integer</span>) 1684326682       <span class="comment">#处理记录命令的 Unix 时间戳</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 12000            <span class="comment">#执行所需的时间量，以微秒为单位</span></span><br><span class="line">   4) 1) <span class="string">&quot;KEYS&quot;</span>                  <span class="comment">#组成命令参数的数组</span></span><br><span class="line">      2) <span class="string">&quot;*&quot;</span></span><br><span class="line">   5) <span class="string">&quot;172.17.0.1:61152&quot;</span>         <span class="comment">#客户端 IP 地址和端口</span></span><br><span class="line">   6) <span class="string">&quot;&quot;</span>                         <span class="comment">#客户端名称</span></span><br></pre></td></tr></table></figure>

<h2 id="Redis内存碎片"><a href="#Redis内存碎片" class="headerlink" title="Redis内存碎片"></a>Redis内存碎片</h2><h3 id="产生原因-1"><a href="#产生原因-1" class="headerlink" title="产生原因"></a>产生原因</h3><ul>
<li>Redis 存储数据时向操作系统<strong>申请</strong>的内存空间可能会<strong>大于</strong>数据<strong>实际需要</strong>的存储空间。</li>
<li>频繁修改 Redis 中的数据也会产生内存碎片。</li>
</ul>
<h3 id="查看内存碎片"><a href="#查看内存碎片" class="headerlink" title="查看内存碎片"></a>查看内存碎片</h3><p>使用 <code>info memory</code> 命令即可查看 Redis 内存相关的信息</p>
<p>Redis 内存碎片率的计算公式：<code>mem_fragmentation_ratio</code> （内存碎片率）&#x3D; <code>used_memory_rss</code> (操作系统实际分配给 Redis 的物理内存空间大小)&#x2F; <code>used_memory</code>(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)</p>
<p>通常<code>mem_fragmentation_ratio &gt; 1.5</code> 的话才需要清理内存碎片。</p>
<h3 id="清理碎片"><a href="#清理碎片" class="headerlink" title="清理碎片"></a>清理碎片</h3><p>通过 <code>config set</code> 命令将 <code>activedefrag</code> 配置项设置为 <code>yes</code> 即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> activedefrag <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>具体什么时候清理需要通过下面两个参数控制：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内存碎片占用空间达到 500mb 的时候开始清理</span></span><br><span class="line">config <span class="built_in">set</span> active-defrag-ignore-bytes 500mb</span><br><span class="line"><span class="comment"># 内存碎片率大于 1.5 的时候开始清理</span></span><br><span class="line">config <span class="built_in">set</span> active-defrag-threshold-lower 50</span><br></pre></td></tr></table></figure>

<p>通过 Redis 自动内存碎片清理机制可能会对 Redis 的性能产生影响，我们可以通过下面两个参数来减少对 Redis 性能的影响：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内存碎片清理所占用 CPU 时间的比例不低于 20%</span></span><br><span class="line">config <span class="built_in">set</span> active-defrag-cycle-min 20</span><br><span class="line"><span class="comment"># 内存碎片清理所占用 CPU 时间的比例不高于 50%</span></span><br><span class="line">config <span class="built_in">set</span> active-defrag-cycle-max 50</span><br></pre></td></tr></table></figure>

<p>另外，重启节点可以做到内存碎片重新整理。</p>
<h2 id="常见阻塞原因"><a href="#常见阻塞原因" class="headerlink" title="常见阻塞原因"></a>常见阻塞原因</h2><ul>
<li>O(n)命令</li>
<li>RDB快照</li>
<li>AOF<ul>
<li>日志记录</li>
<li>刷盘</li>
<li>重写</li>
</ul>
</li>
<li>bigkey<ul>
<li>操作时</li>
<li>查找时</li>
<li>删除时</li>
</ul>
</li>
<li>CPU竞争</li>
<li>网络问题</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%85%AB%E8%82%A1/" rel="tag"># 八股</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/03/02/11-00-37/" rel="prev" title="黑马点评">
      <i class="fa fa-chevron-left"></i> 黑马点评
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/03/09/11-00-37/" rel="next" title="java并发">
      java并发 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">IO多路复用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5"><span class="nav-number">3.</span> <span class="nav-text">三种常见的缓存读写策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache-Aside-Pattern%EF%BC%88%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">3.1.</span> <span class="nav-text">Cache Aside Pattern（旁路缓存模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">3.1.1.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-x2F-Write-Through-Pattern%EF%BC%88%E8%AF%BB%E5%86%99%E7%A9%BF%E9%80%8F%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">Read&#x2F;Write Through Pattern（读写穿透）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Write-Behind-Pattern%EF%BC%88%E5%BC%82%E6%AD%A5%E7%BC%93%E5%AD%98%E5%86%99%E5%85%A5%EF%BC%89"><span class="nav-number">3.3.</span> <span class="nav-text">Write Behind Pattern（异步缓存写入）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RediSearch-VS-ES"><span class="nav-number">4.</span> <span class="nav-text">RediSearch VS ES</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">4.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="nav-number">4.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sorted-set%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.</span> <span class="nav-text">sorted set底层实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ziplist"><span class="nav-number">5.1.</span> <span class="nav-text">ziplist</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#skiplist"><span class="nav-number">5.2.</span> <span class="nav-text">skiplist</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vs-%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="nav-number">5.2.1.</span> <span class="nav-text">vs 平衡树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vs-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">5.2.2.</span> <span class="nav-text">vs 红黑树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vs-B-%E6%A0%91"><span class="nav-number">5.2.3.</span> <span class="nav-text">vs B+树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="nav-number">6.</span> <span class="nav-text">持久化机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">6.1.</span> <span class="nav-text">RDB持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">6.2.</span> <span class="nav-text">AOF持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fsync%E7%AD%96%E7%95%A5"><span class="nav-number">6.2.1.</span> <span class="nav-text">fsync策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95AOF%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="nav-number">6.2.2.</span> <span class="nav-text">记录AOF日志文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF%E9%87%8D%E5%86%99"><span class="nav-number">6.2.3.</span> <span class="nav-text">AOF重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF%E6%A0%A1%E9%AA%8C"><span class="nav-number">6.2.4.</span> <span class="nav-text">AOF校验</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">6.3.</span> <span class="nav-text">混合持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-VS-AOF"><span class="nav-number">6.4.</span> <span class="nav-text">RDB VS AOF</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.</span> <span class="nav-text">线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.1.</span> <span class="nav-text">单线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">7.2.</span> <span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="nav-number">7.3.</span> <span class="nav-text">后台线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">8.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-number">8.1.</span> <span class="nav-text">过期时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E5%88%A4%E6%96%AD%E8%BF%87%E6%9C%9F%E5%8E%9F%E7%90%86"><span class="nav-number">8.2.</span> <span class="nav-text">redis判断过期原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-number">8.3.</span> <span class="nav-text">过期删除策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="nav-number">8.3.1.</span> <span class="nav-text">惰性删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="nav-number">8.3.2.</span> <span class="nav-text">定期删除</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">8.4.</span> <span class="nav-text">内存淘汰机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis%E4%BA%8B%E5%8A%A1"><span class="nav-number">9.</span> <span class="nav-text">redis事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94sql%E4%BA%8B%E5%8A%A1"><span class="nav-number">9.1.</span> <span class="nav-text">对比sql事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ACID"><span class="nav-number">9.1.1.</span> <span class="nav-text">ACID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">9.1.2.</span> <span class="nav-text">实现原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">10.</span> <span class="nav-text">性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%8F%E5%B0%91%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93"><span class="nav-number">10.1.</span> <span class="nav-text">减少网络传输</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">10.1.1.</span> <span class="nav-text">原生批量操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pipeline"><span class="nav-number">10.1.2.</span> <span class="nav-text">pipeline</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lua%E8%84%9A%E6%9C%AC"><span class="nav-number">10.1.3.</span> <span class="nav-text">Lua脚本</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BigKey"><span class="nav-number">10.2.</span> <span class="nav-text">BigKey</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="nav-number">10.2.1.</span> <span class="nav-text">产生原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%B1%E5%AE%B3"><span class="nav-number">10.2.2.</span> <span class="nav-text">危害</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E7%8E%B0bigkey"><span class="nav-number">10.2.3.</span> <span class="nav-text">发现bigkey</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86"><span class="nav-number">10.2.4.</span> <span class="nav-text">处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hotKey"><span class="nav-number">10.3.</span> <span class="nav-text">hotKey</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%B1%E5%AE%B3-1"><span class="nav-number">10.3.1.</span> <span class="nav-text">危害</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E7%8E%B0"><span class="nav-number">10.3.2.</span> <span class="nav-text">发现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3"><span class="nav-number">10.3.3.</span> <span class="nav-text">解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="nav-number">10.4.</span> <span class="nav-text">慢查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4"><span class="nav-number">10.4.1.</span> <span class="nav-text">定位慢查询命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="nav-number">11.</span> <span class="nav-text">Redis内存碎片</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0-1"><span class="nav-number">11.1.</span> <span class="nav-text">产生原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="nav-number">11.2.</span> <span class="nav-text">查看内存碎片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E7%90%86%E7%A2%8E%E7%89%87"><span class="nav-number">11.3.</span> <span class="nav-text">清理碎片</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%98%BB%E5%A1%9E%E5%8E%9F%E5%9B%A0"><span class="nav-number">12.</span> <span class="nav-text">常见阻塞原因</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Fang Jun</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">101</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fang Jun</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":300},"mobile":{"show":false},"rect":"opacity:0.7","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
